"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktodo_list"] = self["webpackChunktodo_list"] || []).push([["vendors-node_modules_oddbird_css-anchor-positioning_dist_css-anchor-positioning-fn_js"],{

/***/ "./node_modules/@oddbird/css-anchor-positioning/dist/css-anchor-positioning-fn.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@oddbird/css-anchor-positioning/dist/css-anchor-positioning-fn.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ nd)\n/* harmony export */ });\nvar ko = Object.defineProperty, So = Object.defineProperties;\nvar yo = Object.getOwnPropertyDescriptors;\nvar En = Object.getOwnPropertySymbols;\nvar bo = Object.prototype.hasOwnProperty, xo = Object.prototype.propertyIsEnumerable;\nvar $n = (t, e, n) => e in t ? ko(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, U = (t, e) => {\n  for (var n in e || (e = {}))\n    bo.call(e, n) && $n(t, n, e[n]);\n  if (En)\n    for (var n of En(e))\n      xo.call(e, n) && $n(t, n, e[n]);\n  return t;\n}, q = (t, e) => So(t, yo(e));\nvar R = (t, e, n) => new Promise((s, r) => {\n  var o = (u) => {\n    try {\n      l(n.next(u));\n    } catch (i) {\n      r(i);\n    }\n  }, a = (u) => {\n    try {\n      l(n.throw(u));\n    } catch (i) {\n      r(i);\n    }\n  }, l = (u) => u.done ? s(u.value) : Promise.resolve(u.value).then(o, a);\n  l((n = n.apply(t, e)).next());\n});\nconst nn = Math.min, Gt = Math.max, Te = Math.round, pe = Math.floor, St = (t) => ({\n  x: t,\n  y: t\n});\nfunction Co(t, e) {\n  return typeof t == \"function\" ? t(e) : t;\n}\nfunction wo(t) {\n  return U({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, t);\n}\nfunction To(t) {\n  return typeof t != \"number\" ? wo(t) : {\n    top: t,\n    right: t,\n    bottom: t,\n    left: t\n  };\n}\nfunction Ae(t) {\n  const {\n    x: e,\n    y: n,\n    width: s,\n    height: r\n  } = t;\n  return {\n    width: s,\n    height: r,\n    top: n,\n    left: e,\n    right: e + s,\n    bottom: n + r,\n    x: e,\n    y: n\n  };\n}\nfunction Ao(t, e) {\n  return R(this, null, function* () {\n    var n;\n    e === void 0 && (e = {});\n    const {\n      x: s,\n      y: r,\n      platform: o,\n      rects: a,\n      elements: l,\n      strategy: u\n    } = t, {\n      boundary: i = \"clippingAncestors\",\n      rootBoundary: c = \"viewport\",\n      elementContext: h = \"floating\",\n      altBoundary: f = !1,\n      padding: p = 0\n    } = Co(e, t), d = To(p), k = l[f ? h === \"floating\" ? \"reference\" : \"floating\" : h], y = Ae(yield o.getClippingRect({\n      element: (n = yield o.isElement == null ? void 0 : o.isElement(k)) == null || n ? k : k.contextElement || (yield o.getDocumentElement == null ? void 0 : o.getDocumentElement(l.floating)),\n      boundary: i,\n      rootBoundary: c,\n      strategy: u\n    })), x = h === \"floating\" ? {\n      x: s,\n      y: r,\n      width: a.floating.width,\n      height: a.floating.height\n    } : a.reference, A = yield o.getOffsetParent == null ? void 0 : o.getOffsetParent(l.floating), M = (yield o.isElement == null ? void 0 : o.isElement(A)) ? (yield o.getScale == null ? void 0 : o.getScale(A)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    }, et = Ae(o.convertOffsetParentRelativeRectToViewportRelativeRect ? yield o.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements: l,\n      rect: x,\n      offsetParent: A,\n      strategy: u\n    }) : x);\n    return {\n      top: (y.top - et.top + d.top) / M.y,\n      bottom: (et.bottom - y.bottom + d.bottom) / M.y,\n      left: (y.left - et.left + d.left) / M.x,\n      right: (et.right - y.right + d.right) / M.x\n    };\n  });\n}\nfunction Re() {\n  return typeof window != \"undefined\";\n}\nfunction te(t) {\n  return Is(t) ? (t.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction it(t) {\n  var e;\n  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;\n}\nfunction bt(t) {\n  var e;\n  return (e = (Is(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;\n}\nfunction Is(t) {\n  return Re() ? t instanceof Node || t instanceof it(t).Node : !1;\n}\nfunction ct(t) {\n  return Re() ? t instanceof Element || t instanceof it(t).Element : !1;\n}\nfunction yt(t) {\n  return Re() ? t instanceof HTMLElement || t instanceof it(t).HTMLElement : !1;\n}\nfunction Ln(t) {\n  return !Re() || typeof ShadowRoot == \"undefined\" ? !1 : t instanceof ShadowRoot || t instanceof it(t).ShadowRoot;\n}\nconst vo = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction he(t) {\n  const {\n    overflow: e,\n    overflowX: n,\n    overflowY: s,\n    display: r\n  } = ut(t);\n  return /auto|scroll|overlay|hidden|clip/.test(e + s + n) && !vo.has(r);\n}\nconst Eo = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction $o(t) {\n  return Eo.has(te(t));\n}\nconst Lo = [\":popover-open\", \":modal\"];\nfunction _e(t) {\n  return Lo.some((e) => {\n    try {\n      return t.matches(e);\n    } catch (n) {\n      return !1;\n    }\n  });\n}\nconst Po = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"], Oo = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"], Ro = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction kn(t) {\n  const e = Sn(), n = ct(t) ? ut(t) : t;\n  return Po.some((s) => n[s] ? n[s] !== \"none\" : !1) || (n.containerType ? n.containerType !== \"normal\" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !e && (n.filter ? n.filter !== \"none\" : !1) || Oo.some((s) => (n.willChange || \"\").includes(s)) || Ro.some((s) => (n.contain || \"\").includes(s));\n}\nfunction _o(t) {\n  let e = Pt(t);\n  for (; yt(e) && !Qt(e); ) {\n    if (kn(e))\n      return e;\n    if (_e(e))\n      return null;\n    e = Pt(e);\n  }\n  return null;\n}\nfunction Sn() {\n  return typeof CSS == \"undefined\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst Io = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction Qt(t) {\n  return Io.has(te(t));\n}\nfunction ut(t) {\n  return it(t).getComputedStyle(t);\n}\nfunction Ie(t) {\n  return ct(t) ? {\n    scrollLeft: t.scrollLeft,\n    scrollTop: t.scrollTop\n  } : {\n    scrollLeft: t.scrollX,\n    scrollTop: t.scrollY\n  };\n}\nfunction Pt(t) {\n  if (te(t) === \"html\")\n    return t;\n  const e = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    t.assignedSlot || // DOM Element detected.\n    t.parentNode || // ShadowRoot detected.\n    Ln(t) && t.host || // Fallback.\n    bt(t)\n  );\n  return Ln(e) ? e.host : e;\n}\nfunction Ns(t) {\n  const e = Pt(t);\n  return Qt(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : yt(e) && he(e) ? e : Ns(e);\n}\nfunction le(t, e, n) {\n  var s;\n  e === void 0 && (e = []), n === void 0 && (n = !0);\n  const r = Ns(t), o = r === ((s = t.ownerDocument) == null ? void 0 : s.body), a = it(r);\n  if (o) {\n    const l = sn(a);\n    return e.concat(a, a.visualViewport || [], he(r) ? r : [], l && n ? le(l) : []);\n  }\n  return e.concat(r, le(r, [], n));\n}\nfunction sn(t) {\n  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;\n}\nfunction Ds(t) {\n  const e = ut(t);\n  let n = parseFloat(e.width) || 0, s = parseFloat(e.height) || 0;\n  const r = yt(t), o = r ? t.offsetWidth : n, a = r ? t.offsetHeight : s, l = Te(n) !== o || Te(s) !== a;\n  return l && (n = o, s = a), {\n    width: n,\n    height: s,\n    $: l\n  };\n}\nfunction yn(t) {\n  return ct(t) ? t : t.contextElement;\n}\nfunction qt(t) {\n  const e = yn(t);\n  if (!yt(e))\n    return St(1);\n  const n = e.getBoundingClientRect(), {\n    width: s,\n    height: r,\n    $: o\n  } = Ds(e);\n  let a = (o ? Te(n.width) : n.width) / s, l = (o ? Te(n.height) : n.height) / r;\n  return (!a || !Number.isFinite(a)) && (a = 1), (!l || !Number.isFinite(l)) && (l = 1), {\n    x: a,\n    y: l\n  };\n}\nconst No = /* @__PURE__ */ St(0);\nfunction Fs(t) {\n  const e = it(t);\n  return !Sn() || !e.visualViewport ? No : {\n    x: e.visualViewport.offsetLeft,\n    y: e.visualViewport.offsetTop\n  };\n}\nfunction Do(t, e, n) {\n  return e === void 0 && (e = !1), !n || e && n !== it(t) ? !1 : e;\n}\nfunction Dt(t, e, n, s) {\n  e === void 0 && (e = !1), n === void 0 && (n = !1);\n  const r = t.getBoundingClientRect(), o = yn(t);\n  let a = St(1);\n  e && (s ? ct(s) && (a = qt(s)) : a = qt(t));\n  const l = Do(o, n, s) ? Fs(o) : St(0);\n  let u = (r.left + l.x) / a.x, i = (r.top + l.y) / a.y, c = r.width / a.x, h = r.height / a.y;\n  if (o) {\n    const f = it(o), p = s && ct(s) ? it(s) : s;\n    let d = f, m = sn(d);\n    for (; m && s && p !== d; ) {\n      const k = qt(m), y = m.getBoundingClientRect(), x = ut(m), A = y.left + (m.clientLeft + parseFloat(x.paddingLeft)) * k.x, M = y.top + (m.clientTop + parseFloat(x.paddingTop)) * k.y;\n      u *= k.x, i *= k.y, c *= k.x, h *= k.y, u += A, i += M, d = it(m), m = sn(d);\n    }\n  }\n  return Ae({\n    width: c,\n    height: h,\n    x: u,\n    y: i\n  });\n}\nfunction Ne(t, e) {\n  const n = Ie(t).scrollLeft;\n  return e ? e.left + n : Dt(bt(t)).left + n;\n}\nfunction Ms(t, e) {\n  const n = t.getBoundingClientRect(), s = n.left + e.scrollLeft - Ne(t, n), r = n.top + e.scrollTop;\n  return {\n    x: s,\n    y: r\n  };\n}\nfunction Fo(t) {\n  let {\n    elements: e,\n    rect: n,\n    offsetParent: s,\n    strategy: r\n  } = t;\n  const o = r === \"fixed\", a = bt(s), l = e ? _e(e.floating) : !1;\n  if (s === a || l && o)\n    return n;\n  let u = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, i = St(1);\n  const c = St(0), h = yt(s);\n  if ((h || !h && !o) && ((te(s) !== \"body\" || he(a)) && (u = Ie(s)), yt(s))) {\n    const p = Dt(s);\n    i = qt(s), c.x = p.x + s.clientLeft, c.y = p.y + s.clientTop;\n  }\n  const f = a && !h && !o ? Ms(a, u) : St(0);\n  return {\n    width: n.width * i.x,\n    height: n.height * i.y,\n    x: n.x * i.x - u.scrollLeft * i.x + c.x + f.x,\n    y: n.y * i.y - u.scrollTop * i.y + c.y + f.y\n  };\n}\nfunction Mo(t) {\n  return Array.from(t.getClientRects());\n}\nfunction jo(t) {\n  const e = bt(t), n = Ie(t), s = t.ownerDocument.body, r = Gt(e.scrollWidth, e.clientWidth, s.scrollWidth, s.clientWidth), o = Gt(e.scrollHeight, e.clientHeight, s.scrollHeight, s.clientHeight);\n  let a = -n.scrollLeft + Ne(t);\n  const l = -n.scrollTop;\n  return ut(s).direction === \"rtl\" && (a += Gt(e.clientWidth, s.clientWidth) - r), {\n    width: r,\n    height: o,\n    x: a,\n    y: l\n  };\n}\nconst Pn = 25;\nfunction Bo(t, e) {\n  const n = it(t), s = bt(t), r = n.visualViewport;\n  let o = s.clientWidth, a = s.clientHeight, l = 0, u = 0;\n  if (r) {\n    o = r.width, a = r.height;\n    const c = Sn();\n    (!c || c && e === \"fixed\") && (l = r.offsetLeft, u = r.offsetTop);\n  }\n  const i = Ne(s);\n  if (i <= 0) {\n    const c = s.ownerDocument, h = c.body, f = getComputedStyle(h), p = c.compatMode === \"CSS1Compat\" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, d = Math.abs(s.clientWidth - h.clientWidth - p);\n    d <= Pn && (o -= d);\n  } else i <= Pn && (o += i);\n  return {\n    width: o,\n    height: a,\n    x: l,\n    y: u\n  };\n}\nconst Wo = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction Uo(t, e) {\n  const n = Dt(t, !0, e === \"fixed\"), s = n.top + t.clientTop, r = n.left + t.clientLeft, o = yt(t) ? qt(t) : St(1), a = t.clientWidth * o.x, l = t.clientHeight * o.y, u = r * o.x, i = s * o.y;\n  return {\n    width: a,\n    height: l,\n    x: u,\n    y: i\n  };\n}\nfunction On(t, e, n) {\n  let s;\n  if (e === \"viewport\")\n    s = Bo(t, n);\n  else if (e === \"document\")\n    s = jo(bt(t));\n  else if (ct(e))\n    s = Uo(e, n);\n  else {\n    const r = Fs(t);\n    s = {\n      x: e.x - r.x,\n      y: e.y - r.y,\n      width: e.width,\n      height: e.height\n    };\n  }\n  return Ae(s);\n}\nfunction js(t, e) {\n  const n = Pt(t);\n  return n === e || !ct(n) || Qt(n) ? !1 : ut(n).position === \"fixed\" || js(n, e);\n}\nfunction zo(t, e) {\n  const n = e.get(t);\n  if (n)\n    return n;\n  let s = le(t, [], !1).filter((l) => ct(l) && te(l) !== \"body\"), r = null;\n  const o = ut(t).position === \"fixed\";\n  let a = o ? Pt(t) : t;\n  for (; ct(a) && !Qt(a); ) {\n    const l = ut(a), u = kn(a);\n    !u && l.position === \"fixed\" && (r = null), (o ? !u && !r : !u && l.position === \"static\" && !!r && Wo.has(r.position) || he(a) && !u && js(t, a)) ? s = s.filter((c) => c !== a) : r = l, a = Pt(a);\n  }\n  return e.set(t, s), s;\n}\nfunction Vo(t) {\n  let {\n    element: e,\n    boundary: n,\n    rootBoundary: s,\n    strategy: r\n  } = t;\n  const a = [...n === \"clippingAncestors\" ? _e(e) ? [] : zo(e, this._c) : [].concat(n), s], l = a[0], u = a.reduce((i, c) => {\n    const h = On(e, c, r);\n    return i.top = Gt(h.top, i.top), i.right = nn(h.right, i.right), i.bottom = nn(h.bottom, i.bottom), i.left = Gt(h.left, i.left), i;\n  }, On(e, l, r));\n  return {\n    width: u.right - u.left,\n    height: u.bottom - u.top,\n    x: u.left,\n    y: u.top\n  };\n}\nfunction Ho(t) {\n  const {\n    width: e,\n    height: n\n  } = Ds(t);\n  return {\n    width: e,\n    height: n\n  };\n}\nfunction Go(t, e, n) {\n  const s = yt(e), r = bt(e), o = n === \"fixed\", a = Dt(t, !0, o, e);\n  let l = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const u = St(0);\n  function i() {\n    u.x = Ne(r);\n  }\n  if (s || !s && !o)\n    if ((te(e) !== \"body\" || he(r)) && (l = Ie(e)), s) {\n      const p = Dt(e, !0, o, e);\n      u.x = p.x + e.clientLeft, u.y = p.y + e.clientTop;\n    } else r && i();\n  o && !s && r && i();\n  const c = r && !s && !o ? Ms(r, l) : St(0), h = a.left + l.scrollLeft - u.x - c.x, f = a.top + l.scrollTop - u.y - c.y;\n  return {\n    x: h,\n    y: f,\n    width: a.width,\n    height: a.height\n  };\n}\nfunction Fe(t) {\n  return ut(t).position === \"static\";\n}\nfunction Rn(t, e) {\n  if (!yt(t) || ut(t).position === \"fixed\")\n    return null;\n  if (e)\n    return e(t);\n  let n = t.offsetParent;\n  return bt(t) === n && (n = n.ownerDocument.body), n;\n}\nfunction Bs(t, e) {\n  const n = it(t);\n  if (_e(t))\n    return n;\n  if (!yt(t)) {\n    let r = Pt(t);\n    for (; r && !Qt(r); ) {\n      if (ct(r) && !Fe(r))\n        return r;\n      r = Pt(r);\n    }\n    return n;\n  }\n  let s = Rn(t, e);\n  for (; s && $o(s) && Fe(s); )\n    s = Rn(s, e);\n  return s && Qt(s) && Fe(s) && !kn(s) ? n : s || _o(t) || n;\n}\nconst qo = function(t) {\n  return R(this, null, function* () {\n    const e = this.getOffsetParent || Bs, n = this.getDimensions, s = yield n(t.floating);\n    return {\n      reference: Go(t.reference, yield e(t.floating), t.strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        width: s.width,\n        height: s.height\n      }\n    };\n  });\n};\nfunction Ko(t) {\n  return ut(t).direction === \"rtl\";\n}\nconst V = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: Fo,\n  getDocumentElement: bt,\n  getClippingRect: Vo,\n  getOffsetParent: Bs,\n  getElementRects: qo,\n  getClientRects: Mo,\n  getDimensions: Ho,\n  getScale: qt,\n  isElement: ct,\n  isRTL: Ko\n};\nfunction Ws(t, e) {\n  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;\n}\nfunction Qo(t, e) {\n  let n = null, s;\n  const r = bt(t);\n  function o() {\n    var l;\n    clearTimeout(s), (l = n) == null || l.disconnect(), n = null;\n  }\n  function a(l, u) {\n    l === void 0 && (l = !1), u === void 0 && (u = 1), o();\n    const i = t.getBoundingClientRect(), {\n      left: c,\n      top: h,\n      width: f,\n      height: p\n    } = i;\n    if (l || e(), !f || !p)\n      return;\n    const d = pe(h), m = pe(r.clientWidth - (c + f)), k = pe(r.clientHeight - (h + p)), y = pe(c), A = {\n      rootMargin: -d + \"px \" + -m + \"px \" + -k + \"px \" + -y + \"px\",\n      threshold: Gt(0, nn(1, u)) || 1\n    };\n    let M = !0;\n    function et(w) {\n      const C = w[0].intersectionRatio;\n      if (C !== u) {\n        if (!M)\n          return a();\n        C ? a(!1, C) : s = setTimeout(() => {\n          a(!1, 1e-7);\n        }, 1e3);\n      }\n      C === 1 && !Ws(i, t.getBoundingClientRect()) && a(), M = !1;\n    }\n    try {\n      n = new IntersectionObserver(et, q(U({}, A), {\n        // Handle <iframe>s\n        root: r.ownerDocument\n      }));\n    } catch (w) {\n      n = new IntersectionObserver(et, A);\n    }\n    n.observe(t);\n  }\n  return a(!0), o;\n}\nfunction rn(t, e, n, s) {\n  s === void 0 && (s = {});\n  const {\n    ancestorScroll: r = !0,\n    ancestorResize: o = !0,\n    elementResize: a = typeof ResizeObserver == \"function\",\n    layoutShift: l = typeof IntersectionObserver == \"function\",\n    animationFrame: u = !1\n  } = s, i = yn(t), c = r || o ? [...i ? le(i) : [], ...le(e)] : [];\n  c.forEach((y) => {\n    r && y.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), o && y.addEventListener(\"resize\", n);\n  });\n  const h = i && l ? Qo(i, n) : null;\n  let f = -1, p = null;\n  a && (p = new ResizeObserver((y) => {\n    let [x] = y;\n    x && x.target === i && p && (p.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {\n      var A;\n      (A = p) == null || A.observe(e);\n    })), n();\n  }), i && !u && p.observe(i), p.observe(e));\n  let d, m = u ? Dt(t) : null;\n  u && k();\n  function k() {\n    const y = Dt(t);\n    m && !Ws(m, y) && n(), m = y, d = requestAnimationFrame(k);\n  }\n  return n(), () => {\n    var y;\n    c.forEach((x) => {\n      r && x.removeEventListener(\"scroll\", n), o && x.removeEventListener(\"resize\", n);\n    }), h == null || h(), (y = p) == null || y.disconnect(), p = null, u && cancelAnimationFrame(d);\n  };\n}\nconst Yo = Ao, { hasOwnProperty: bn } = Object.prototype, ne = function() {\n};\nfunction _n(t) {\n  return typeof t == \"function\" ? t : ne;\n}\nfunction In(t, e) {\n  return function(n, s, r) {\n    n.type === e && t.call(this, n, s, r);\n  };\n}\nfunction Xo(t, e) {\n  const n = e.structure, s = [];\n  for (const r in n) {\n    if (bn.call(n, r) === !1)\n      continue;\n    let o = n[r];\n    const a = {\n      name: r,\n      type: !1,\n      nullable: !1\n    };\n    Array.isArray(o) || (o = [o]);\n    for (const l of o)\n      l === null ? a.nullable = !0 : typeof l == \"string\" ? a.type = \"node\" : Array.isArray(l) && (a.type = \"list\");\n    a.type && s.push(a);\n  }\n  return s.length ? {\n    context: e.walkContext,\n    fields: s\n  } : null;\n}\nfunction Jo(t) {\n  const e = {};\n  for (const n in t.node)\n    if (bn.call(t.node, n)) {\n      const s = t.node[n];\n      if (!s.structure)\n        throw new Error(\"Missed `structure` field in `\" + n + \"` node type definition\");\n      e[n] = Xo(n, s);\n    }\n  return e;\n}\nfunction Nn(t, e) {\n  const n = t.fields.slice(), s = t.context, r = typeof s == \"string\";\n  return e && n.reverse(), function(o, a, l, u) {\n    let i;\n    r && (i = a[s], a[s] = o);\n    for (const c of n) {\n      const h = o[c.name];\n      if (!c.nullable || h) {\n        if (c.type === \"list\") {\n          if (e ? h.reduceRight(u, !1) : h.reduce(u, !1))\n            return !0;\n        } else if (l(h))\n          return !0;\n      }\n    }\n    r && (a[s] = i);\n  };\n}\nfunction Dn({\n  StyleSheet: t,\n  Atrule: e,\n  Rule: n,\n  Block: s,\n  DeclarationList: r\n}) {\n  return {\n    Atrule: {\n      StyleSheet: t,\n      Atrule: e,\n      Rule: n,\n      Block: s\n    },\n    Rule: {\n      StyleSheet: t,\n      Atrule: e,\n      Rule: n,\n      Block: s\n    },\n    Declaration: {\n      StyleSheet: t,\n      Atrule: e,\n      Rule: n,\n      Block: s,\n      DeclarationList: r\n    }\n  };\n}\nfunction Zo(t) {\n  const e = Jo(t), n = {}, s = {}, r = Symbol(\"break-walk\"), o = Symbol(\"skip-node\");\n  for (const i in e)\n    bn.call(e, i) && e[i] !== null && (n[i] = Nn(e[i], !1), s[i] = Nn(e[i], !0));\n  const a = Dn(n), l = Dn(s), u = function(i, c) {\n    function h(y, x, A) {\n      const M = f.call(k, y, x, A);\n      return M === r ? !0 : M === o ? !1 : !!(d.hasOwnProperty(y.type) && d[y.type](y, k, h, m) || p.call(k, y, x, A) === r);\n    }\n    let f = ne, p = ne, d = n, m = (y, x, A, M) => y || h(x, A, M);\n    const k = {\n      break: r,\n      skip: o,\n      root: i,\n      stylesheet: null,\n      atrule: null,\n      atrulePrelude: null,\n      rule: null,\n      selector: null,\n      block: null,\n      declaration: null,\n      function: null\n    };\n    if (typeof c == \"function\")\n      f = c;\n    else if (c && (f = _n(c.enter), p = _n(c.leave), c.reverse && (d = s), c.visit)) {\n      if (a.hasOwnProperty(c.visit))\n        d = c.reverse ? l[c.visit] : a[c.visit];\n      else if (!e.hasOwnProperty(c.visit))\n        throw new Error(\"Bad value `\" + c.visit + \"` for `visit` option (should be: \" + Object.keys(e).sort().join(\", \") + \")\");\n      f = In(f, c.visit), p = In(p, c.visit);\n    }\n    if (f === ne && p === ne)\n      throw new Error(\"Neither `enter` nor `leave` walker handler is set or both aren't a function\");\n    h(i);\n  };\n  return u.break = r, u.skip = o, u.find = function(i, c) {\n    let h = null;\n    return u(i, function(f, p, d) {\n      if (c.call(this, f, p, d))\n        return h = f, r;\n    }), h;\n  }, u.findLast = function(i, c) {\n    let h = null;\n    return u(i, {\n      reverse: !0,\n      enter(f, p, d) {\n        if (c.call(this, f, p, d))\n          return h = f, r;\n      }\n    }), h;\n  }, u.findAll = function(i, c) {\n    const h = [];\n    return u(i, function(f, p, d) {\n      c.call(this, f, p, d) && h.push(f);\n    }), h;\n  }, u;\n}\nconst vt = 0, g = 1, T = 2, z = 3, I = 4, Tt = 5, ta = 6, Q = 7, at = 8, L = 9, b = 10, F = 11, E = 12, W = 13, De = 14, nt = 15, X = 16, tt = 17, ft = 18, ee = 19, ce = 20, _ = 21, S = 22, ht = 23, Yt = 24, Y = 25, ea = 0;\nfunction rt(t) {\n  return t >= 48 && t <= 57;\n}\nfunction Xt(t) {\n  return rt(t) || // 0 .. 9\n  t >= 65 && t <= 70 || // A .. F\n  t >= 97 && t <= 102;\n}\nfunction xn(t) {\n  return t >= 65 && t <= 90;\n}\nfunction na(t) {\n  return t >= 97 && t <= 122;\n}\nfunction sa(t) {\n  return xn(t) || na(t);\n}\nfunction ra(t) {\n  return t >= 128;\n}\nfunction ve(t) {\n  return sa(t) || ra(t) || t === 95;\n}\nfunction Us(t) {\n  return ve(t) || rt(t) || t === 45;\n}\nfunction ia(t) {\n  return t >= 0 && t <= 8 || t === 11 || t >= 14 && t <= 31 || t === 127;\n}\nfunction Ee(t) {\n  return t === 10 || t === 13 || t === 12;\n}\nfunction Ft(t) {\n  return Ee(t) || t === 32 || t === 9;\n}\nfunction kt(t, e) {\n  return !(t !== 92 || Ee(e) || e === ea);\n}\nfunction Me(t, e, n) {\n  return t === 45 ? ve(e) || e === 45 || kt(e, n) : ve(t) ? !0 : t === 92 ? kt(t, e) : !1;\n}\nfunction je(t, e, n) {\n  return t === 43 || t === 45 ? rt(e) ? 2 : e === 46 && rt(n) ? 3 : 0 : t === 46 ? rt(e) ? 2 : 0 : rt(t) ? 1 : 0;\n}\nfunction zs(t) {\n  return t === 65279 || t === 65534 ? 1 : 0;\n}\nconst on = new Array(128), oa = 128, ye = 130, Vs = 131, Cn = 132, Hs = 133;\nfor (let t = 0; t < on.length; t++)\n  on[t] = Ft(t) && ye || rt(t) && Vs || ve(t) && Cn || ia(t) && Hs || t || oa;\nfunction Be(t) {\n  return t < 128 ? on[t] : Cn;\n}\nfunction Kt(t, e) {\n  return e < t.length ? t.charCodeAt(e) : 0;\n}\nfunction an(t, e, n) {\n  return n === 13 && Kt(t, e + 1) === 10 ? 2 : 1;\n}\nfunction Gs(t, e, n) {\n  let s = t.charCodeAt(e);\n  return xn(s) && (s = s | 32), s === n;\n}\nfunction $e(t, e, n, s) {\n  if (n - e !== s.length || e < 0 || n > t.length)\n    return !1;\n  for (let r = e; r < n; r++) {\n    const o = s.charCodeAt(r - e);\n    let a = t.charCodeAt(r);\n    if (xn(a) && (a = a | 32), a !== o)\n      return !1;\n  }\n  return !0;\n}\nfunction aa(t, e) {\n  for (; e >= 0 && Ft(t.charCodeAt(e)); e--)\n    ;\n  return e + 1;\n}\nfunction de(t, e) {\n  for (; e < t.length && Ft(t.charCodeAt(e)); e++)\n    ;\n  return e;\n}\nfunction We(t, e) {\n  for (; e < t.length && rt(t.charCodeAt(e)); e++)\n    ;\n  return e;\n}\nfunction Jt(t, e) {\n  if (e += 2, Xt(Kt(t, e - 1))) {\n    for (const s = Math.min(t.length, e + 5); e < s && Xt(Kt(t, e)); e++)\n      ;\n    const n = Kt(t, e);\n    Ft(n) && (e += an(t, e, n));\n  }\n  return e;\n}\nfunction ge(t, e) {\n  for (; e < t.length; e++) {\n    const n = t.charCodeAt(e);\n    if (!Us(n)) {\n      if (kt(n, Kt(t, e + 1))) {\n        e = Jt(t, e) - 1;\n        continue;\n      }\n      break;\n    }\n  }\n  return e;\n}\nfunction qs(t, e) {\n  let n = t.charCodeAt(e);\n  if ((n === 43 || n === 45) && (n = t.charCodeAt(e += 1)), rt(n) && (e = We(t, e + 1), n = t.charCodeAt(e)), n === 46 && rt(t.charCodeAt(e + 1)) && (e += 2, e = We(t, e)), Gs(\n    t,\n    e,\n    101\n    /* e */\n  )) {\n    let s = 0;\n    n = t.charCodeAt(e + 1), (n === 45 || n === 43) && (s = 1, n = t.charCodeAt(e + 2)), rt(n) && (e = We(t, e + 1 + s + 1));\n  }\n  return e;\n}\nfunction Ue(t, e) {\n  for (; e < t.length; e++) {\n    const n = t.charCodeAt(e);\n    if (n === 41) {\n      e++;\n      break;\n    }\n    kt(n, Kt(t, e + 1)) && (e = Jt(t, e));\n  }\n  return e;\n}\nfunction Ks(t) {\n  if (t.length === 1 && !Xt(t.charCodeAt(0)))\n    return t[0];\n  let e = parseInt(t, 16);\n  return (e === 0 || // If this number is zero,\n  e >= 55296 && e <= 57343 || // or is for a surrogate,\n  e > 1114111) && (e = 65533), String.fromCodePoint(e);\n}\nconst Qs = [\n  \"EOF-token\",\n  \"ident-token\",\n  \"function-token\",\n  \"at-keyword-token\",\n  \"hash-token\",\n  \"string-token\",\n  \"bad-string-token\",\n  \"url-token\",\n  \"bad-url-token\",\n  \"delim-token\",\n  \"number-token\",\n  \"percentage-token\",\n  \"dimension-token\",\n  \"whitespace-token\",\n  \"CDO-token\",\n  \"CDC-token\",\n  \"colon-token\",\n  \"semicolon-token\",\n  \"comma-token\",\n  \"[-token\",\n  \"]-token\",\n  \"(-token\",\n  \")-token\",\n  \"{-token\",\n  \"}-token\",\n  \"comment-token\"\n], la = 16 * 1024;\nfunction Le(t = null, e) {\n  return t === null || t.length < e ? new Uint32Array(Math.max(e + 1024, la)) : t;\n}\nconst Fn = 10, ca = 12, Mn = 13;\nfunction jn(t) {\n  const e = t.source, n = e.length, s = e.length > 0 ? zs(e.charCodeAt(0)) : 0, r = Le(t.lines, n), o = Le(t.columns, n);\n  let a = t.startLine, l = t.startColumn;\n  for (let u = s; u < n; u++) {\n    const i = e.charCodeAt(u);\n    r[u] = a, o[u] = l++, (i === Fn || i === Mn || i === ca) && (i === Mn && u + 1 < n && e.charCodeAt(u + 1) === Fn && (u++, r[u] = a, o[u] = l), a++, l = 1);\n  }\n  r[n] = a, o[n] = l, t.lines = r, t.columns = o, t.computed = !0;\n}\nclass ua {\n  constructor(e, n, s, r) {\n    this.setSource(e, n, s, r), this.lines = null, this.columns = null;\n  }\n  setSource(e = \"\", n = 0, s = 1, r = 1) {\n    this.source = e, this.startOffset = n, this.startLine = s, this.startColumn = r, this.computed = !1;\n  }\n  getLocation(e, n) {\n    return this.computed || jn(this), {\n      source: n,\n      offset: this.startOffset + e,\n      line: this.lines[e],\n      column: this.columns[e]\n    };\n  }\n  getLocationRange(e, n, s) {\n    return this.computed || jn(this), {\n      source: s,\n      start: {\n        offset: this.startOffset + e,\n        line: this.lines[e],\n        column: this.columns[e]\n      },\n      end: {\n        offset: this.startOffset + n,\n        line: this.lines[n],\n        column: this.columns[n]\n      }\n    };\n  }\n}\nconst dt = 16777215, gt = 24, Mt = new Uint8Array(32);\nMt[T] = S;\nMt[_] = S;\nMt[ee] = ce;\nMt[ht] = Yt;\nfunction Bn(t) {\n  return Mt[t] !== 0;\n}\nclass ha {\n  constructor(e, n) {\n    this.setSource(e, n);\n  }\n  reset() {\n    this.eof = !1, this.tokenIndex = -1, this.tokenType = 0, this.tokenStart = this.firstCharOffset, this.tokenEnd = this.firstCharOffset;\n  }\n  setSource(e = \"\", n = () => {\n  }) {\n    e = String(e || \"\");\n    const s = e.length, r = Le(this.offsetAndType, e.length + 1), o = Le(this.balance, e.length + 1);\n    let a = 0, l = -1, u = 0, i = e.length;\n    this.offsetAndType = null, this.balance = null, o.fill(0), n(e, (c, h, f) => {\n      const p = a++;\n      if (r[p] = c << gt | f, l === -1 && (l = h), o[p] = i, c === u) {\n        const d = o[i];\n        o[i] = p, i = d, u = Mt[r[d] >> gt];\n      } else Bn(c) && (i = p, u = Mt[c]);\n    }), r[a] = vt << gt | s, o[a] = a;\n    for (let c = 0; c < a; c++) {\n      const h = o[c];\n      if (h <= c) {\n        const f = o[h];\n        f !== c && (o[c] = f);\n      } else h > a && (o[c] = a);\n    }\n    this.source = e, this.firstCharOffset = l === -1 ? 0 : l, this.tokenCount = a, this.offsetAndType = r, this.balance = o, this.reset(), this.next();\n  }\n  lookupType(e) {\n    return e += this.tokenIndex, e < this.tokenCount ? this.offsetAndType[e] >> gt : vt;\n  }\n  lookupTypeNonSC(e) {\n    for (let n = this.tokenIndex; n < this.tokenCount; n++) {\n      const s = this.offsetAndType[n] >> gt;\n      if (s !== W && s !== Y && e-- === 0)\n        return s;\n    }\n    return vt;\n  }\n  lookupOffset(e) {\n    return e += this.tokenIndex, e < this.tokenCount ? this.offsetAndType[e - 1] & dt : this.source.length;\n  }\n  lookupOffsetNonSC(e) {\n    for (let n = this.tokenIndex; n < this.tokenCount; n++) {\n      const s = this.offsetAndType[n] >> gt;\n      if (s !== W && s !== Y && e-- === 0)\n        return n - this.tokenIndex;\n    }\n    return vt;\n  }\n  lookupValue(e, n) {\n    return e += this.tokenIndex, e < this.tokenCount ? $e(\n      this.source,\n      this.offsetAndType[e - 1] & dt,\n      this.offsetAndType[e] & dt,\n      n\n    ) : !1;\n  }\n  getTokenStart(e) {\n    return e === this.tokenIndex ? this.tokenStart : e > 0 ? e < this.tokenCount ? this.offsetAndType[e - 1] & dt : this.offsetAndType[this.tokenCount] & dt : this.firstCharOffset;\n  }\n  substrToCursor(e) {\n    return this.source.substring(e, this.tokenStart);\n  }\n  isBalanceEdge(e) {\n    return this.balance[this.tokenIndex] < e;\n  }\n  isDelim(e, n) {\n    return n ? this.lookupType(n) === L && this.source.charCodeAt(this.lookupOffset(n)) === e : this.tokenType === L && this.source.charCodeAt(this.tokenStart) === e;\n  }\n  skip(e) {\n    let n = this.tokenIndex + e;\n    n < this.tokenCount ? (this.tokenIndex = n, this.tokenStart = this.offsetAndType[n - 1] & dt, n = this.offsetAndType[n], this.tokenType = n >> gt, this.tokenEnd = n & dt) : (this.tokenIndex = this.tokenCount, this.next());\n  }\n  next() {\n    let e = this.tokenIndex + 1;\n    e < this.tokenCount ? (this.tokenIndex = e, this.tokenStart = this.tokenEnd, e = this.offsetAndType[e], this.tokenType = e >> gt, this.tokenEnd = e & dt) : (this.eof = !0, this.tokenIndex = this.tokenCount, this.tokenType = vt, this.tokenStart = this.tokenEnd = this.source.length);\n  }\n  skipSC() {\n    for (; this.tokenType === W || this.tokenType === Y; )\n      this.next();\n  }\n  skipUntilBalanced(e, n) {\n    let s = e, r = 0, o = 0;\n    t:\n      for (; s < this.tokenCount; s++) {\n        if (r = this.balance[s], r < e)\n          break t;\n        switch (o = s > 0 ? this.offsetAndType[s - 1] & dt : this.firstCharOffset, n(this.source.charCodeAt(o))) {\n          case 1:\n            break t;\n          case 2:\n            s++;\n            break t;\n          default:\n            Bn(this.offsetAndType[s] >> gt) && (s = r);\n        }\n      }\n    this.skip(s - this.tokenIndex);\n  }\n  forEachToken(e) {\n    for (let n = 0, s = this.firstCharOffset; n < this.tokenCount; n++) {\n      const r = s, o = this.offsetAndType[n], a = o & dt, l = o >> gt;\n      s = a, e(l, r, a, n);\n    }\n  }\n  dump() {\n    const e = new Array(this.tokenCount);\n    return this.forEachToken((n, s, r, o) => {\n      e[o] = {\n        idx: o,\n        type: Qs[n],\n        chunk: this.source.substring(s, r),\n        balance: this.balance[o]\n      };\n    }), e;\n  }\n}\nfunction Ys(t, e) {\n  function n(h) {\n    return h < l ? t.charCodeAt(h) : 0;\n  }\n  function s() {\n    if (i = qs(t, i), Me(n(i), n(i + 1), n(i + 2))) {\n      c = E, i = ge(t, i);\n      return;\n    }\n    if (n(i) === 37) {\n      c = F, i++;\n      return;\n    }\n    c = b;\n  }\n  function r() {\n    const h = i;\n    if (i = ge(t, i), $e(t, h, i, \"url\") && n(i) === 40) {\n      if (i = de(t, i + 1), n(i) === 34 || n(i) === 39) {\n        c = T, i = h + 4;\n        return;\n      }\n      a();\n      return;\n    }\n    if (n(i) === 40) {\n      c = T, i++;\n      return;\n    }\n    c = g;\n  }\n  function o(h) {\n    for (h || (h = n(i++)), c = Tt; i < t.length; i++) {\n      const f = t.charCodeAt(i);\n      switch (Be(f)) {\n        // ending code point\n        case h:\n          i++;\n          return;\n        // EOF\n        // case EofCategory:\n        // This is a parse error. Return the <string-token>.\n        // return;\n        // newline\n        case ye:\n          if (Ee(f)) {\n            i += an(t, i, f), c = ta;\n            return;\n          }\n          break;\n        // U+005C REVERSE SOLIDUS (\\)\n        case 92:\n          if (i === t.length - 1)\n            break;\n          const p = n(i + 1);\n          Ee(p) ? i += an(t, i + 1, p) : kt(f, p) && (i = Jt(t, i) - 1);\n          break;\n      }\n    }\n  }\n  function a() {\n    for (c = Q, i = de(t, i); i < t.length; i++) {\n      const h = t.charCodeAt(i);\n      switch (Be(h)) {\n        // U+0029 RIGHT PARENTHESIS ())\n        case 41:\n          i++;\n          return;\n        // EOF\n        // case EofCategory:\n        // This is a parse error. Return the <url-token>.\n        // return;\n        // whitespace\n        case ye:\n          if (i = de(t, i), n(i) === 41 || i >= t.length) {\n            i < t.length && i++;\n            return;\n          }\n          i = Ue(t, i), c = at;\n          return;\n        // U+0022 QUOTATION MARK (\")\n        // U+0027 APOSTROPHE (')\n        // U+0028 LEFT PARENTHESIS (()\n        // non-printable code point\n        case 34:\n        case 39:\n        case 40:\n        case Hs:\n          i = Ue(t, i), c = at;\n          return;\n        // U+005C REVERSE SOLIDUS (\\)\n        case 92:\n          if (kt(h, n(i + 1))) {\n            i = Jt(t, i) - 1;\n            break;\n          }\n          i = Ue(t, i), c = at;\n          return;\n      }\n    }\n  }\n  t = String(t || \"\");\n  const l = t.length;\n  let u = zs(n(0)), i = u, c;\n  for (; i < l; ) {\n    const h = t.charCodeAt(i);\n    switch (Be(h)) {\n      // whitespace\n      case ye:\n        c = W, i = de(t, i + 1);\n        break;\n      // U+0022 QUOTATION MARK (\")\n      case 34:\n        o();\n        break;\n      // U+0023 NUMBER SIGN (#)\n      case 35:\n        Us(n(i + 1)) || kt(n(i + 1), n(i + 2)) ? (c = I, i = ge(t, i + 1)) : (c = L, i++);\n        break;\n      // U+0027 APOSTROPHE (')\n      case 39:\n        o();\n        break;\n      // U+0028 LEFT PARENTHESIS (()\n      case 40:\n        c = _, i++;\n        break;\n      // U+0029 RIGHT PARENTHESIS ())\n      case 41:\n        c = S, i++;\n        break;\n      // U+002B PLUS SIGN (+)\n      case 43:\n        je(h, n(i + 1), n(i + 2)) ? s() : (c = L, i++);\n        break;\n      // U+002C COMMA (,)\n      case 44:\n        c = ft, i++;\n        break;\n      // U+002D HYPHEN-MINUS (-)\n      case 45:\n        je(h, n(i + 1), n(i + 2)) ? s() : n(i + 1) === 45 && n(i + 2) === 62 ? (c = nt, i = i + 3) : Me(h, n(i + 1), n(i + 2)) ? r() : (c = L, i++);\n        break;\n      // U+002E FULL STOP (.)\n      case 46:\n        je(h, n(i + 1), n(i + 2)) ? s() : (c = L, i++);\n        break;\n      // U+002F SOLIDUS (/)\n      case 47:\n        n(i + 1) === 42 ? (c = Y, i = t.indexOf(\"*/\", i + 2), i = i === -1 ? t.length : i + 2) : (c = L, i++);\n        break;\n      // U+003A COLON (:)\n      case 58:\n        c = X, i++;\n        break;\n      // U+003B SEMICOLON (;)\n      case 59:\n        c = tt, i++;\n        break;\n      // U+003C LESS-THAN SIGN (<)\n      case 60:\n        n(i + 1) === 33 && n(i + 2) === 45 && n(i + 3) === 45 ? (c = De, i = i + 4) : (c = L, i++);\n        break;\n      // U+0040 COMMERCIAL AT (@)\n      case 64:\n        Me(n(i + 1), n(i + 2), n(i + 3)) ? (c = z, i = ge(t, i + 1)) : (c = L, i++);\n        break;\n      // U+005B LEFT SQUARE BRACKET ([)\n      case 91:\n        c = ee, i++;\n        break;\n      // U+005C REVERSE SOLIDUS (\\)\n      case 92:\n        kt(h, n(i + 1)) ? r() : (c = L, i++);\n        break;\n      // U+005D RIGHT SQUARE BRACKET (])\n      case 93:\n        c = ce, i++;\n        break;\n      // U+007B LEFT CURLY BRACKET ({)\n      case 123:\n        c = ht, i++;\n        break;\n      // U+007D RIGHT CURLY BRACKET (})\n      case 125:\n        c = Yt, i++;\n        break;\n      // digit\n      case Vs:\n        s();\n        break;\n      // name-start code point\n      case Cn:\n        r();\n        break;\n      // EOF\n      // case EofCategory:\n      // Return an <EOF-token>.\n      // break;\n      // anything else\n      default:\n        c = L, i++;\n    }\n    e(c, u, u = i);\n  }\n}\nconst mt = 43, st = 45, be = 110, _t = !0, fa = !1;\nfunction xe(t, e) {\n  let n = this.tokenStart + t;\n  const s = this.charCodeAt(n);\n  for ((s === mt || s === st) && (e && this.error(\"Number sign is not allowed\"), n++); n < this.tokenEnd; n++)\n    rt(this.charCodeAt(n)) || this.error(\"Integer is expected\", n);\n}\nfunction Vt(t) {\n  return xe.call(this, 0, t);\n}\nfunction At(t, e) {\n  if (!this.cmpChar(this.tokenStart + t, e)) {\n    let n = \"\";\n    switch (e) {\n      case be:\n        n = \"N is expected\";\n        break;\n      case st:\n        n = \"HyphenMinus is expected\";\n        break;\n    }\n    this.error(n, this.tokenStart + t);\n  }\n}\nfunction ze() {\n  let t = 0, e = 0, n = this.tokenType;\n  for (; n === W || n === Y; )\n    n = this.lookupType(++t);\n  if (n !== b)\n    if (this.isDelim(mt, t) || this.isDelim(st, t)) {\n      e = this.isDelim(mt, t) ? mt : st;\n      do\n        n = this.lookupType(++t);\n      while (n === W || n === Y);\n      n !== b && (this.skip(t), Vt.call(this, _t));\n    } else\n      return null;\n  return t > 0 && this.skip(t), e === 0 && (n = this.charCodeAt(this.tokenStart), n !== mt && n !== st && this.error(\"Number sign is expected\")), Vt.call(this, e !== 0), e === st ? \"-\" + this.consume(b) : this.consume(b);\n}\nconst pa = \"AnPlusB\", da = {\n  a: [String, null],\n  b: [String, null]\n};\nfunction Xs() {\n  const t = this.tokenStart;\n  let e = null, n = null;\n  if (this.tokenType === b)\n    Vt.call(this, fa), n = this.consume(b);\n  else if (this.tokenType === g && this.cmpChar(this.tokenStart, st))\n    switch (e = \"-1\", At.call(this, 1, be), this.tokenEnd - this.tokenStart) {\n      // -n\n      // -n <signed-integer>\n      // -n ['+' | '-'] <signless-integer>\n      case 2:\n        this.next(), n = ze.call(this);\n        break;\n      // -n- <signless-integer>\n      case 3:\n        At.call(this, 2, st), this.next(), this.skipSC(), Vt.call(this, _t), n = \"-\" + this.consume(b);\n        break;\n      // <dashndashdigit-ident>\n      default:\n        At.call(this, 2, st), xe.call(this, 3, _t), this.next(), n = this.substrToCursor(t + 2);\n    }\n  else if (this.tokenType === g || this.isDelim(mt) && this.lookupType(1) === g) {\n    let s = 0;\n    switch (e = \"1\", this.isDelim(mt) && (s = 1, this.next()), At.call(this, 0, be), this.tokenEnd - this.tokenStart) {\n      // '+'? n\n      // '+'? n <signed-integer>\n      // '+'? n ['+' | '-'] <signless-integer>\n      case 1:\n        this.next(), n = ze.call(this);\n        break;\n      // '+'? n- <signless-integer>\n      case 2:\n        At.call(this, 1, st), this.next(), this.skipSC(), Vt.call(this, _t), n = \"-\" + this.consume(b);\n        break;\n      // '+'? <ndashdigit-ident>\n      default:\n        At.call(this, 1, st), xe.call(this, 2, _t), this.next(), n = this.substrToCursor(t + s + 1);\n    }\n  } else if (this.tokenType === E) {\n    const s = this.charCodeAt(this.tokenStart), r = s === mt || s === st;\n    let o = this.tokenStart + r;\n    for (; o < this.tokenEnd && rt(this.charCodeAt(o)); o++)\n      ;\n    o === this.tokenStart + r && this.error(\"Integer is expected\", this.tokenStart + r), At.call(this, o - this.tokenStart, be), e = this.substring(t, o), o + 1 === this.tokenEnd ? (this.next(), n = ze.call(this)) : (At.call(this, o - this.tokenStart + 1, st), o + 2 === this.tokenEnd ? (this.next(), this.skipSC(), Vt.call(this, _t), n = \"-\" + this.consume(b)) : (xe.call(this, o - this.tokenStart + 2, _t), this.next(), n = this.substrToCursor(o + 1)));\n  } else\n    this.error();\n  return e !== null && e.charCodeAt(0) === mt && (e = e.substr(1)), n !== null && n.charCodeAt(0) === mt && (n = n.substr(1)), {\n    type: \"AnPlusB\",\n    loc: this.getLocation(t, this.tokenStart),\n    a: e,\n    b: n\n  };\n}\nfunction Js(t) {\n  if (t.a) {\n    const e = t.a === \"+1\" && \"n\" || t.a === \"1\" && \"n\" || t.a === \"-1\" && \"-n\" || t.a + \"n\";\n    if (t.b) {\n      const n = t.b[0] === \"-\" || t.b[0] === \"+\" ? t.b : \"+\" + t.b;\n      this.tokenize(e + n);\n    } else\n      this.tokenize(e);\n  } else\n    this.tokenize(t.b);\n}\nconst ga = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Js,\n  name: pa,\n  parse: Xs,\n  structure: da\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Wn() {\n  return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, !0);\n}\nfunction ma() {\n  for (let t = 1, e; e = this.lookupType(t); t++) {\n    if (e === Yt)\n      return !0;\n    if (e === ht || e === z)\n      return !1;\n  }\n  return !1;\n}\nconst ka = \"Atrule\", Sa = \"atrule\", ya = {\n  name: String,\n  prelude: [\"AtrulePrelude\", \"Raw\", null],\n  block: [\"Block\", null]\n};\nfunction Zs(t = !1) {\n  const e = this.tokenStart;\n  let n, s, r = null, o = null;\n  switch (this.eat(z), n = this.substrToCursor(e + 1), s = n.toLowerCase(), this.skipSC(), this.eof === !1 && this.tokenType !== ht && this.tokenType !== tt && (this.parseAtrulePrelude ? r = this.parseWithFallback(this.AtrulePrelude.bind(this, n, t), Wn) : r = Wn.call(this, this.tokenIndex), this.skipSC()), this.tokenType) {\n    case tt:\n      this.next();\n      break;\n    case ht:\n      hasOwnProperty.call(this.atrule, s) && typeof this.atrule[s].block == \"function\" ? o = this.atrule[s].block.call(this, t) : o = this.Block(ma.call(this));\n      break;\n  }\n  return {\n    type: \"Atrule\",\n    loc: this.getLocation(e, this.tokenStart),\n    name: n,\n    prelude: r,\n    block: o\n  };\n}\nfunction tr(t) {\n  this.token(z, \"@\" + t.name), t.prelude !== null && this.node(t.prelude), t.block ? this.node(t.block) : this.token(tt, \";\");\n}\nconst ba = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: tr,\n  name: ka,\n  parse: Zs,\n  structure: ya,\n  walkContext: Sa\n}, Symbol.toStringTag, { value: \"Module\" })), xa = \"AtrulePrelude\", Ca = \"atrulePrelude\", wa = {\n  children: [[]]\n};\nfunction er(t) {\n  let e = null;\n  return t !== null && (t = t.toLowerCase()), this.skipSC(), hasOwnProperty.call(this.atrule, t) && typeof this.atrule[t].prelude == \"function\" ? e = this.atrule[t].prelude.call(this) : e = this.readSequence(this.scope.AtrulePrelude), this.skipSC(), this.eof !== !0 && this.tokenType !== ht && this.tokenType !== tt && this.error(\"Semicolon or block is expected\"), {\n    type: \"AtrulePrelude\",\n    loc: this.getLocationFromList(e),\n    children: e\n  };\n}\nfunction nr(t) {\n  this.children(t);\n}\nconst Ta = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: nr,\n  name: xa,\n  parse: er,\n  structure: wa,\n  walkContext: Ca\n}, Symbol.toStringTag, { value: \"Module\" })), Aa = 36, sr = 42, Ce = 61, va = 94, ln = 124, Ea = 126;\nfunction $a() {\n  this.eof && this.error(\"Unexpected end of input\");\n  const t = this.tokenStart;\n  let e = !1;\n  return this.isDelim(sr) ? (e = !0, this.next()) : this.isDelim(ln) || this.eat(g), this.isDelim(ln) ? this.charCodeAt(this.tokenStart + 1) !== Ce ? (this.next(), this.eat(g)) : e && this.error(\"Identifier is expected\", this.tokenEnd) : e && this.error(\"Vertical line is expected\"), {\n    type: \"Identifier\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: this.substrToCursor(t)\n  };\n}\nfunction La() {\n  const t = this.tokenStart, e = this.charCodeAt(t);\n  return e !== Ce && // =\n  e !== Ea && // ~=\n  e !== va && // ^=\n  e !== Aa && // $=\n  e !== sr && // *=\n  e !== ln && this.error(\"Attribute selector (=, ~=, ^=, $=, *=, |=) is expected\"), this.next(), e !== Ce && (this.isDelim(Ce) || this.error(\"Equal sign is expected\"), this.next()), this.substrToCursor(t);\n}\nconst Pa = \"AttributeSelector\", Oa = {\n  name: \"Identifier\",\n  matcher: [String, null],\n  value: [\"String\", \"Identifier\", null],\n  flags: [String, null]\n};\nfunction rr() {\n  const t = this.tokenStart;\n  let e, n = null, s = null, r = null;\n  return this.eat(ee), this.skipSC(), e = $a.call(this), this.skipSC(), this.tokenType !== ce && (this.tokenType !== g && (n = La.call(this), this.skipSC(), s = this.tokenType === Tt ? this.String() : this.Identifier(), this.skipSC()), this.tokenType === g && (r = this.consume(g), this.skipSC())), this.eat(ce), {\n    type: \"AttributeSelector\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: e,\n    matcher: n,\n    value: s,\n    flags: r\n  };\n}\nfunction ir(t) {\n  this.token(L, \"[\"), this.node(t.name), t.matcher !== null && (this.tokenize(t.matcher), this.node(t.value)), t.flags !== null && this.token(g, t.flags), this.token(L, \"]\");\n}\nconst Ra = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ir,\n  name: Pa,\n  parse: rr,\n  structure: Oa\n}, Symbol.toStringTag, { value: \"Module\" })), _a = 38;\nfunction or() {\n  return this.Raw(null, !0);\n}\nfunction Un() {\n  return this.parseWithFallback(this.Rule, or);\n}\nfunction zn() {\n  return this.Raw(this.consumeUntilSemicolonIncluded, !0);\n}\nfunction Ia() {\n  if (this.tokenType === tt)\n    return zn.call(this, this.tokenIndex);\n  const t = this.parseWithFallback(this.Declaration, zn);\n  return this.tokenType === tt && this.next(), t;\n}\nconst Na = \"Block\", Da = \"block\", Fa = {\n  children: [[\n    \"Atrule\",\n    \"Rule\",\n    \"Declaration\"\n  ]]\n};\nfunction ar(t) {\n  const e = t ? Ia : Un, n = this.tokenStart;\n  let s = this.createList();\n  this.eat(ht);\n  t:\n    for (; !this.eof; )\n      switch (this.tokenType) {\n        case Yt:\n          break t;\n        case W:\n        case Y:\n          this.next();\n          break;\n        case z:\n          s.push(this.parseWithFallback(this.Atrule.bind(this, t), or));\n          break;\n        default:\n          t && this.isDelim(_a) ? s.push(Un.call(this)) : s.push(e.call(this));\n      }\n  return this.eof || this.eat(Yt), {\n    type: \"Block\",\n    loc: this.getLocation(n, this.tokenStart),\n    children: s\n  };\n}\nfunction lr(t) {\n  this.token(ht, \"{\"), this.children(t, (e) => {\n    e.type === \"Declaration\" && this.token(tt, \";\");\n  }), this.token(Yt, \"}\");\n}\nconst Ma = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: lr,\n  name: Na,\n  parse: ar,\n  structure: Fa,\n  walkContext: Da\n}, Symbol.toStringTag, { value: \"Module\" })), ja = \"Brackets\", Ba = {\n  children: [[]]\n};\nfunction cr(t, e) {\n  const n = this.tokenStart;\n  let s = null;\n  return this.eat(ee), s = t.call(this, e), this.eof || this.eat(ce), {\n    type: \"Brackets\",\n    loc: this.getLocation(n, this.tokenStart),\n    children: s\n  };\n}\nfunction ur(t) {\n  this.token(L, \"[\"), this.children(t), this.token(L, \"]\");\n}\nconst Wa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ur,\n  name: ja,\n  parse: cr,\n  structure: Ba\n}, Symbol.toStringTag, { value: \"Module\" })), Ua = \"CDC\", za = [];\nfunction hr() {\n  const t = this.tokenStart;\n  return this.eat(nt), {\n    type: \"CDC\",\n    loc: this.getLocation(t, this.tokenStart)\n  };\n}\nfunction fr() {\n  this.token(nt, \"-->\");\n}\nconst Va = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: fr,\n  name: Ua,\n  parse: hr,\n  structure: za\n}, Symbol.toStringTag, { value: \"Module\" })), Ha = \"CDO\", Ga = [];\nfunction pr() {\n  const t = this.tokenStart;\n  return this.eat(De), {\n    type: \"CDO\",\n    loc: this.getLocation(t, this.tokenStart)\n  };\n}\nfunction dr() {\n  this.token(De, \"<!--\");\n}\nconst qa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: dr,\n  name: Ha,\n  parse: pr,\n  structure: Ga\n}, Symbol.toStringTag, { value: \"Module\" })), Ka = 46, Qa = \"ClassSelector\", Ya = {\n  name: String\n};\nfunction gr() {\n  return this.eatDelim(Ka), {\n    type: \"ClassSelector\",\n    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),\n    name: this.consume(g)\n  };\n}\nfunction mr(t) {\n  this.token(L, \".\"), this.token(g, t.name);\n}\nconst Xa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: mr,\n  name: Qa,\n  parse: gr,\n  structure: Ya\n}, Symbol.toStringTag, { value: \"Module\" })), Ja = 43, Vn = 47, Za = 62, tl = 126, el = \"Combinator\", nl = {\n  name: String\n};\nfunction kr() {\n  const t = this.tokenStart;\n  let e;\n  switch (this.tokenType) {\n    case W:\n      e = \" \";\n      break;\n    case L:\n      switch (this.charCodeAt(this.tokenStart)) {\n        case Za:\n        case Ja:\n        case tl:\n          this.next();\n          break;\n        case Vn:\n          this.next(), this.eatIdent(\"deep\"), this.eatDelim(Vn);\n          break;\n        default:\n          this.error(\"Combinator is expected\");\n      }\n      e = this.substrToCursor(t);\n      break;\n  }\n  return {\n    type: \"Combinator\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: e\n  };\n}\nfunction Sr(t) {\n  this.tokenize(t.name);\n}\nconst sl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Sr,\n  name: el,\n  parse: kr,\n  structure: nl\n}, Symbol.toStringTag, { value: \"Module\" })), rl = 42, il = 47, ol = \"Comment\", al = {\n  value: String\n};\nfunction yr() {\n  const t = this.tokenStart;\n  let e = this.tokenEnd;\n  return this.eat(Y), e - t + 2 >= 2 && this.charCodeAt(e - 2) === rl && this.charCodeAt(e - 1) === il && (e -= 2), {\n    type: \"Comment\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: this.substring(t + 2, e)\n  };\n}\nfunction br(t) {\n  this.token(Y, \"/*\" + t.value + \"*/\");\n}\nconst ll = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: br,\n  name: ol,\n  parse: yr,\n  structure: al\n}, Symbol.toStringTag, { value: \"Module\" })), cl = /* @__PURE__ */ new Set([X, S, vt]), ul = \"Condition\", hl = {\n  kind: String,\n  children: [[\n    \"Identifier\",\n    \"Feature\",\n    \"FeatureFunction\",\n    \"FeatureRange\",\n    \"SupportsDeclaration\"\n  ]]\n};\nfunction Hn(t) {\n  return this.lookupTypeNonSC(1) === g && cl.has(this.lookupTypeNonSC(2)) ? this.Feature(t) : this.FeatureRange(t);\n}\nconst fl = {\n  media: Hn,\n  container: Hn,\n  supports() {\n    return this.SupportsDeclaration();\n  }\n};\nfunction xr(t = \"media\") {\n  const e = this.createList();\n  t: for (; !this.eof; )\n    switch (this.tokenType) {\n      case Y:\n      case W:\n        this.next();\n        continue;\n      case g:\n        e.push(this.Identifier());\n        break;\n      case _: {\n        let n = this.parseWithFallback(\n          () => fl[t].call(this, t),\n          () => null\n        );\n        n || (n = this.parseWithFallback(\n          () => {\n            this.eat(_);\n            const s = this.Condition(t);\n            return this.eat(S), s;\n          },\n          () => this.GeneralEnclosed(t)\n        )), e.push(n);\n        break;\n      }\n      case T: {\n        let n = this.parseWithFallback(\n          () => this.FeatureFunction(t),\n          () => null\n        );\n        n || (n = this.GeneralEnclosed(t)), e.push(n);\n        break;\n      }\n      default:\n        break t;\n    }\n  return e.isEmpty && this.error(\"Condition is expected\"), {\n    type: \"Condition\",\n    loc: this.getLocationFromList(e),\n    kind: t,\n    children: e\n  };\n}\nfunction Cr(t) {\n  t.children.forEach((e) => {\n    e.type === \"Condition\" ? (this.token(_, \"(\"), this.node(e), this.token(S, \")\")) : this.node(e);\n  });\n}\nconst pl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Cr,\n  name: ul,\n  parse: xr,\n  structure: hl\n}, Symbol.toStringTag, { value: \"Module\" })), Gn = 45;\nfunction dl(t, e) {\n  return e = e || 0, t.length - e >= 2 && t.charCodeAt(e) === Gn && t.charCodeAt(e + 1) === Gn;\n}\nconst wr = 33, gl = 35, ml = 36, kl = 38, Sl = 42, yl = 43, qn = 47;\nfunction bl() {\n  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !0);\n}\nfunction xl() {\n  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !1);\n}\nfunction Cl() {\n  const t = this.tokenIndex, e = this.Value();\n  return e.type !== \"Raw\" && this.eof === !1 && this.tokenType !== tt && this.isDelim(wr) === !1 && this.isBalanceEdge(t) === !1 && this.error(), e;\n}\nconst wl = \"Declaration\", Tl = \"declaration\", Al = {\n  important: [Boolean, String],\n  property: String,\n  value: [\"Value\", \"Raw\"]\n};\nfunction Tr() {\n  const t = this.tokenStart, e = this.tokenIndex, n = vl.call(this), s = dl(n), r = s ? this.parseCustomProperty : this.parseValue, o = s ? xl : bl;\n  let a = !1, l;\n  this.skipSC(), this.eat(X);\n  const u = this.tokenIndex;\n  if (s || this.skipSC(), r ? l = this.parseWithFallback(Cl, o) : l = o.call(this, this.tokenIndex), s && l.type === \"Value\" && l.children.isEmpty) {\n    for (let i = u - this.tokenIndex; i <= 0; i++)\n      if (this.lookupType(i) === W) {\n        l.children.appendData({\n          type: \"WhiteSpace\",\n          loc: null,\n          value: \" \"\n        });\n        break;\n      }\n  }\n  return this.isDelim(wr) && (a = El.call(this), this.skipSC()), this.eof === !1 && this.tokenType !== tt && this.isBalanceEdge(e) === !1 && this.error(), {\n    type: \"Declaration\",\n    loc: this.getLocation(t, this.tokenStart),\n    important: a,\n    property: n,\n    value: l\n  };\n}\nfunction Ar(t) {\n  this.token(g, t.property), this.token(X, \":\"), this.node(t.value), t.important && (this.token(L, \"!\"), this.token(g, t.important === !0 ? \"important\" : t.important));\n}\nfunction vl() {\n  const t = this.tokenStart;\n  if (this.tokenType === L)\n    switch (this.charCodeAt(this.tokenStart)) {\n      case Sl:\n      case ml:\n      case yl:\n      case gl:\n      case kl:\n        this.next();\n        break;\n      // TODO: not sure we should support this hack\n      case qn:\n        this.next(), this.isDelim(qn) && this.next();\n        break;\n    }\n  return this.tokenType === I ? this.eat(I) : this.eat(g), this.substrToCursor(t);\n}\nfunction El() {\n  this.eat(L), this.skipSC();\n  const t = this.consume(g);\n  return t === \"important\" ? !0 : t;\n}\nconst $l = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Ar,\n  name: wl,\n  parse: Tr,\n  structure: Al,\n  walkContext: Tl\n}, Symbol.toStringTag, { value: \"Module\" })), Ll = 38;\nfunction Ve() {\n  return this.Raw(this.consumeUntilSemicolonIncluded, !0);\n}\nconst Pl = \"DeclarationList\", Ol = {\n  children: [[\n    \"Declaration\",\n    \"Atrule\",\n    \"Rule\"\n  ]]\n};\nfunction vr() {\n  const t = this.createList();\n  for (; !this.eof; )\n    switch (this.tokenType) {\n      case W:\n      case Y:\n      case tt:\n        this.next();\n        break;\n      case z:\n        t.push(this.parseWithFallback(this.Atrule.bind(this, !0), Ve));\n        break;\n      default:\n        this.isDelim(Ll) ? t.push(this.parseWithFallback(this.Rule, Ve)) : t.push(this.parseWithFallback(this.Declaration, Ve));\n    }\n  return {\n    type: \"DeclarationList\",\n    loc: this.getLocationFromList(t),\n    children: t\n  };\n}\nfunction Er(t) {\n  this.children(t, (e) => {\n    e.type === \"Declaration\" && this.token(tt, \";\");\n  });\n}\nconst Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Er,\n  name: Pl,\n  parse: vr,\n  structure: Ol\n}, Symbol.toStringTag, { value: \"Module\" })), _l = \"Dimension\", Il = {\n  value: String,\n  unit: String\n};\nfunction $r() {\n  const t = this.tokenStart, e = this.consumeNumber(E);\n  return {\n    type: \"Dimension\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: e,\n    unit: this.substring(t + e.length, this.tokenStart)\n  };\n}\nfunction Lr(t) {\n  this.token(E, t.value + t.unit);\n}\nconst Nl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Lr,\n  name: _l,\n  parse: $r,\n  structure: Il\n}, Symbol.toStringTag, { value: \"Module\" })), Dl = 47, Fl = \"Feature\", Ml = {\n  kind: String,\n  name: String,\n  value: [\"Identifier\", \"Number\", \"Dimension\", \"Ratio\", \"Function\", null]\n};\nfunction Pr(t) {\n  const e = this.tokenStart;\n  let n, s = null;\n  if (this.eat(_), this.skipSC(), n = this.consume(g), this.skipSC(), this.tokenType !== S) {\n    switch (this.eat(X), this.skipSC(), this.tokenType) {\n      case b:\n        this.lookupNonWSType(1) === L ? s = this.Ratio() : s = this.Number();\n        break;\n      case E:\n        s = this.Dimension();\n        break;\n      case g:\n        s = this.Identifier();\n        break;\n      case T:\n        s = this.parseWithFallback(\n          () => {\n            const r = this.Function(this.readSequence, this.scope.Value);\n            return this.skipSC(), this.isDelim(Dl) && this.error(), r;\n          },\n          () => this.Ratio()\n        );\n        break;\n      default:\n        this.error(\"Number, dimension, ratio or identifier is expected\");\n    }\n    this.skipSC();\n  }\n  return this.eof || this.eat(S), {\n    type: \"Feature\",\n    loc: this.getLocation(e, this.tokenStart),\n    kind: t,\n    name: n,\n    value: s\n  };\n}\nfunction Or(t) {\n  this.token(_, \"(\"), this.token(g, t.name), t.value !== null && (this.token(X, \":\"), this.node(t.value)), this.token(S, \")\");\n}\nconst jl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Or,\n  name: Fl,\n  parse: Pr,\n  structure: Ml\n}, Symbol.toStringTag, { value: \"Module\" })), Bl = \"FeatureFunction\", Wl = {\n  kind: String,\n  feature: String,\n  value: [\"Declaration\", \"Selector\"]\n};\nfunction Ul(t, e) {\n  const s = (this.features[t] || {})[e];\n  return typeof s != \"function\" && this.error(`Unknown feature ${e}()`), s;\n}\nfunction Rr(t = \"unknown\") {\n  const e = this.tokenStart, n = this.consumeFunctionName(), s = Ul.call(this, t, n.toLowerCase());\n  this.skipSC();\n  const r = this.parseWithFallback(\n    () => {\n      const o = this.tokenIndex, a = s.call(this);\n      return this.eof === !1 && this.isBalanceEdge(o) === !1 && this.error(), a;\n    },\n    () => this.Raw(null, !1)\n  );\n  return this.eof || this.eat(S), {\n    type: \"FeatureFunction\",\n    loc: this.getLocation(e, this.tokenStart),\n    kind: t,\n    feature: n,\n    value: r\n  };\n}\nfunction _r(t) {\n  this.token(T, t.feature + \"(\"), this.node(t.value), this.token(S, \")\");\n}\nconst zl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: _r,\n  name: Bl,\n  parse: Rr,\n  structure: Wl\n}, Symbol.toStringTag, { value: \"Module\" })), Kn = 47, Vl = 60, Qn = 61, Hl = 62, Gl = \"FeatureRange\", ql = {\n  kind: String,\n  left: [\"Identifier\", \"Number\", \"Dimension\", \"Ratio\", \"Function\"],\n  leftComparison: String,\n  middle: [\"Identifier\", \"Number\", \"Dimension\", \"Ratio\", \"Function\"],\n  rightComparison: [String, null],\n  right: [\"Identifier\", \"Number\", \"Dimension\", \"Ratio\", \"Function\", null]\n};\nfunction He() {\n  switch (this.skipSC(), this.tokenType) {\n    case b:\n      return this.isDelim(Kn, this.lookupOffsetNonSC(1)) ? this.Ratio() : this.Number();\n    case E:\n      return this.Dimension();\n    case g:\n      return this.Identifier();\n    case T:\n      return this.parseWithFallback(\n        () => {\n          const t = this.Function(this.readSequence, this.scope.Value);\n          return this.skipSC(), this.isDelim(Kn) && this.error(), t;\n        },\n        () => this.Ratio()\n      );\n    default:\n      this.error(\"Number, dimension, ratio or identifier is expected\");\n  }\n}\nfunction Yn(t) {\n  if (this.skipSC(), this.isDelim(Vl) || this.isDelim(Hl)) {\n    const e = this.source[this.tokenStart];\n    return this.next(), this.isDelim(Qn) ? (this.next(), e + \"=\") : e;\n  }\n  if (this.isDelim(Qn))\n    return \"=\";\n  this.error(`Expected ${t ? '\":\", ' : \"\"}\"<\", \">\", \"=\" or \")\"`);\n}\nfunction Ir(t = \"unknown\") {\n  const e = this.tokenStart;\n  this.skipSC(), this.eat(_);\n  const n = He.call(this), s = Yn.call(this, n.type === \"Identifier\"), r = He.call(this);\n  let o = null, a = null;\n  return this.lookupNonWSType(0) !== S && (o = Yn.call(this), a = He.call(this)), this.skipSC(), this.eat(S), {\n    type: \"FeatureRange\",\n    loc: this.getLocation(e, this.tokenStart),\n    kind: t,\n    left: n,\n    leftComparison: s,\n    middle: r,\n    rightComparison: o,\n    right: a\n  };\n}\nfunction Nr(t) {\n  this.token(_, \"(\"), this.node(t.left), this.tokenize(t.leftComparison), this.node(t.middle), t.right && (this.tokenize(t.rightComparison), this.node(t.right)), this.token(S, \")\");\n}\nconst Kl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Nr,\n  name: Gl,\n  parse: Ir,\n  structure: ql\n}, Symbol.toStringTag, { value: \"Module\" })), Ql = \"Function\", Yl = \"function\", Xl = {\n  name: String,\n  children: [[]]\n};\nfunction Dr(t, e) {\n  const n = this.tokenStart, s = this.consumeFunctionName(), r = s.toLowerCase();\n  let o;\n  return o = e.hasOwnProperty(r) ? e[r].call(this, e) : t.call(this, e), this.eof || this.eat(S), {\n    type: \"Function\",\n    loc: this.getLocation(n, this.tokenStart),\n    name: s,\n    children: o\n  };\n}\nfunction Fr(t) {\n  this.token(T, t.name + \"(\"), this.children(t), this.token(S, \")\");\n}\nconst Jl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Fr,\n  name: Ql,\n  parse: Dr,\n  structure: Xl,\n  walkContext: Yl\n}, Symbol.toStringTag, { value: \"Module\" })), Zl = \"GeneralEnclosed\", tc = {\n  kind: String,\n  function: [String, null],\n  children: [[]]\n};\nfunction Mr(t) {\n  const e = this.tokenStart;\n  let n = null;\n  this.tokenType === T ? n = this.consumeFunctionName() : this.eat(_);\n  const s = this.parseWithFallback(\n    () => {\n      const r = this.tokenIndex, o = this.readSequence(this.scope.Value);\n      return this.eof === !1 && this.isBalanceEdge(r) === !1 && this.error(), o;\n    },\n    () => this.createSingleNodeList(\n      this.Raw(null, !1)\n    )\n  );\n  return this.eof || this.eat(S), {\n    type: \"GeneralEnclosed\",\n    loc: this.getLocation(e, this.tokenStart),\n    kind: t,\n    function: n,\n    children: s\n  };\n}\nfunction jr(t) {\n  t.function ? this.token(T, t.function + \"(\") : this.token(_, \"(\"), this.children(t), this.token(S, \")\");\n}\nconst ec = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: jr,\n  name: Zl,\n  parse: Mr,\n  structure: tc\n}, Symbol.toStringTag, { value: \"Module\" })), nc = \"XXX\", sc = \"Hash\", rc = {\n  value: String\n};\nfunction Br() {\n  const t = this.tokenStart;\n  return this.eat(I), {\n    type: \"Hash\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: this.substrToCursor(t + 1)\n  };\n}\nfunction Wr(t) {\n  this.token(I, \"#\" + t.value);\n}\nconst ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Wr,\n  name: sc,\n  parse: Br,\n  structure: rc,\n  xxx: nc\n}, Symbol.toStringTag, { value: \"Module\" })), oc = \"Identifier\", ac = {\n  name: String\n};\nfunction Ur() {\n  return {\n    type: \"Identifier\",\n    loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    name: this.consume(g)\n  };\n}\nfunction zr(t) {\n  this.token(g, t.name);\n}\nconst lc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: zr,\n  name: oc,\n  parse: Ur,\n  structure: ac\n}, Symbol.toStringTag, { value: \"Module\" })), cc = \"IdSelector\", uc = {\n  name: String\n};\nfunction Vr() {\n  const t = this.tokenStart;\n  return this.eat(I), {\n    type: \"IdSelector\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: this.substrToCursor(t + 1)\n  };\n}\nfunction Hr(t) {\n  this.token(L, \"#\" + t.name);\n}\nconst hc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Hr,\n  name: cc,\n  parse: Vr,\n  structure: uc\n}, Symbol.toStringTag, { value: \"Module\" })), fc = 46, pc = \"Layer\", dc = {\n  name: String\n};\nfunction Gr() {\n  let t = this.tokenStart, e = this.consume(g);\n  for (; this.isDelim(fc); )\n    this.eat(L), e += \".\" + this.consume(g);\n  return {\n    type: \"Layer\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: e\n  };\n}\nfunction qr(t) {\n  this.tokenize(t.name);\n}\nconst gc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: qr,\n  name: pc,\n  parse: Gr,\n  structure: dc\n}, Symbol.toStringTag, { value: \"Module\" })), mc = \"LayerList\", kc = {\n  children: [[\n    \"Layer\"\n  ]]\n};\nfunction Kr() {\n  const t = this.createList();\n  for (this.skipSC(); !this.eof && (t.push(this.Layer()), this.lookupTypeNonSC(0) === ft); )\n    this.skipSC(), this.next(), this.skipSC();\n  return {\n    type: \"LayerList\",\n    loc: this.getLocationFromList(t),\n    children: t\n  };\n}\nfunction Qr(t) {\n  this.children(t, () => this.token(ft, \",\"));\n}\nconst Sc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Qr,\n  name: mc,\n  parse: Kr,\n  structure: kc\n}, Symbol.toStringTag, { value: \"Module\" })), yc = \"MediaQuery\", bc = {\n  modifier: [String, null],\n  mediaType: [String, null],\n  condition: [\"Condition\", null]\n};\nfunction Yr() {\n  const t = this.tokenStart;\n  let e = null, n = null, s = null;\n  if (this.skipSC(), this.tokenType === g && this.lookupTypeNonSC(1) !== _) {\n    const r = this.consume(g), o = r.toLowerCase();\n    switch (o === \"not\" || o === \"only\" ? (this.skipSC(), e = o, n = this.consume(g)) : n = r, this.lookupTypeNonSC(0)) {\n      case g: {\n        this.skipSC(), this.eatIdent(\"and\"), s = this.Condition(\"media\");\n        break;\n      }\n      case ht:\n      case tt:\n      case ft:\n      case vt:\n        break;\n      default:\n        this.error(\"Identifier or parenthesis is expected\");\n    }\n  } else\n    switch (this.tokenType) {\n      case g:\n      case _:\n      case T: {\n        s = this.Condition(\"media\");\n        break;\n      }\n      case ht:\n      case tt:\n      case vt:\n        break;\n      default:\n        this.error(\"Identifier or parenthesis is expected\");\n    }\n  return {\n    type: \"MediaQuery\",\n    loc: this.getLocation(t, this.tokenStart),\n    modifier: e,\n    mediaType: n,\n    condition: s\n  };\n}\nfunction Xr(t) {\n  t.mediaType ? (t.modifier && this.token(g, t.modifier), this.token(g, t.mediaType), t.condition && (this.token(g, \"and\"), this.node(t.condition))) : t.condition && this.node(t.condition);\n}\nconst xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Xr,\n  name: yc,\n  parse: Yr,\n  structure: bc\n}, Symbol.toStringTag, { value: \"Module\" })), Cc = \"MediaQueryList\", wc = {\n  children: [[\n    \"MediaQuery\"\n  ]]\n};\nfunction Jr() {\n  const t = this.createList();\n  for (this.skipSC(); !this.eof && (t.push(this.MediaQuery()), this.tokenType === ft); )\n    this.next();\n  return {\n    type: \"MediaQueryList\",\n    loc: this.getLocationFromList(t),\n    children: t\n  };\n}\nfunction Zr(t) {\n  this.children(t, () => this.token(ft, \",\"));\n}\nconst Tc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Zr,\n  name: Cc,\n  parse: Jr,\n  structure: wc\n}, Symbol.toStringTag, { value: \"Module\" })), Ac = 38, vc = \"NestingSelector\", Ec = {};\nfunction ti() {\n  const t = this.tokenStart;\n  return this.eatDelim(Ac), {\n    type: \"NestingSelector\",\n    loc: this.getLocation(t, this.tokenStart)\n  };\n}\nfunction ei() {\n  this.token(L, \"&\");\n}\nconst $c = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ei,\n  name: vc,\n  parse: ti,\n  structure: Ec\n}, Symbol.toStringTag, { value: \"Module\" })), Lc = \"Nth\", Pc = {\n  nth: [\"AnPlusB\", \"Identifier\"],\n  selector: [\"SelectorList\", null]\n};\nfunction ni() {\n  this.skipSC();\n  const t = this.tokenStart;\n  let e = t, n = null, s;\n  return this.lookupValue(0, \"odd\") || this.lookupValue(0, \"even\") ? s = this.Identifier() : s = this.AnPlusB(), e = this.tokenStart, this.skipSC(), this.lookupValue(0, \"of\") && (this.next(), n = this.SelectorList(), e = this.tokenStart), {\n    type: \"Nth\",\n    loc: this.getLocation(t, e),\n    nth: s,\n    selector: n\n  };\n}\nfunction si(t) {\n  this.node(t.nth), t.selector !== null && (this.token(g, \"of\"), this.node(t.selector));\n}\nconst Oc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: si,\n  name: Lc,\n  parse: ni,\n  structure: Pc\n}, Symbol.toStringTag, { value: \"Module\" })), Rc = \"Number\", _c = {\n  value: String\n};\nfunction ri() {\n  return {\n    type: \"Number\",\n    loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    value: this.consume(b)\n  };\n}\nfunction ii(t) {\n  this.token(b, t.value);\n}\nconst Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ii,\n  name: Rc,\n  parse: ri,\n  structure: _c\n}, Symbol.toStringTag, { value: \"Module\" })), Nc = \"Operator\", Dc = {\n  value: String\n};\nfunction oi() {\n  const t = this.tokenStart;\n  return this.next(), {\n    type: \"Operator\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: this.substrToCursor(t)\n  };\n}\nfunction ai(t) {\n  this.tokenize(t.value);\n}\nconst Fc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ai,\n  name: Nc,\n  parse: oi,\n  structure: Dc\n}, Symbol.toStringTag, { value: \"Module\" })), Mc = \"Parentheses\", jc = {\n  children: [[]]\n};\nfunction li(t, e) {\n  const n = this.tokenStart;\n  let s = null;\n  return this.eat(_), s = t.call(this, e), this.eof || this.eat(S), {\n    type: \"Parentheses\",\n    loc: this.getLocation(n, this.tokenStart),\n    children: s\n  };\n}\nfunction ci(t) {\n  this.token(_, \"(\"), this.children(t), this.token(S, \")\");\n}\nconst Bc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ci,\n  name: Mc,\n  parse: li,\n  structure: jc\n}, Symbol.toStringTag, { value: \"Module\" })), Wc = \"Percentage\", Uc = {\n  value: String\n};\nfunction ui() {\n  return {\n    type: \"Percentage\",\n    loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    value: this.consumeNumber(F)\n  };\n}\nfunction hi(t) {\n  this.token(F, t.value + \"%\");\n}\nconst zc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: hi,\n  name: Wc,\n  parse: ui,\n  structure: Uc\n}, Symbol.toStringTag, { value: \"Module\" })), Vc = \"PseudoClassSelector\", Hc = \"function\", Gc = {\n  name: String,\n  children: [[\"Raw\"], null]\n};\nfunction fi() {\n  const t = this.tokenStart;\n  let e = null, n, s;\n  return this.eat(X), this.tokenType === T ? (n = this.consumeFunctionName(), s = n.toLowerCase(), this.lookupNonWSType(0) == S ? e = this.createList() : hasOwnProperty.call(this.pseudo, s) ? (this.skipSC(), e = this.pseudo[s].call(this), this.skipSC()) : (e = this.createList(), e.push(\n    this.Raw(null, !1)\n  )), this.eat(S)) : n = this.consume(g), {\n    type: \"PseudoClassSelector\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: n,\n    children: e\n  };\n}\nfunction pi(t) {\n  this.token(X, \":\"), t.children === null ? this.token(g, t.name) : (this.token(T, t.name + \"(\"), this.children(t), this.token(S, \")\"));\n}\nconst qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: pi,\n  name: Vc,\n  parse: fi,\n  structure: Gc,\n  walkContext: Hc\n}, Symbol.toStringTag, { value: \"Module\" })), Kc = \"PseudoElementSelector\", Qc = \"function\", Yc = {\n  name: String,\n  children: [[\"Raw\"], null]\n};\nfunction di() {\n  const t = this.tokenStart;\n  let e = null, n, s;\n  return this.eat(X), this.eat(X), this.tokenType === T ? (n = this.consumeFunctionName(), s = n.toLowerCase(), this.lookupNonWSType(0) == S ? e = this.createList() : hasOwnProperty.call(this.pseudo, s) ? (this.skipSC(), e = this.pseudo[s].call(this), this.skipSC()) : (e = this.createList(), e.push(\n    this.Raw(null, !1)\n  )), this.eat(S)) : n = this.consume(g), {\n    type: \"PseudoElementSelector\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: n,\n    children: e\n  };\n}\nfunction gi(t) {\n  this.token(X, \":\"), this.token(X, \":\"), t.children === null ? this.token(g, t.name) : (this.token(T, t.name + \"(\"), this.children(t), this.token(S, \")\"));\n}\nconst Xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: gi,\n  name: Kc,\n  parse: di,\n  structure: Yc,\n  walkContext: Qc\n}, Symbol.toStringTag, { value: \"Module\" })), Xn = 47;\nfunction Jn() {\n  switch (this.skipSC(), this.tokenType) {\n    case b:\n      return this.Number();\n    case T:\n      return this.Function(this.readSequence, this.scope.Value);\n    default:\n      this.error(\"Number of function is expected\");\n  }\n}\nconst Jc = \"Ratio\", Zc = {\n  left: [\"Number\", \"Function\"],\n  right: [\"Number\", \"Function\", null]\n};\nfunction mi() {\n  const t = this.tokenStart, e = Jn.call(this);\n  let n = null;\n  return this.skipSC(), this.isDelim(Xn) && (this.eatDelim(Xn), n = Jn.call(this)), {\n    type: \"Ratio\",\n    loc: this.getLocation(t, this.tokenStart),\n    left: e,\n    right: n\n  };\n}\nfunction ki(t) {\n  this.node(t.left), this.token(L, \"/\"), t.right ? this.node(t.right) : this.node(b, 1);\n}\nconst tu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: ki,\n  name: Jc,\n  parse: mi,\n  structure: Zc\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction eu() {\n  return this.tokenIndex > 0 && this.lookupType(-1) === W ? this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset : this.tokenStart;\n}\nconst nu = \"Raw\", su = {\n  value: String\n};\nfunction Si(t, e) {\n  const n = this.getTokenStart(this.tokenIndex);\n  let s;\n  return this.skipUntilBalanced(this.tokenIndex, t || this.consumeUntilBalanceEnd), e && this.tokenStart > n ? s = eu.call(this) : s = this.tokenStart, {\n    type: \"Raw\",\n    loc: this.getLocation(n, s),\n    value: this.substring(n, s)\n  };\n}\nfunction yi(t) {\n  this.tokenize(t.value);\n}\nconst ru = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: yi,\n  name: nu,\n  parse: Si,\n  structure: su\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Zn() {\n  return this.Raw(this.consumeUntilLeftCurlyBracket, !0);\n}\nfunction iu() {\n  const t = this.SelectorList();\n  return t.type !== \"Raw\" && this.eof === !1 && this.tokenType !== ht && this.error(), t;\n}\nconst ou = \"Rule\", au = \"rule\", lu = {\n  prelude: [\"SelectorList\", \"Raw\"],\n  block: [\"Block\"]\n};\nfunction bi() {\n  const t = this.tokenIndex, e = this.tokenStart;\n  let n, s;\n  return this.parseRulePrelude ? n = this.parseWithFallback(iu, Zn) : n = Zn.call(this, t), s = this.Block(!0), {\n    type: \"Rule\",\n    loc: this.getLocation(e, this.tokenStart),\n    prelude: n,\n    block: s\n  };\n}\nfunction xi(t) {\n  this.node(t.prelude), this.node(t.block);\n}\nconst cu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: xi,\n  name: ou,\n  parse: bi,\n  structure: lu,\n  walkContext: au\n}, Symbol.toStringTag, { value: \"Module\" })), uu = \"Scope\", hu = {\n  root: [\"SelectorList\", \"Raw\", null],\n  limit: [\"SelectorList\", \"Raw\", null]\n};\nfunction Ci() {\n  let t = null, e = null;\n  this.skipSC();\n  const n = this.tokenStart;\n  return this.tokenType === _ && (this.next(), this.skipSC(), t = this.parseWithFallback(\n    this.SelectorList,\n    () => this.Raw(!1, !0)\n  ), this.skipSC(), this.eat(S)), this.lookupNonWSType(0) === g && (this.skipSC(), this.eatIdent(\"to\"), this.skipSC(), this.eat(_), this.skipSC(), e = this.parseWithFallback(\n    this.SelectorList,\n    () => this.Raw(!1, !0)\n  ), this.skipSC(), this.eat(S)), {\n    type: \"Scope\",\n    loc: this.getLocation(n, this.tokenStart),\n    root: t,\n    limit: e\n  };\n}\nfunction wi(t) {\n  t.root && (this.token(_, \"(\"), this.node(t.root), this.token(S, \")\")), t.limit && (this.token(g, \"to\"), this.token(_, \"(\"), this.node(t.limit), this.token(S, \")\"));\n}\nconst fu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: wi,\n  name: uu,\n  parse: Ci,\n  structure: hu\n}, Symbol.toStringTag, { value: \"Module\" })), pu = \"Selector\", du = {\n  children: [[\n    \"TypeSelector\",\n    \"IdSelector\",\n    \"ClassSelector\",\n    \"AttributeSelector\",\n    \"PseudoClassSelector\",\n    \"PseudoElementSelector\",\n    \"Combinator\"\n  ]]\n};\nfunction Ti() {\n  const t = this.readSequence(this.scope.Selector);\n  return this.getFirstListNode(t) === null && this.error(\"Selector is expected\"), {\n    type: \"Selector\",\n    loc: this.getLocationFromList(t),\n    children: t\n  };\n}\nfunction Ai(t) {\n  this.children(t);\n}\nconst gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Ai,\n  name: pu,\n  parse: Ti,\n  structure: du\n}, Symbol.toStringTag, { value: \"Module\" })), mu = \"SelectorList\", ku = \"selector\", Su = {\n  children: [[\n    \"Selector\",\n    \"Raw\"\n  ]]\n};\nfunction vi() {\n  const t = this.createList();\n  for (; !this.eof; ) {\n    if (t.push(this.Selector()), this.tokenType === ft) {\n      this.next();\n      continue;\n    }\n    break;\n  }\n  return {\n    type: \"SelectorList\",\n    loc: this.getLocationFromList(t),\n    children: t\n  };\n}\nfunction Ei(t) {\n  this.children(t, () => this.token(ft, \",\"));\n}\nconst yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Ei,\n  name: mu,\n  parse: vi,\n  structure: Su,\n  walkContext: ku\n}, Symbol.toStringTag, { value: \"Module\" })), cn = 92, $i = 34, bu = 39;\nfunction Li(t) {\n  const e = t.length, n = t.charCodeAt(0), s = n === $i || n === bu ? 1 : 0, r = s === 1 && e > 1 && t.charCodeAt(e - 1) === n ? e - 2 : e - 1;\n  let o = \"\";\n  for (let a = s; a <= r; a++) {\n    let l = t.charCodeAt(a);\n    if (l === cn) {\n      if (a === r) {\n        a !== e - 1 && (o = t.substr(a + 1));\n        break;\n      }\n      if (l = t.charCodeAt(++a), kt(cn, l)) {\n        const u = a - 1, i = Jt(t, u);\n        a = i - 1, o += Ks(t.substring(u + 1, i));\n      } else\n        l === 13 && t.charCodeAt(a + 1) === 10 && a++;\n    } else\n      o += t[a];\n  }\n  return o;\n}\nfunction xu(t, e) {\n  const s = $i;\n  let r = \"\", o = !1;\n  for (let a = 0; a < t.length; a++) {\n    const l = t.charCodeAt(a);\n    if (l === 0) {\n      r += \"\";\n      continue;\n    }\n    if (l <= 31 || l === 127) {\n      r += \"\\\\\" + l.toString(16), o = !0;\n      continue;\n    }\n    l === s || l === cn ? (r += \"\\\\\" + t.charAt(a), o = !1) : (o && (Xt(l) || Ft(l)) && (r += \" \"), r += t.charAt(a), o = !1);\n  }\n  return '\"' + r + '\"';\n}\nconst Cu = \"String\", wu = {\n  value: String\n};\nfunction Pi() {\n  return {\n    type: \"String\",\n    loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    value: Li(this.consume(Tt))\n  };\n}\nfunction Oi(t) {\n  this.token(Tt, xu(t.value));\n}\nconst Tu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Oi,\n  name: Cu,\n  parse: Pi,\n  structure: wu\n}, Symbol.toStringTag, { value: \"Module\" })), Au = 33;\nfunction ts() {\n  return this.Raw(null, !1);\n}\nconst vu = \"StyleSheet\", Eu = \"stylesheet\", $u = {\n  children: [[\n    \"Comment\",\n    \"CDO\",\n    \"CDC\",\n    \"Atrule\",\n    \"Rule\",\n    \"Raw\"\n  ]]\n};\nfunction Ri() {\n  const t = this.tokenStart, e = this.createList();\n  let n;\n  for (; !this.eof; ) {\n    switch (this.tokenType) {\n      case W:\n        this.next();\n        continue;\n      case Y:\n        if (this.charCodeAt(this.tokenStart + 2) !== Au) {\n          this.next();\n          continue;\n        }\n        n = this.Comment();\n        break;\n      case De:\n        n = this.CDO();\n        break;\n      case nt:\n        n = this.CDC();\n        break;\n      // CSS Syntax Module Level 3\n      // 2.2 Error handling\n      // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n      case z:\n        n = this.parseWithFallback(this.Atrule, ts);\n        break;\n      // Anything else starts a qualified rule ...\n      default:\n        n = this.parseWithFallback(this.Rule, ts);\n    }\n    e.push(n);\n  }\n  return {\n    type: \"StyleSheet\",\n    loc: this.getLocation(t, this.tokenStart),\n    children: e\n  };\n}\nfunction _i(t) {\n  this.children(t);\n}\nconst Lu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: _i,\n  name: vu,\n  parse: Ri,\n  structure: $u,\n  walkContext: Eu\n}, Symbol.toStringTag, { value: \"Module\" })), Pu = \"SupportsDeclaration\", Ou = {\n  declaration: \"Declaration\"\n};\nfunction Ii() {\n  const t = this.tokenStart;\n  this.eat(_), this.skipSC();\n  const e = this.Declaration();\n  return this.eof || this.eat(S), {\n    type: \"SupportsDeclaration\",\n    loc: this.getLocation(t, this.tokenStart),\n    declaration: e\n  };\n}\nfunction Ni(t) {\n  this.token(_, \"(\"), this.node(t.declaration), this.token(S, \")\");\n}\nconst Ru = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Ni,\n  name: Pu,\n  parse: Ii,\n  structure: Ou\n}, Symbol.toStringTag, { value: \"Module\" })), _u = 42, es = 124;\nfunction Ge() {\n  this.tokenType !== g && this.isDelim(_u) === !1 && this.error(\"Identifier or asterisk is expected\"), this.next();\n}\nconst Iu = \"TypeSelector\", Nu = {\n  name: String\n};\nfunction Di() {\n  const t = this.tokenStart;\n  return this.isDelim(es) ? (this.next(), Ge.call(this)) : (Ge.call(this), this.isDelim(es) && (this.next(), Ge.call(this))), {\n    type: \"TypeSelector\",\n    loc: this.getLocation(t, this.tokenStart),\n    name: this.substrToCursor(t)\n  };\n}\nfunction Fi(t) {\n  this.tokenize(t.name);\n}\nconst Du = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Fi,\n  name: Iu,\n  parse: Di,\n  structure: Nu\n}, Symbol.toStringTag, { value: \"Module\" })), Mi = 43, ji = 45, un = 63;\nfunction se(t, e) {\n  let n = 0;\n  for (let s = this.tokenStart + t; s < this.tokenEnd; s++) {\n    const r = this.charCodeAt(s);\n    if (r === ji && e && n !== 0)\n      return se.call(this, t + n + 1, !1), -1;\n    Xt(r) || this.error(\n      e && n !== 0 ? \"Hyphen minus\" + (n < 6 ? \" or hex digit\" : \"\") + \" is expected\" : n < 6 ? \"Hex digit is expected\" : \"Unexpected input\",\n      s\n    ), ++n > 6 && this.error(\"Too many hex digits\", s);\n  }\n  return this.next(), n;\n}\nfunction me(t) {\n  let e = 0;\n  for (; this.isDelim(un); )\n    ++e > t && this.error(\"Too many question marks\"), this.next();\n}\nfunction Fu(t) {\n  this.charCodeAt(this.tokenStart) !== t && this.error((t === Mi ? \"Plus sign\" : \"Hyphen minus\") + \" is expected\");\n}\nfunction Mu() {\n  let t = 0;\n  switch (this.tokenType) {\n    case b:\n      if (t = se.call(this, 1, !0), this.isDelim(un)) {\n        me.call(this, 6 - t);\n        break;\n      }\n      if (this.tokenType === E || this.tokenType === b) {\n        Fu.call(this, ji), se.call(this, 1, !1);\n        break;\n      }\n      break;\n    case E:\n      t = se.call(this, 1, !0), t > 0 && me.call(this, 6 - t);\n      break;\n    default:\n      if (this.eatDelim(Mi), this.tokenType === g) {\n        t = se.call(this, 0, !0), t > 0 && me.call(this, 6 - t);\n        break;\n      }\n      if (this.isDelim(un)) {\n        this.next(), me.call(this, 5);\n        break;\n      }\n      this.error(\"Hex digit or question mark is expected\");\n  }\n}\nconst ju = \"UnicodeRange\", Bu = {\n  value: String\n};\nfunction Bi() {\n  const t = this.tokenStart;\n  return this.eatIdent(\"u\"), Mu.call(this), {\n    type: \"UnicodeRange\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: this.substrToCursor(t)\n  };\n}\nfunction Wi(t) {\n  this.tokenize(t.value);\n}\nconst Wu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Wi,\n  name: ju,\n  parse: Bi,\n  structure: Bu\n}, Symbol.toStringTag, { value: \"Module\" })), Uu = 32, hn = 92, zu = 34, Vu = 39, Hu = 40, Ui = 41;\nfunction Gu(t) {\n  const e = t.length;\n  let n = 4, s = t.charCodeAt(e - 1) === Ui ? e - 2 : e - 1, r = \"\";\n  for (; n < s && Ft(t.charCodeAt(n)); )\n    n++;\n  for (; n < s && Ft(t.charCodeAt(s)); )\n    s--;\n  for (let o = n; o <= s; o++) {\n    let a = t.charCodeAt(o);\n    if (a === hn) {\n      if (o === s) {\n        o !== e - 1 && (r = t.substr(o + 1));\n        break;\n      }\n      if (a = t.charCodeAt(++o), kt(hn, a)) {\n        const l = o - 1, u = Jt(t, l);\n        o = u - 1, r += Ks(t.substring(l + 1, u));\n      } else\n        a === 13 && t.charCodeAt(o + 1) === 10 && o++;\n    } else\n      r += t[o];\n  }\n  return r;\n}\nfunction qu(t) {\n  let e = \"\", n = !1;\n  for (let s = 0; s < t.length; s++) {\n    const r = t.charCodeAt(s);\n    if (r === 0) {\n      e += \"\";\n      continue;\n    }\n    if (r <= 31 || r === 127) {\n      e += \"\\\\\" + r.toString(16), n = !0;\n      continue;\n    }\n    r === Uu || r === hn || r === zu || r === Vu || r === Hu || r === Ui ? (e += \"\\\\\" + t.charAt(s), n = !1) : (n && Xt(r) && (e += \" \"), e += t.charAt(s), n = !1);\n  }\n  return \"url(\" + e + \")\";\n}\nconst Ku = \"Url\", Qu = {\n  value: String\n};\nfunction zi() {\n  const t = this.tokenStart;\n  let e;\n  switch (this.tokenType) {\n    case Q:\n      e = Gu(this.consume(Q));\n      break;\n    case T:\n      this.cmpStr(this.tokenStart, this.tokenEnd, \"url(\") || this.error(\"Function name must be `url`\"), this.eat(T), this.skipSC(), e = Li(this.consume(Tt)), this.skipSC(), this.eof || this.eat(S);\n      break;\n    default:\n      this.error(\"Url or Function is expected\");\n  }\n  return {\n    type: \"Url\",\n    loc: this.getLocation(t, this.tokenStart),\n    value: e\n  };\n}\nfunction Vi(t) {\n  this.token(Q, qu(t.value));\n}\nconst Yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Vi,\n  name: Ku,\n  parse: zi,\n  structure: Qu\n}, Symbol.toStringTag, { value: \"Module\" })), Xu = \"Value\", Ju = {\n  children: [[]]\n};\nfunction Hi() {\n  const t = this.tokenStart, e = this.readSequence(this.scope.Value);\n  return {\n    type: \"Value\",\n    loc: this.getLocation(t, this.tokenStart),\n    children: e\n  };\n}\nfunction Gi(t) {\n  this.children(t);\n}\nconst Zu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Gi,\n  name: Xu,\n  parse: Hi,\n  structure: Ju\n}, Symbol.toStringTag, { value: \"Module\" })), th = Object.freeze({\n  type: \"WhiteSpace\",\n  loc: null,\n  value: \" \"\n}), eh = \"WhiteSpace\", nh = {\n  value: String\n};\nfunction qi() {\n  return this.eat(W), th;\n}\nfunction Ki(t) {\n  this.token(W, t.value);\n}\nconst sh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  generate: Ki,\n  name: eh,\n  parse: qi,\n  structure: nh\n}, Symbol.toStringTag, { value: \"Module\" })), rh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AnPlusB: ga,\n  Atrule: ba,\n  AtrulePrelude: Ta,\n  AttributeSelector: Ra,\n  Block: Ma,\n  Brackets: Wa,\n  CDC: Va,\n  CDO: qa,\n  ClassSelector: Xa,\n  Combinator: sl,\n  Comment: ll,\n  Condition: pl,\n  Declaration: $l,\n  DeclarationList: Rl,\n  Dimension: Nl,\n  Feature: jl,\n  FeatureFunction: zl,\n  FeatureRange: Kl,\n  Function: Jl,\n  GeneralEnclosed: ec,\n  Hash: ic,\n  IdSelector: hc,\n  Identifier: lc,\n  Layer: gc,\n  LayerList: Sc,\n  MediaQuery: xc,\n  MediaQueryList: Tc,\n  NestingSelector: $c,\n  Nth: Oc,\n  Number: Ic,\n  Operator: Fc,\n  Parentheses: Bc,\n  Percentage: zc,\n  PseudoClassSelector: qc,\n  PseudoElementSelector: Xc,\n  Ratio: tu,\n  Raw: ru,\n  Rule: cu,\n  Scope: fu,\n  Selector: gu,\n  SelectorList: yu,\n  String: Tu,\n  StyleSheet: Lu,\n  SupportsDeclaration: Ru,\n  TypeSelector: Du,\n  UnicodeRange: Wu,\n  Url: Yu,\n  Value: Zu,\n  WhiteSpace: sh\n}, Symbol.toStringTag, { value: \"Module\" })), ih = {\n  node: rh\n}, $t = Zo(ih), wn = [\n  \"left\",\n  \"right\",\n  \"top\",\n  \"bottom\",\n  \"inset-block-start\",\n  \"inset-block-end\",\n  \"inset-inline-start\",\n  \"inset-inline-end\",\n  \"inset-block\",\n  \"inset-inline\",\n  \"inset\"\n];\nfunction ue(t) {\n  return wn.includes(t);\n}\nconst Tn = [\n  \"margin-block-start\",\n  \"margin-block-end\",\n  \"margin-block\",\n  \"margin-inline-start\",\n  \"margin-inline-end\",\n  \"margin-inline\",\n  \"margin-bottom\",\n  \"margin-left\",\n  \"margin-right\",\n  \"margin-top\",\n  \"margin\"\n];\nfunction oh(t) {\n  return Tn.includes(t);\n}\nconst An = [\n  \"width\",\n  \"height\",\n  \"min-width\",\n  \"min-height\",\n  \"max-width\",\n  \"max-height\",\n  \"block-size\",\n  \"inline-size\",\n  \"min-block-size\",\n  \"min-inline-size\",\n  \"max-block-size\",\n  \"max-inline-size\"\n];\nfunction Qi(t) {\n  return An.includes(t);\n}\nconst Yi = [\n  \"justify-self\",\n  \"align-self\",\n  \"place-self\"\n];\nfunction ah(t) {\n  return Yi.includes(t);\n}\nconst Xi = [\n  ...wn,\n  ...Tn,\n  ...An,\n  ...Yi,\n  \"position-anchor\",\n  \"position-area\"\n], lh = [\n  ...An,\n  ...wn,\n  ...Tn\n];\nfunction Ji(t) {\n  return lh.includes(\n    t\n  );\n}\nconst ch = [\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"start\",\n  \"end\",\n  \"self-start\",\n  \"self-end\",\n  \"center\",\n  \"inside\",\n  \"outside\"\n];\nfunction Zi(t) {\n  return ch.includes(t);\n}\nconst uh = [\n  \"width\",\n  \"height\",\n  \"block\",\n  \"inline\",\n  \"self-block\",\n  \"self-inline\"\n];\nfunction hh(t) {\n  return uh.includes(t);\n}\nconst ns = /* @__PURE__ */ new Set([\"Atrule\", \"Selector\", \"Declaration\"]);\nfunction fh(t) {\n  const e = new SourceMapGenerator(), n = {\n    line: 1,\n    column: 0\n  }, s = {\n    line: 0,\n    // should be zero to add first mapping\n    column: 0\n  }, r = {\n    line: 1,\n    column: 0\n  }, o = {\n    generated: r\n  };\n  let a = 1, l = 0, u = !1;\n  const i = t.node;\n  t.node = function(f) {\n    if (f.loc && f.loc.start && ns.has(f.type)) {\n      const p = f.loc.start.line, d = f.loc.start.column - 1;\n      (s.line !== p || s.column !== d) && (s.line = p, s.column = d, n.line = a, n.column = l, u && (u = !1, (n.line !== r.line || n.column !== r.column) && e.addMapping(o)), u = !0, e.addMapping({\n        source: f.loc.source,\n        original: s,\n        generated: n\n      }));\n    }\n    i.call(this, f), u && ns.has(f.type) && (r.line = a, r.column = l);\n  };\n  const c = t.emit;\n  t.emit = function(f, p, d) {\n    for (let m = 0; m < f.length; m++)\n      f.charCodeAt(m) === 10 ? (a++, l = 0) : l++;\n    c(f, p, d);\n  };\n  const h = t.result;\n  return t.result = function() {\n    return u && e.addMapping(o), {\n      css: h(),\n      map: e\n    };\n  }, t;\n}\nconst ph = 43, dh = 45, qe = (t, e) => {\n  if (t === L && (t = e), typeof t == \"string\") {\n    const n = t.charCodeAt(0);\n    return n > 127 ? 32768 : n << 8;\n  }\n  return t;\n}, to = [\n  [g, g],\n  [g, T],\n  [g, Q],\n  [g, at],\n  [g, \"-\"],\n  [g, b],\n  [g, F],\n  [g, E],\n  [g, nt],\n  [g, _],\n  [z, g],\n  [z, T],\n  [z, Q],\n  [z, at],\n  [z, \"-\"],\n  [z, b],\n  [z, F],\n  [z, E],\n  [z, nt],\n  [I, g],\n  [I, T],\n  [I, Q],\n  [I, at],\n  [I, \"-\"],\n  [I, b],\n  [I, F],\n  [I, E],\n  [I, nt],\n  [E, g],\n  [E, T],\n  [E, Q],\n  [E, at],\n  [E, \"-\"],\n  [E, b],\n  [E, F],\n  [E, E],\n  [E, nt],\n  [\"#\", g],\n  [\"#\", T],\n  [\"#\", Q],\n  [\"#\", at],\n  [\"#\", \"-\"],\n  [\"#\", b],\n  [\"#\", F],\n  [\"#\", E],\n  [\"#\", nt],\n  // https://github.com/w3c/csswg-drafts/pull/6874\n  [\"-\", g],\n  [\"-\", T],\n  [\"-\", Q],\n  [\"-\", at],\n  [\"-\", \"-\"],\n  [\"-\", b],\n  [\"-\", F],\n  [\"-\", E],\n  [\"-\", nt],\n  // https://github.com/w3c/csswg-drafts/pull/6874\n  [b, g],\n  [b, T],\n  [b, Q],\n  [b, at],\n  [b, b],\n  [b, F],\n  [b, E],\n  [b, \"%\"],\n  [b, nt],\n  // https://github.com/w3c/csswg-drafts/pull/6874\n  [\"@\", g],\n  [\"@\", T],\n  [\"@\", Q],\n  [\"@\", at],\n  [\"@\", \"-\"],\n  [\"@\", nt],\n  // https://github.com/w3c/csswg-drafts/pull/6874\n  [\".\", b],\n  [\".\", F],\n  [\".\", E],\n  [\"+\", b],\n  [\"+\", F],\n  [\"+\", E],\n  [\"/\", \"*\"]\n], gh = to.concat([\n  [g, I],\n  [E, I],\n  [I, I],\n  [z, _],\n  [z, Tt],\n  [z, X],\n  [F, F],\n  [F, E],\n  [F, T],\n  [F, \"-\"],\n  [S, g],\n  [S, T],\n  [S, F],\n  [S, E],\n  [S, I],\n  [S, \"-\"]\n]);\nfunction eo(t) {\n  const e = new Set(\n    t.map(([n, s]) => qe(n) << 16 | qe(s))\n  );\n  return function(n, s, r) {\n    const o = qe(s, r), a = r.charCodeAt(0);\n    return (a === dh && s !== g && s !== T && s !== nt || a === ph ? e.has(n << 16 | a << 8) : e.has(n << 16 | o)) && this.emit(\" \", W, !0), o;\n  };\n}\nconst mh = eo(to), no = eo(gh), ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  safe: no,\n  spec: mh\n}, Symbol.toStringTag, { value: \"Module\" })), kh = 92;\nfunction Sh(t, e) {\n  if (typeof e == \"function\") {\n    let n = null;\n    t.children.forEach((s) => {\n      n !== null && e.call(this, n), this.node(s), n = s;\n    });\n    return;\n  }\n  t.children.forEach(this.node, this);\n}\nfunction yh(t) {\n  Ys(t, (e, n, s) => {\n    this.token(e, t.slice(n, s));\n  });\n}\nfunction bh(t) {\n  const e = /* @__PURE__ */ new Map();\n  for (let [n, s] of Object.entries(t.node))\n    typeof (s.generate || s) == \"function\" && e.set(n, s.generate || s);\n  return function(n, s) {\n    let r = \"\", o = 0, a = {\n      node(u) {\n        if (e.has(u.type))\n          e.get(u.type).call(l, u);\n        else\n          throw new Error(\"Unknown node type: \" + u.type);\n      },\n      tokenBefore: no,\n      token(u, i) {\n        o = this.tokenBefore(o, u, i), this.emit(i, u, !1), u === L && i.charCodeAt(0) === kh && this.emit(`\n`, W, !0);\n      },\n      emit(u) {\n        r += u;\n      },\n      result() {\n        return r;\n      }\n    };\n    s && (typeof s.decorator == \"function\" && (a = s.decorator(a)), s.sourceMap && (a = fh(a)), s.mode in ss && (a.tokenBefore = ss[s.mode]));\n    const l = {\n      node: (u) => a.node(u),\n      children: Sh,\n      token: (u, i) => a.token(u, i),\n      tokenize: yh\n    };\n    return a.node(n), a.result();\n  };\n}\nconst xh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AnPlusB: Js,\n  Atrule: tr,\n  AtrulePrelude: nr,\n  AttributeSelector: ir,\n  Block: lr,\n  Brackets: ur,\n  CDC: fr,\n  CDO: dr,\n  ClassSelector: mr,\n  Combinator: Sr,\n  Comment: br,\n  Condition: Cr,\n  Declaration: Ar,\n  DeclarationList: Er,\n  Dimension: Lr,\n  Feature: Or,\n  FeatureFunction: _r,\n  FeatureRange: Nr,\n  Function: Fr,\n  GeneralEnclosed: jr,\n  Hash: Wr,\n  IdSelector: Hr,\n  Identifier: zr,\n  Layer: qr,\n  LayerList: Qr,\n  MediaQuery: Xr,\n  MediaQueryList: Zr,\n  NestingSelector: ei,\n  Nth: si,\n  Number: ii,\n  Operator: ai,\n  Parentheses: ci,\n  Percentage: hi,\n  PseudoClassSelector: pi,\n  PseudoElementSelector: gi,\n  Ratio: ki,\n  Raw: yi,\n  Rule: xi,\n  Scope: wi,\n  Selector: Ai,\n  SelectorList: Ei,\n  String: Oi,\n  StyleSheet: _i,\n  SupportsDeclaration: Ni,\n  TypeSelector: Fi,\n  UnicodeRange: Wi,\n  Url: Vi,\n  Value: Gi,\n  WhiteSpace: Ki\n}, Symbol.toStringTag, { value: \"Module\" })), Ch = {\n  node: xh\n}, wh = bh(Ch);\nlet zt = null;\nclass K {\n  static createItem(e) {\n    return {\n      prev: null,\n      next: null,\n      data: e\n    };\n  }\n  constructor() {\n    this.head = null, this.tail = null, this.cursor = null;\n  }\n  createItem(e) {\n    return K.createItem(e);\n  }\n  // cursor helpers\n  allocateCursor(e, n) {\n    let s;\n    return zt !== null ? (s = zt, zt = zt.cursor, s.prev = e, s.next = n, s.cursor = this.cursor) : s = {\n      prev: e,\n      next: n,\n      cursor: this.cursor\n    }, this.cursor = s, s;\n  }\n  releaseCursor() {\n    const { cursor: e } = this;\n    this.cursor = e.cursor, e.prev = null, e.next = null, e.cursor = zt, zt = e;\n  }\n  updateCursors(e, n, s, r) {\n    let { cursor: o } = this;\n    for (; o !== null; )\n      o.prev === e && (o.prev = n), o.next === s && (o.next = r), o = o.cursor;\n  }\n  *[Symbol.iterator]() {\n    for (let e = this.head; e !== null; e = e.next)\n      yield e.data;\n  }\n  // getters\n  get size() {\n    let e = 0;\n    for (let n = this.head; n !== null; n = n.next)\n      e++;\n    return e;\n  }\n  get isEmpty() {\n    return this.head === null;\n  }\n  get first() {\n    return this.head && this.head.data;\n  }\n  get last() {\n    return this.tail && this.tail.data;\n  }\n  // convertors\n  fromArray(e) {\n    let n = null;\n    this.head = null;\n    for (let s of e) {\n      const r = K.createItem(s);\n      n !== null ? n.next = r : this.head = r, r.prev = n, n = r;\n    }\n    return this.tail = n, this;\n  }\n  toArray() {\n    return [...this];\n  }\n  toJSON() {\n    return [...this];\n  }\n  // array-like methods\n  forEach(e, n = this) {\n    const s = this.allocateCursor(null, this.head);\n    for (; s.next !== null; ) {\n      const r = s.next;\n      s.next = r.next, e.call(n, r.data, r, this);\n    }\n    this.releaseCursor();\n  }\n  forEachRight(e, n = this) {\n    const s = this.allocateCursor(this.tail, null);\n    for (; s.prev !== null; ) {\n      const r = s.prev;\n      s.prev = r.prev, e.call(n, r.data, r, this);\n    }\n    this.releaseCursor();\n  }\n  reduce(e, n, s = this) {\n    let r = this.allocateCursor(null, this.head), o = n, a;\n    for (; r.next !== null; )\n      a = r.next, r.next = a.next, o = e.call(s, o, a.data, a, this);\n    return this.releaseCursor(), o;\n  }\n  reduceRight(e, n, s = this) {\n    let r = this.allocateCursor(this.tail, null), o = n, a;\n    for (; r.prev !== null; )\n      a = r.prev, r.prev = a.prev, o = e.call(s, o, a.data, a, this);\n    return this.releaseCursor(), o;\n  }\n  some(e, n = this) {\n    for (let s = this.head; s !== null; s = s.next)\n      if (e.call(n, s.data, s, this))\n        return !0;\n    return !1;\n  }\n  map(e, n = this) {\n    const s = new K();\n    for (let r = this.head; r !== null; r = r.next)\n      s.appendData(e.call(n, r.data, r, this));\n    return s;\n  }\n  filter(e, n = this) {\n    const s = new K();\n    for (let r = this.head; r !== null; r = r.next)\n      e.call(n, r.data, r, this) && s.appendData(r.data);\n    return s;\n  }\n  nextUntil(e, n, s = this) {\n    if (e === null)\n      return;\n    const r = this.allocateCursor(null, e);\n    for (; r.next !== null; ) {\n      const o = r.next;\n      if (r.next = o.next, n.call(s, o.data, o, this))\n        break;\n    }\n    this.releaseCursor();\n  }\n  prevUntil(e, n, s = this) {\n    if (e === null)\n      return;\n    const r = this.allocateCursor(e, null);\n    for (; r.prev !== null; ) {\n      const o = r.prev;\n      if (r.prev = o.prev, n.call(s, o.data, o, this))\n        break;\n    }\n    this.releaseCursor();\n  }\n  // mutation\n  clear() {\n    this.head = null, this.tail = null;\n  }\n  copy() {\n    const e = new K();\n    for (let n of this)\n      e.appendData(n);\n    return e;\n  }\n  prepend(e) {\n    return this.updateCursors(null, e, this.head, e), this.head !== null ? (this.head.prev = e, e.next = this.head) : this.tail = e, this.head = e, this;\n  }\n  prependData(e) {\n    return this.prepend(K.createItem(e));\n  }\n  append(e) {\n    return this.insert(e);\n  }\n  appendData(e) {\n    return this.insert(K.createItem(e));\n  }\n  insert(e, n = null) {\n    if (n !== null)\n      if (this.updateCursors(n.prev, e, n, e), n.prev === null) {\n        if (this.head !== n)\n          throw new Error(\"before doesn't belong to list\");\n        this.head = e, n.prev = e, e.next = n, this.updateCursors(null, e);\n      } else\n        n.prev.next = e, e.prev = n.prev, n.prev = e, e.next = n;\n    else\n      this.updateCursors(this.tail, e, null, e), this.tail !== null ? (this.tail.next = e, e.prev = this.tail) : this.head = e, this.tail = e;\n    return this;\n  }\n  insertData(e, n) {\n    return this.insert(K.createItem(e), n);\n  }\n  remove(e) {\n    if (this.updateCursors(e, e.prev, e, e.next), e.prev !== null)\n      e.prev.next = e.next;\n    else {\n      if (this.head !== e)\n        throw new Error(\"item doesn't belong to list\");\n      this.head = e.next;\n    }\n    if (e.next !== null)\n      e.next.prev = e.prev;\n    else {\n      if (this.tail !== e)\n        throw new Error(\"item doesn't belong to list\");\n      this.tail = e.prev;\n    }\n    return e.prev = null, e.next = null, e;\n  }\n  push(e) {\n    this.insert(K.createItem(e));\n  }\n  pop() {\n    return this.tail !== null ? this.remove(this.tail) : null;\n  }\n  unshift(e) {\n    this.prepend(K.createItem(e));\n  }\n  shift() {\n    return this.head !== null ? this.remove(this.head) : null;\n  }\n  prependList(e) {\n    return this.insertList(e, this.head);\n  }\n  appendList(e) {\n    return this.insertList(e);\n  }\n  insertList(e, n) {\n    return e.head === null ? this : (n != null ? (this.updateCursors(n.prev, e.tail, n, e.head), n.prev !== null ? (n.prev.next = e.head, e.head.prev = n.prev) : this.head = e.head, n.prev = e.tail, e.tail.next = n) : (this.updateCursors(this.tail, e.tail, null, e.head), this.tail !== null ? (this.tail.next = e.head, e.head.prev = this.tail) : this.head = e.head, this.tail = e.tail), e.head = null, e.tail = null, this);\n  }\n  replace(e, n) {\n    \"head\" in n ? this.insertList(n, e) : this.insert(n, e), this.remove(e);\n  }\n}\nfunction Th(t, e) {\n  const n = Object.create(SyntaxError.prototype), s = new Error();\n  return Object.assign(n, {\n    name: t,\n    message: e,\n    get stack() {\n      return (s.stack || \"\").replace(/^(.+\\n){1,3}/, `${t}: ${e}\n`);\n    }\n  });\n}\nconst Ke = 100, rs = 60, is = \"    \";\nfunction os({ source: t, line: e, column: n, baseLine: s, baseColumn: r }, o) {\n  function a(d, m) {\n    return i.slice(d, m).map(\n      (k, y) => String(d + y + 1).padStart(f) + \" |\" + k\n    ).join(`\n`);\n  }\n  const l = `\n`.repeat(Math.max(s - 1, 0)), u = \" \".repeat(Math.max(r - 1, 0)), i = (l + u + t).split(/\\r\\n?|\\n|\\f/), c = Math.max(1, e - o) - 1, h = Math.min(e + o, i.length + 1), f = Math.max(4, String(h).length) + 1;\n  let p = 0;\n  n += (is.length - 1) * (i[e - 1].substr(0, n - 1).match(/\\t/g) || []).length, n > Ke && (p = n - rs + 3, n = rs - 2);\n  for (let d = c; d <= h; d++)\n    d >= 0 && d < i.length && (i[d] = i[d].replace(/\\t/g, is), i[d] = (p > 0 && i[d].length > p ? \"\" : \"\") + i[d].substr(p, Ke - 2) + (i[d].length > p + Ke - 1 ? \"\" : \"\"));\n  return [\n    a(c, e),\n    new Array(n + f + 2).join(\"-\") + \"^\",\n    a(e, h)\n  ].filter(Boolean).join(`\n`).replace(/^(\\s+\\d+\\s+\\|\\n)+/, \"\").replace(/\\n(\\s+\\d+\\s+\\|)+$/, \"\");\n}\nfunction as(t, e, n, s, r, o = 1, a = 1) {\n  return Object.assign(Th(\"SyntaxError\", t), {\n    source: e,\n    offset: n,\n    line: s,\n    column: r,\n    sourceFragment(u) {\n      return os({ source: e, line: s, column: r, baseLine: o, baseColumn: a }, isNaN(u) ? 0 : u);\n    },\n    get formattedMessage() {\n      return `Parse error: ${t}\n` + os({ source: e, line: s, column: r, baseLine: o, baseColumn: a }, 2);\n    }\n  });\n}\nfunction Ah(t) {\n  const e = this.createList();\n  let n = !1;\n  const s = {\n    recognizer: t\n  };\n  for (; !this.eof; ) {\n    switch (this.tokenType) {\n      case Y:\n        this.next();\n        continue;\n      case W:\n        n = !0, this.next();\n        continue;\n    }\n    let r = t.getNode.call(this, s);\n    if (r === void 0)\n      break;\n    n && (t.onWhiteSpace && t.onWhiteSpace.call(this, r, e, s), n = !1), e.push(r);\n  }\n  return n && t.onWhiteSpace && t.onWhiteSpace.call(this, null, e, s), e;\n}\nconst ls = () => {\n}, vh = 33, Eh = 35, Qe = 59, cs = 123, us = 0;\nfunction $h(t) {\n  return function() {\n    return this[t]();\n  };\n}\nfunction Ye(t) {\n  const e = /* @__PURE__ */ Object.create(null);\n  for (const n of Object.keys(t)) {\n    const s = t[n], r = s.parse || s;\n    r && (e[n] = r);\n  }\n  return e;\n}\nfunction Lh(t) {\n  const e = {\n    context: /* @__PURE__ */ Object.create(null),\n    features: Object.assign(/* @__PURE__ */ Object.create(null), t.features),\n    scope: Object.assign(/* @__PURE__ */ Object.create(null), t.scope),\n    atrule: Ye(t.atrule),\n    pseudo: Ye(t.pseudo),\n    node: Ye(t.node)\n  };\n  for (const [n, s] of Object.entries(t.parseContext))\n    switch (typeof s) {\n      case \"function\":\n        e.context[n] = s;\n        break;\n      case \"string\":\n        e.context[n] = $h(s);\n        break;\n    }\n  return U(U({\n    config: e\n  }, e), e.node);\n}\nfunction Ph(t) {\n  let e = \"\", n = \"<unknown>\", s = !1, r = ls, o = !1;\n  const a = new ua(), l = Object.assign(new ha(), Lh(t || {}), {\n    parseAtrulePrelude: !0,\n    parseRulePrelude: !0,\n    parseValue: !0,\n    parseCustomProperty: !1,\n    readSequence: Ah,\n    consumeUntilBalanceEnd: () => 0,\n    consumeUntilLeftCurlyBracket(i) {\n      return i === cs ? 1 : 0;\n    },\n    consumeUntilLeftCurlyBracketOrSemicolon(i) {\n      return i === cs || i === Qe ? 1 : 0;\n    },\n    consumeUntilExclamationMarkOrSemicolon(i) {\n      return i === vh || i === Qe ? 1 : 0;\n    },\n    consumeUntilSemicolonIncluded(i) {\n      return i === Qe ? 2 : 0;\n    },\n    createList() {\n      return new K();\n    },\n    createSingleNodeList(i) {\n      return new K().appendData(i);\n    },\n    getFirstListNode(i) {\n      return i && i.first;\n    },\n    getLastListNode(i) {\n      return i && i.last;\n    },\n    parseWithFallback(i, c) {\n      const h = this.tokenIndex;\n      try {\n        return i.call(this);\n      } catch (f) {\n        if (o)\n          throw f;\n        this.skip(h - this.tokenIndex);\n        const p = c.call(this);\n        return o = !0, r(f, p), o = !1, p;\n      }\n    },\n    lookupNonWSType(i) {\n      let c;\n      do\n        if (c = this.lookupType(i++), c !== W && c !== Y)\n          return c;\n      while (c !== us);\n      return us;\n    },\n    charCodeAt(i) {\n      return i >= 0 && i < e.length ? e.charCodeAt(i) : 0;\n    },\n    substring(i, c) {\n      return e.substring(i, c);\n    },\n    substrToCursor(i) {\n      return this.source.substring(i, this.tokenStart);\n    },\n    cmpChar(i, c) {\n      return Gs(e, i, c);\n    },\n    cmpStr(i, c, h) {\n      return $e(e, i, c, h);\n    },\n    consume(i) {\n      const c = this.tokenStart;\n      return this.eat(i), this.substrToCursor(c);\n    },\n    consumeFunctionName() {\n      const i = e.substring(this.tokenStart, this.tokenEnd - 1);\n      return this.eat(T), i;\n    },\n    consumeNumber(i) {\n      const c = e.substring(this.tokenStart, qs(e, this.tokenStart));\n      return this.eat(i), c;\n    },\n    eat(i) {\n      if (this.tokenType !== i) {\n        const c = Qs[i].slice(0, -6).replace(/-/g, \" \").replace(/^./, (p) => p.toUpperCase());\n        let h = `${/[[\\](){}]/.test(c) ? `\"${c}\"` : c} is expected`, f = this.tokenStart;\n        switch (i) {\n          case g:\n            this.tokenType === T || this.tokenType === Q ? (f = this.tokenEnd - 1, h = \"Identifier is expected but function found\") : h = \"Identifier is expected\";\n            break;\n          case I:\n            this.isDelim(Eh) && (this.next(), f++, h = \"Name is expected\");\n            break;\n          case F:\n            this.tokenType === b && (f = this.tokenEnd, h = \"Percent sign is expected\");\n            break;\n        }\n        this.error(h, f);\n      }\n      this.next();\n    },\n    eatIdent(i) {\n      (this.tokenType !== g || this.lookupValue(0, i) === !1) && this.error(`Identifier \"${i}\" is expected`), this.next();\n    },\n    eatDelim(i) {\n      this.isDelim(i) || this.error(`Delim \"${String.fromCharCode(i)}\" is expected`), this.next();\n    },\n    getLocation(i, c) {\n      return s ? a.getLocationRange(\n        i,\n        c,\n        n\n      ) : null;\n    },\n    getLocationFromList(i) {\n      if (s) {\n        const c = this.getFirstListNode(i), h = this.getLastListNode(i);\n        return a.getLocationRange(\n          c !== null ? c.loc.start.offset - a.startOffset : this.tokenStart,\n          h !== null ? h.loc.end.offset - a.startOffset : this.tokenStart,\n          n\n        );\n      }\n      return null;\n    },\n    error(i, c) {\n      const h = typeof c != \"undefined\" && c < e.length ? a.getLocation(c) : this.eof ? a.getLocation(aa(e, e.length - 1)) : a.getLocation(this.tokenStart);\n      throw new as(\n        i || \"Unexpected input\",\n        e,\n        h.offset,\n        h.line,\n        h.column,\n        a.startLine,\n        a.startColumn\n      );\n    }\n  });\n  return Object.assign(function(i, c) {\n    e = i, c = c || {}, l.setSource(e, Ys), a.setSource(\n      e,\n      c.offset,\n      c.line,\n      c.column\n    ), n = c.filename || \"<unknown>\", s = !!c.positions, r = typeof c.onParseError == \"function\" ? c.onParseError : ls, o = !1, l.parseAtrulePrelude = \"parseAtrulePrelude\" in c ? !!c.parseAtrulePrelude : !0, l.parseRulePrelude = \"parseRulePrelude\" in c ? !!c.parseRulePrelude : !0, l.parseValue = \"parseValue\" in c ? !!c.parseValue : !0, l.parseCustomProperty = \"parseCustomProperty\" in c ? !!c.parseCustomProperty : !1;\n    const { context: h = \"default\", onComment: f } = c;\n    if (!(h in l.context))\n      throw new Error(\"Unknown context `\" + h + \"`\");\n    typeof f == \"function\" && l.forEachToken((d, m, k) => {\n      if (d === Y) {\n        const y = l.getLocation(m, k), x = $e(e, k - 2, k, \"*/\") ? e.slice(m + 2, k - 2) : e.slice(m + 2, k);\n        f(x, y);\n      }\n    });\n    const p = l.context[h].call(l, c);\n    return l.eof || l.error(), p;\n  }, {\n    SyntaxError: as,\n    config: l.config\n  });\n}\nconst Oh = 35, Rh = 42, hs = 43, _h = 45, Ih = 47, Nh = 117;\nfunction so(t) {\n  switch (this.tokenType) {\n    case I:\n      return this.Hash();\n    case ft:\n      return this.Operator();\n    case _:\n      return this.Parentheses(this.readSequence, t.recognizer);\n    case ee:\n      return this.Brackets(this.readSequence, t.recognizer);\n    case Tt:\n      return this.String();\n    case E:\n      return this.Dimension();\n    case F:\n      return this.Percentage();\n    case b:\n      return this.Number();\n    case T:\n      return this.cmpStr(this.tokenStart, this.tokenEnd, \"url(\") ? this.Url() : this.Function(this.readSequence, t.recognizer);\n    case Q:\n      return this.Url();\n    case g:\n      return this.cmpChar(this.tokenStart, Nh) && this.cmpChar(this.tokenStart + 1, hs) ? this.UnicodeRange() : this.Identifier();\n    case L: {\n      const e = this.charCodeAt(this.tokenStart);\n      if (e === Ih || e === Rh || e === hs || e === _h)\n        return this.Operator();\n      e === Oh && this.error(\"Hex or identifier is expected\", this.tokenStart + 1);\n      break;\n    }\n  }\n}\nconst Dh = {\n  getNode: so\n}, Fh = 35, Mh = 38, jh = 42, Bh = 43, Wh = 47, fs = 46, Uh = 62, zh = 124, Vh = 126;\nfunction Hh(t, e) {\n  e.last !== null && e.last.type !== \"Combinator\" && t !== null && t.type !== \"Combinator\" && e.push({\n    // FIXME: this.Combinator() should be used instead\n    type: \"Combinator\",\n    loc: null,\n    name: \" \"\n  });\n}\nfunction Gh() {\n  switch (this.tokenType) {\n    case ee:\n      return this.AttributeSelector();\n    case I:\n      return this.IdSelector();\n    case X:\n      return this.lookupType(1) === X ? this.PseudoElementSelector() : this.PseudoClassSelector();\n    case g:\n      return this.TypeSelector();\n    case b:\n    case F:\n      return this.Percentage();\n    case E:\n      this.charCodeAt(this.tokenStart) === fs && this.error(\"Identifier is expected\", this.tokenStart + 1);\n      break;\n    case L: {\n      switch (this.charCodeAt(this.tokenStart)) {\n        case Bh:\n        case Uh:\n        case Vh:\n        case Wh:\n          return this.Combinator();\n        case fs:\n          return this.ClassSelector();\n        case jh:\n        case zh:\n          return this.TypeSelector();\n        case Fh:\n          return this.IdSelector();\n        case Mh:\n          return this.NestingSelector();\n      }\n      break;\n    }\n  }\n}\nconst qh = {\n  onWhiteSpace: Hh,\n  getNode: Gh\n};\nfunction Kh() {\n  return this.createSingleNodeList(\n    this.Raw(null, !1)\n  );\n}\nfunction Qh() {\n  const t = this.createList();\n  if (this.skipSC(), t.push(this.Identifier()), this.skipSC(), this.tokenType === ft) {\n    t.push(this.Operator());\n    const e = this.tokenIndex, n = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, !1);\n    if (n.type === \"Value\" && n.children.isEmpty) {\n      for (let s = e - this.tokenIndex; s <= 0; s++)\n        if (this.lookupType(s) === W) {\n          n.children.appendData({\n            type: \"WhiteSpace\",\n            loc: null,\n            value: \" \"\n          });\n          break;\n        }\n    }\n    t.push(n);\n  }\n  return t;\n}\nfunction ps(t) {\n  return t !== null && t.type === \"Operator\" && (t.value[t.value.length - 1] === \"-\" || t.value[t.value.length - 1] === \"+\");\n}\nconst Yh = {\n  getNode: so,\n  onWhiteSpace(t, e) {\n    ps(t) && (t.value = \" \" + t.value), ps(e.last) && (e.last.value += \" \");\n  },\n  expression: Kh,\n  var: Qh\n}, Xh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AtrulePrelude: Dh,\n  Selector: qh,\n  Value: Yh\n}, Symbol.toStringTag, { value: \"Module\" })), Jh = /* @__PURE__ */ new Set([\"none\", \"and\", \"not\", \"or\"]), Zh = {\n  parse: {\n    prelude() {\n      const t = this.createList();\n      if (this.tokenType === g) {\n        const e = this.substring(this.tokenStart, this.tokenEnd);\n        Jh.has(e.toLowerCase()) || t.push(this.Identifier());\n      }\n      return t.push(this.Condition(\"container\")), t;\n    },\n    block(t = !1) {\n      return this.Block(t);\n    }\n  }\n}, tf = {\n  parse: {\n    prelude: null,\n    block() {\n      return this.Block(!0);\n    }\n  }\n};\nfunction Xe(t, e) {\n  return this.parseWithFallback(\n    () => {\n      try {\n        return t.call(this);\n      } finally {\n        this.skipSC(), this.lookupNonWSType(0) !== S && this.error();\n      }\n    },\n    e || (() => this.Raw(null, !0))\n  );\n}\nconst ds = {\n  layer() {\n    this.skipSC();\n    const t = this.createList(), e = Xe.call(this, this.Layer);\n    return (e.type !== \"Raw\" || e.value !== \"\") && t.push(e), t;\n  },\n  supports() {\n    this.skipSC();\n    const t = this.createList(), e = Xe.call(\n      this,\n      this.Declaration,\n      () => Xe.call(this, () => this.Condition(\"supports\"))\n    );\n    return (e.type !== \"Raw\" || e.value !== \"\") && t.push(e), t;\n  }\n}, ef = {\n  parse: {\n    prelude() {\n      const t = this.createList();\n      switch (this.tokenType) {\n        case Tt:\n          t.push(this.String());\n          break;\n        case Q:\n        case T:\n          t.push(this.Url());\n          break;\n        default:\n          this.error(\"String or url() is expected\");\n      }\n      return this.skipSC(), this.tokenType === g && this.cmpStr(this.tokenStart, this.tokenEnd, \"layer\") ? t.push(this.Identifier()) : this.tokenType === T && this.cmpStr(this.tokenStart, this.tokenEnd, \"layer(\") && t.push(this.Function(null, ds)), this.skipSC(), this.tokenType === T && this.cmpStr(this.tokenStart, this.tokenEnd, \"supports(\") && t.push(this.Function(null, ds)), (this.lookupNonWSType(0) === g || this.lookupNonWSType(0) === _) && t.push(this.MediaQueryList()), t;\n    },\n    block: null\n  }\n}, nf = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.LayerList()\n      );\n    },\n    block() {\n      return this.Block(!1);\n    }\n  }\n}, sf = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.MediaQueryList()\n      );\n    },\n    block(t = !1) {\n      return this.Block(t);\n    }\n  }\n}, rf = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.SelectorList()\n      );\n    },\n    block() {\n      return this.Block(!0);\n    }\n  }\n}, of = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.SelectorList()\n      );\n    },\n    block() {\n      return this.Block(!0);\n    }\n  }\n}, af = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.Scope()\n      );\n    },\n    block(t = !1) {\n      return this.Block(t);\n    }\n  }\n}, lf = {\n  parse: {\n    prelude: null,\n    block(t = !1) {\n      return this.Block(t);\n    }\n  }\n}, cf = {\n  parse: {\n    prelude() {\n      return this.createSingleNodeList(\n        this.Condition(\"supports\")\n      );\n    },\n    block(t = !1) {\n      return this.Block(t);\n    }\n  }\n}, uf = {\n  container: Zh,\n  \"font-face\": tf,\n  import: ef,\n  layer: nf,\n  media: sf,\n  nest: rf,\n  page: of,\n  scope: af,\n  \"starting-style\": lf,\n  supports: cf\n};\nfunction hf() {\n  const t = this.createList();\n  this.skipSC();\n  t: for (; !this.eof; ) {\n    switch (this.tokenType) {\n      case g:\n        t.push(this.Identifier());\n        break;\n      case Tt:\n        t.push(this.String());\n        break;\n      case ft:\n        t.push(this.Operator());\n        break;\n      case S:\n        break t;\n      default:\n        this.error(\"Identifier, string or comma is expected\");\n    }\n    this.skipSC();\n  }\n  return t;\n}\nconst Rt = {\n  parse() {\n    return this.createSingleNodeList(\n      this.SelectorList()\n    );\n  }\n}, Je = {\n  parse() {\n    return this.createSingleNodeList(\n      this.Selector()\n    );\n  }\n}, ff = {\n  parse() {\n    return this.createSingleNodeList(\n      this.Identifier()\n    );\n  }\n}, pf = {\n  parse: hf\n}, ke = {\n  parse() {\n    return this.createSingleNodeList(\n      this.Nth()\n    );\n  }\n}, df = {\n  dir: ff,\n  has: Rt,\n  lang: pf,\n  matches: Rt,\n  is: Rt,\n  \"-moz-any\": Rt,\n  \"-webkit-any\": Rt,\n  where: Rt,\n  not: Rt,\n  \"nth-child\": ke,\n  \"nth-last-child\": ke,\n  \"nth-last-of-type\": ke,\n  \"nth-of-type\": ke,\n  slotted: Je,\n  host: Je,\n  \"host-context\": Je\n}, gf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AnPlusB: Xs,\n  Atrule: Zs,\n  AtrulePrelude: er,\n  AttributeSelector: rr,\n  Block: ar,\n  Brackets: cr,\n  CDC: hr,\n  CDO: pr,\n  ClassSelector: gr,\n  Combinator: kr,\n  Comment: yr,\n  Condition: xr,\n  Declaration: Tr,\n  DeclarationList: vr,\n  Dimension: $r,\n  Feature: Pr,\n  FeatureFunction: Rr,\n  FeatureRange: Ir,\n  Function: Dr,\n  GeneralEnclosed: Mr,\n  Hash: Br,\n  IdSelector: Vr,\n  Identifier: Ur,\n  Layer: Gr,\n  LayerList: Kr,\n  MediaQuery: Yr,\n  MediaQueryList: Jr,\n  NestingSelector: ti,\n  Nth: ni,\n  Number: ri,\n  Operator: oi,\n  Parentheses: li,\n  Percentage: ui,\n  PseudoClassSelector: fi,\n  PseudoElementSelector: di,\n  Ratio: mi,\n  Raw: Si,\n  Rule: bi,\n  Scope: Ci,\n  Selector: Ti,\n  SelectorList: vi,\n  String: Pi,\n  StyleSheet: Ri,\n  SupportsDeclaration: Ii,\n  TypeSelector: Di,\n  UnicodeRange: Bi,\n  Url: zi,\n  Value: Hi,\n  WhiteSpace: qi\n}, Symbol.toStringTag, { value: \"Module\" })), mf = {\n  parseContext: {\n    default: \"StyleSheet\",\n    stylesheet: \"StyleSheet\",\n    atrule: \"Atrule\",\n    atrulePrelude(t) {\n      return this.AtrulePrelude(t.atrule ? String(t.atrule) : null);\n    },\n    mediaQueryList: \"MediaQueryList\",\n    mediaQuery: \"MediaQuery\",\n    condition(t) {\n      return this.Condition(t.kind);\n    },\n    rule: \"Rule\",\n    selectorList: \"SelectorList\",\n    selector: \"Selector\",\n    block() {\n      return this.Block(!0);\n    },\n    declarationList: \"DeclarationList\",\n    declaration: \"Declaration\",\n    value: \"Value\"\n  },\n  features: {\n    supports: {\n      selector() {\n        return this.Selector();\n      }\n    },\n    container: {\n      style() {\n        return this.Declaration();\n      }\n    }\n  },\n  scope: Xh,\n  atrule: uf,\n  pseudo: df,\n  node: gf\n}, kf = Ph(mf);\nfunction Pe(t) {\n  const e = {};\n  for (const n of Object.keys(t)) {\n    let s = t[n];\n    s && (Array.isArray(s) || s instanceof K ? s = s.map(Pe) : s.constructor === Object && (s = Pe(s))), e[n] = s;\n  }\n  return e;\n}\nlet Sf = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\", lt = (t = 21) => {\n  let e = \"\", n = t | 0;\n  for (; n--; )\n    e += Sf[Math.random() * 64 | 0];\n  return e;\n};\nconst ro = lt(), re = /* @__PURE__ */ new Set();\nfunction Oe(t) {\n  return !!(t && t.type === \"Function\" && t.name === \"anchor\");\n}\nfunction Lt(t, e = !1) {\n  return kf(t, {\n    parseAtrulePrelude: !1,\n    parseCustomProperty: !0,\n    onParseError: (n) => {\n      e && re.add(n);\n    }\n  });\n}\nfunction Z(t) {\n  return wh(t, {\n    // Default `safe` adds extra (potentially breaking) spaces for compatibility\n    // with old browsers.\n    mode: \"spec\"\n  });\n}\nfunction yf(t) {\n  return t.type === \"Declaration\";\n}\nfunction bf(t) {\n  return t.toArray().reduce(\n    (e, n) => n.type === \"Operator\" && n.value === \",\" ? (e.push([]), e) : (n.type === \"Identifier\" && e[e.length - 1].push(n), e),\n    [[]]\n  );\n}\nfunction fn(t) {\n  return t ? t.children.map((e) => {\n    var r;\n    let n;\n    ((r = e.children.last) == null ? void 0 : r.type) === \"PseudoElementSelector\" && (e = Pe(e), n = Z(e.children.last), e.children.pop());\n    const s = Z(e);\n    return {\n      selector: s + (n != null ? n : \"\"),\n      elementPart: s,\n      pseudoElementPart: n\n    };\n  }).toArray() : [];\n}\nfunction xf() {\n  re.size > 0 && (console.group(\n    `The CSS anchor positioning polyfill was not applied due to ${re.size === 1 ? \"a CSS parse error\" : \"CSS parse errors\"}.`\n  ), re.forEach((t) => {\n    console.warn(t.formattedMessage);\n  }), console.groupEnd());\n}\nfunction Cf() {\n  re.clear();\n}\nconst pn = [\n  ...Xi,\n  \"anchor-scope\",\n  \"anchor-name\"\n].reduce(\n  (t, e) => (t[e] = `--${e}-${ro}`, t),\n  {}\n);\nfunction wf(t, e) {\n  return yf(t) && pn[t.property] && e ? (e.children.appendData(q(U({}, t), {\n    property: pn[t.property]\n  })), { updated: !0 }) : {};\n}\nfunction Tf(t) {\n  for (const e of t) {\n    let n = !1;\n    const s = Lt(e.css, !0);\n    $t(s, {\n      visit: \"Declaration\",\n      enter(r) {\n        var l;\n        const o = (l = this.rule) == null ? void 0 : l.block, { updated: a } = wf(r, o);\n        a && (n = !0);\n      }\n    }), n && (e.css = Z(s), e.changed = !0);\n  }\n  return t.some((e) => e.changed === !0);\n}\nvar io = /* @__PURE__ */ ((t) => (t.All = \"all\", t.None = \"none\", t))(io || {});\nfunction ot(t, e) {\n  var s;\n  return e = (s = pn[e]) != null ? s : e, (t instanceof HTMLElement ? getComputedStyle(t) : t.computedStyle).getPropertyValue(e).trim();\n}\nfunction Zt(t, e, n) {\n  return ot(t, e) === n;\n}\nfunction Af(t, { selector: e, pseudoElementPart: n }) {\n  const s = getComputedStyle(t, n), r = document.createElement(\"div\"), o = document.createElement(\"style\");\n  r.id = `fake-pseudo-element-${lt()}`;\n  for (const l of Array.from(s)) {\n    const u = s.getPropertyValue(l);\n    r.style.setProperty(l, u);\n  }\n  o.textContent += `#${r.id}${n} { content: ${s.content}; }`, o.textContent += `${e} { display: none !important; }`, document.head.append(o);\n  const a = n === \"::before\" ? \"afterbegin\" : \"beforeend\";\n  return t.insertAdjacentElement(a, r), { fakePseudoElement: r, sheet: o, computedStyle: s };\n}\nfunction vf(t) {\n  let e = t;\n  for (; e; ) {\n    if (Zt(e, \"overflow\", \"scroll\"))\n      return e;\n    e = e.parentElement;\n  }\n  return e;\n}\nfunction Ef(t) {\n  let e = vf(t);\n  return e === document.documentElement && (e = null), e != null ? e : { scrollTop: 0, scrollLeft: 0 };\n}\nfunction $f(t, e) {\n  const { elementPart: n, pseudoElementPart: s } = t, r = [];\n  if (s && !(s === \"::before\" || s === \"::after\")) return r;\n  const l = ie(e.roots, n);\n  if (!s)\n    return r.push(...l), r;\n  for (const u of l) {\n    const { fakePseudoElement: i, sheet: c, computedStyle: h } = Af(\n      u,\n      t\n    ), f = i.getBoundingClientRect(), { scrollY: p, scrollX: d } = globalThis, m = Ef(u);\n    r.push({\n      fakePseudoElement: i,\n      computedStyle: h,\n      removeFakePseudoElement() {\n        i.remove(), c.remove();\n      },\n      // For https://floating-ui.com/docs/autoupdate#ancestorscroll to work on\n      // `VirtualElement`s.\n      contextElement: u,\n      // https://floating-ui.com/docs/virtual-elements\n      getBoundingClientRect() {\n        const { scrollY: k, scrollX: y } = globalThis, { scrollTop: x, scrollLeft: A } = m;\n        return DOMRect.fromRect({\n          y: f.y + (p - k) + (m.scrollTop - x),\n          x: f.x + (d - y) + (m.scrollLeft - A),\n          width: f.width,\n          height: f.height\n        });\n      }\n    });\n  }\n  return r;\n}\nfunction Lf(t, e) {\n  const n = ot(t, \"anchor-name\");\n  return e ? n.split(\",\").map((s) => s.trim()).includes(e) : !n;\n}\nfunction Pf(t, e) {\n  const n = ot(t, \"anchor-scope\");\n  return n === e || n === \"all\";\n}\nconst vn = (t) => R(null, null, function* () {\n  var n, s, r;\n  let e = yield (n = V.getOffsetParent) == null ? void 0 : n.call(V, t);\n  return (yield (s = V.isElement) == null ? void 0 : s.call(V, e)) || (e = (yield (r = V.getDocumentElement) == null ? void 0 : r.call(V, t)) || window.document.documentElement), e;\n}), ie = (t, e) => t.flatMap(\n  (n) => [...n.querySelectorAll(e)]\n), gs = \"InvalidMimeType\";\nfunction Of(t) {\n  return !!((t.type === \"text/css\" || t.rel === \"stylesheet\") && t.href);\n}\nfunction Rf(t) {\n  const e = new URL(t.href, document.baseURI);\n  if (Of(t) && e.origin === location.origin)\n    return e;\n}\nfunction _f(t) {\n  return R(this, null, function* () {\n    return (yield Promise.all(\n      t.map((n) => R(null, null, function* () {\n        var s;\n        if (!n.url)\n          return n;\n        if ((s = n.el) != null && s.disabled)\n          return null;\n        try {\n          const r = yield fetch(n.url.toString()), o = r.headers.get(\"content-type\");\n          if (!(o != null && o.startsWith(\"text/css\"))) {\n            const l = new Error(\n              `Error loading ${n.url}: expected content-type \"text/css\", got \"${o}\".`\n            );\n            throw l.name = gs, l;\n          }\n          const a = yield r.text();\n          return q(U({}, n), { css: a });\n        } catch (r) {\n          if (r instanceof Error && r.name === gs)\n            return console.warn(r), null;\n          throw r;\n        }\n      }))\n    )).filter((n) => n !== null);\n  });\n}\nconst ms = '[style*=\"anchor\"]', ks = '[style*=\"position-area\"]';\nfunction If(t) {\n  const e = t ? t.filter(\n    (s) => s instanceof HTMLElement && (s.matches(ms) || s.matches(ks))\n  ) : Array.from(\n    document.querySelectorAll(\n      [\n        ms,\n        ks\n      ].join(\",\")\n    )\n  ), n = [];\n  return e.filter((s) => s instanceof HTMLElement).forEach((s) => {\n    const r = lt(12), o = \"data-has-inline-styles\";\n    s.setAttribute(o, r);\n    const a = s.getAttribute(\"style\"), l = `[${o}=\"${r}\"] { ${a} }`;\n    n.push({ el: s, css: l });\n  }), n;\n}\nfunction Nf(t) {\n  return R(this, null, function* () {\n    var o, a;\n    const e = (o = t.elements) != null ? o : ie(t.roots, \"link, style\"), n = [];\n    e.filter((l) => l instanceof HTMLElement).forEach((l) => {\n      if (l.tagName.toLowerCase() === \"link\") {\n        const u = Rf(l);\n        u && n.push({ el: l, url: u });\n      }\n      l.tagName.toLowerCase() === \"style\" && n.push({ el: l, css: l.innerHTML });\n    });\n    const s = t.excludeInlineStyles ? (a = t.elements) != null ? a : [] : void 0, r = If(s);\n    return yield _f([...n, ...r]);\n  });\n}\nconst Df = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet oo = (t = 21) => {\n  let e = \"\", n = crypto.getRandomValues(new Uint8Array(t |= 0));\n  for (; t--; )\n    e += Df[n[t] & 63];\n  return e;\n};\nconst ao = \"--pa-cascade-property\", lo = \"data-anchor-position-wrapper\", co = \"data-pa-wrapper-for-\", Ss = \"POLYFILL-POSITION-AREA\", Ff = [\n  \"left\",\n  \"center\",\n  \"right\",\n  \"span-left\",\n  \"span-right\",\n  \"x-start\",\n  \"x-end\",\n  \"span-x-start\",\n  \"span-x-end\",\n  \"x-self-start\",\n  \"x-self-end\",\n  \"span-x-self-start\",\n  \"span-x-self-end\",\n  \"span-all\",\n  \"top\",\n  \"bottom\",\n  \"span-top\",\n  \"span-bottom\",\n  \"y-start\",\n  \"y-end\",\n  \"span-y-start\",\n  \"span-y-end\",\n  \"y-self-start\",\n  \"y-self-end\",\n  \"span-y-self-start\",\n  \"span-y-self-end\",\n  \"block-start\",\n  \"block-end\",\n  \"span-block-start\",\n  \"span-block-end\",\n  \"inline-start\",\n  \"inline-end\",\n  \"span-inline-start\",\n  \"span-inline-end\",\n  \"self-block-start\",\n  \"self-block-end\",\n  \"span-self-block-start\",\n  \"span-self-block-end\",\n  \"self-inline-start\",\n  \"self-inline-end\",\n  \"span-self-inline-start\",\n  \"span-self-inline-end\",\n  \"start\",\n  \"end\",\n  \"span-start\",\n  \"span-end\",\n  \"self-start\",\n  \"self-end\",\n  \"span-self-start\",\n  \"span-self-end\"\n];\nfunction uo(t) {\n  return Ff.includes(t);\n}\nconst ys = {\n  left: [\n    0,\n    1,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  center: [\n    1,\n    2,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  right: [\n    2,\n    3,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"span-left\": [\n    0,\n    2,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"span-right\": [\n    1,\n    3,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"x-start\": [\n    0,\n    1,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"x-end\": [\n    2,\n    3,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"span-x-start\": [\n    0,\n    2,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"span-x-end\": [\n    1,\n    3,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"x-self-start\": [\n    0,\n    1,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"x-self-end\": [\n    2,\n    3,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"span-x-self-start\": [\n    0,\n    2,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"span-x-self-end\": [\n    1,\n    3,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"span-all\": [\n    0,\n    3,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  top: [\n    0,\n    1,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  bottom: [\n    2,\n    3,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"span-top\": [\n    0,\n    2,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"span-bottom\": [\n    1,\n    3,\n    \"Irrelevant\"\n    /* Irrelevant */\n  ],\n  \"y-start\": [\n    0,\n    1,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"y-end\": [\n    2,\n    3,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"span-y-start\": [\n    0,\n    2,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"span-y-end\": [\n    1,\n    3,\n    \"Physical\"\n    /* Physical */\n  ],\n  \"y-self-start\": [\n    0,\n    1,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"y-self-end\": [\n    2,\n    3,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"span-y-self-start\": [\n    0,\n    2,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"span-y-self-end\": [\n    1,\n    3,\n    \"PhysicalSelf\"\n    /* PhysicalSelf */\n  ],\n  \"block-start\": [\n    0,\n    1,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"block-end\": [\n    2,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-block-start\": [\n    0,\n    2,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-block-end\": [\n    1,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"inline-start\": [\n    0,\n    1,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"inline-end\": [\n    2,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-inline-start\": [\n    0,\n    2,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-inline-end\": [\n    1,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"self-block-start\": [\n    0,\n    1,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"self-block-end\": [\n    2,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-block-start\": [\n    0,\n    2,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-block-end\": [\n    1,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"self-inline-start\": [\n    0,\n    1,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"self-inline-end\": [\n    2,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-inline-start\": [\n    0,\n    2,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-inline-end\": [\n    1,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  start: [\n    0,\n    1,\n    \"Logical\"\n    /* Logical */\n  ],\n  end: [\n    2,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-start\": [\n    0,\n    2,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"span-end\": [\n    1,\n    3,\n    \"Logical\"\n    /* Logical */\n  ],\n  \"self-start\": [\n    0,\n    1,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"self-end\": [\n    2,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-start\": [\n    0,\n    2,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ],\n  \"span-self-end\": [\n    1,\n    3,\n    \"LogicalSelf\"\n    /* LogicalSelf */\n  ]\n}, Mf = [\n  \"left\",\n  \"center\",\n  \"right\",\n  \"span-left\",\n  \"span-right\",\n  \"x-start\",\n  \"x-end\",\n  \"span-x-start\",\n  \"span-x-end\",\n  \"x-self-start\",\n  \"x-self-end\",\n  \"span-x-self-start\",\n  \"span-x-self-end\",\n  \"span-all\"\n], jf = [\n  \"top\",\n  \"center\",\n  \"bottom\",\n  \"span-top\",\n  \"span-bottom\",\n  \"y-start\",\n  \"y-end\",\n  \"span-y-start\",\n  \"span-y-end\",\n  \"y-self-start\",\n  \"y-self-end\",\n  \"span-y-self-start\",\n  \"span-y-self-end\",\n  \"span-all\"\n], Bf = [\n  \"block-start\",\n  \"center\",\n  \"block-end\",\n  \"span-block-start\",\n  \"span-block-end\",\n  \"span-all\"\n], Wf = [\n  \"inline-start\",\n  \"center\",\n  \"inline-end\",\n  \"span-inline-start\",\n  \"span-inline-end\",\n  \"span-all\"\n], Uf = [\n  \"self-block-start\",\n  \"center\",\n  \"self-block-end\",\n  \"span-self-block-start\",\n  \"span-self-block-end\",\n  \"span-all\"\n], zf = [\n  \"self-inline-start\",\n  \"center\",\n  \"self-inline-end\",\n  \"span-self-inline-start\",\n  \"span-self-inline-end\",\n  \"span-all\"\n], bs = [\n  \"start\",\n  \"center\",\n  \"end\",\n  \"span-start\",\n  \"span-end\",\n  \"span-all\"\n], xs = [\n  \"self-start\",\n  \"center\",\n  \"self-end\",\n  \"span-self-start\",\n  \"span-self-end\",\n  \"span-all\"\n], Vf = [\"block\", \"top\", \"bottom\", \"y\"], Hf = [\"inline\", \"left\", \"right\", \"x\"];\nfunction dn(t) {\n  const e = t.split(\"-\");\n  for (const n of e) {\n    if (Vf.includes(n)) return \"block\";\n    if (Hf.includes(n)) return \"inline\";\n  }\n  return \"ambiguous\";\n}\nfunction Gf(t, e) {\n  return e[0].includes(t[0]) && e[1].includes(t[1]) || e[0].includes(t[1]) && e[1].includes(t[0]);\n}\nconst qf = [\n  [Mf, jf],\n  [Bf, Wf],\n  [Uf, zf],\n  [bs, bs],\n  [xs, xs]\n];\nfunction Kf(t) {\n  for (const e of qf)\n    if (Gf(t, e)) return !0;\n  return !1;\n}\nconst Cs = (t) => {\n  const e = getComputedStyle(t);\n  return {\n    writingMode: e.writingMode,\n    direction: e.direction\n  };\n}, Qf = (t, e) => R(null, null, function* () {\n  const n = yield vn(t);\n  switch (e) {\n    case \"Logical\":\n    case \"Physical\":\n      return Cs(n);\n    case \"LogicalSelf\":\n    case \"PhysicalSelf\":\n      return Cs(t);\n    default:\n      return null;\n  }\n}), Ze = (t) => t.reverse().map((e) => 3 - e), ho = (t, e) => t === \"Irrelevant\" ? e : t, Yf = (s, r) => R(null, [s, r], function* ({\n  block: t,\n  inline: e\n}, n) {\n  const o = ho(t[2], e[2]), a = yield Qf(n, o), l = {\n    block: [t[0], t[1]],\n    inline: [e[0], e[1]]\n  };\n  if (a) {\n    if (a.direction === \"rtl\" && (l.inline = Ze(l.inline)), a.writingMode.startsWith(\"vertical\")) {\n      const u = l.block;\n      l.block = l.inline, l.inline = u;\n    }\n    if (a.writingMode.startsWith(\"sideways\")) {\n      const u = l.block;\n      l.block = l.inline, l.inline = u, a.writingMode.endsWith(\"lr\") && (l.block = Ze(l.block));\n    }\n    a.writingMode.endsWith(\"rl\") && (l.inline = Ze(l.inline));\n  }\n  return l;\n}), Xf = ({\n  block: t,\n  inline: e\n}) => {\n  const n = [0, \"top\", \"bottom\", 0], s = [0, \"left\", \"right\", 0];\n  return {\n    block: [n[t[0]], n[t[1]]],\n    inline: [s[e[0]], s[e[1]]]\n  };\n};\nfunction ws([t, e]) {\n  return t === 0 && e === 3 ? \"center\" : t === 0 ? \"end\" : e === 3 ? \"start\" : \"center\";\n}\nfunction Jf(t) {\n  return t.type === \"Declaration\" && t.property === \"position-area\";\n}\nfunction Zf(t) {\n  const e = t.value.children.toArray().map(({ name: n }) => n);\n  return e.length === 1 && (dn(e[0]) === \"ambiguous\" ? e.push(e[0]) : e.push(\"span-all\")), e;\n}\nfunction tp(t) {\n  if (!Jf(t)) return;\n  const e = Zf(t);\n  if (!Kf(e)) return;\n  const n = {};\n  switch (dn(e[0])) {\n    case \"block\":\n      n.block = e[0], n.inline = e[1];\n      break;\n    case \"inline\":\n      n.inline = e[0], n.block = e[1];\n      break;\n    case \"ambiguous\":\n      dn(e[1]) == \"block\" ? (n.block = e[1], n.inline = e[0]) : (n.inline = e[1], n.block = e[0]);\n      break;\n  }\n  const s = {\n    block: ys[n.block],\n    inline: ys[n.inline]\n  }, r = `--pa-declaration-${oo(12)}`;\n  return {\n    values: n,\n    grid: s,\n    selectorUUID: r\n  };\n}\nfunction ep(t, e) {\n  [\n    // Insets are applied to a wrapping element\n    \"justify-self\",\n    \"align-self\"\n  ].forEach((n) => {\n    e.children.appendData({\n      type: \"Declaration\",\n      property: n,\n      value: { type: \"Raw\", value: `var(--pa-value-${n})` },\n      important: !1\n    });\n  }), e.children.appendData({\n    type: \"Declaration\",\n    property: ao,\n    value: { type: \"Raw\", value: t.selectorUUID },\n    important: !1\n  });\n}\nfunction np(t, e) {\n  var s, r;\n  let n;\n  if (((s = t.parentElement) == null ? void 0 : s.tagName) === Ss)\n    n = t.parentElement;\n  else {\n    n = document.createElement(Ss), n.style.display = \"grid\", n.style.position = \"absolute\";\n    const o = getComputedStyle(t).pointerEvents;\n    n.style.pointerEvents = \"none\", t.style.pointerEvents = o, [\"top\", \"left\", \"right\", \"bottom\"].forEach((a) => {\n      n.style.setProperty(a, `var(--pa-value-${a})`);\n    }), (r = t.parentElement) == null || r.insertBefore(n, t), n.appendChild(t);\n  }\n  return n.setAttribute(\n    `${co}${e}`,\n    \"\"\n  ), n;\n}\nfunction sp(t, e, n) {\n  return R(this, null, function* () {\n    const s = `--pa-target-${oo(12)}`, r = yield Yf(\n      e.grid,\n      t\n    ), o = Xf(r), a = ho(\n      e.grid.block[2],\n      e.grid.inline[2]\n    ), l = [\n      \"LogicalSelf\",\n      \"PhysicalSelf\"\n      /* PhysicalSelf */\n    ].includes(a) ? r : e.grid, u = {\n      block: ws([l.block[0], l.block[1]]),\n      inline: ws([\n        l.inline[0],\n        l.inline[1]\n      ])\n    };\n    return {\n      insets: o,\n      alignments: u,\n      targetUUID: s,\n      targetEl: t,\n      anchorEl: n,\n      wrapperEl: np(t, s),\n      values: e.values,\n      grid: e.grid,\n      selectorUUID: e.selectorUUID\n    };\n  });\n}\nfunction rp(t, e) {\n  return `\n    [${lo}=\"${e}\"][${co}${t}] {\n      --pa-value-top: var(${t}-top);\n      --pa-value-left: var(${t}-left);\n      --pa-value-right: var(${t}-right);\n      --pa-value-bottom: var(${t}-bottom);\n      --pa-value-justify-self: var(${t}-justify-self);\n      --pa-value-align-self: var(${t}-align-self);\n    }\n  `.replaceAll(`\n`, \"\");\n}\nconst ip = [\n  \"normal\",\n  \"most-width\",\n  \"most-height\",\n  \"most-block-size\",\n  \"most-inline-size\"\n], op = [\n  \"flip-block\",\n  \"flip-inline\",\n  \"flip-start\"\n];\nfunction ap(t) {\n  return t.type === \"Declaration\";\n}\nfunction lp(t) {\n  return t.type === \"Declaration\" && t.property === \"position-try-fallbacks\";\n}\nfunction cp(t) {\n  return t.type === \"Declaration\" && t.property === \"position-try-order\";\n}\nfunction up(t) {\n  return t.type === \"Declaration\" && t.property === \"position-try\";\n}\nfunction hp(t) {\n  return t.type === \"Atrule\" && t.name === \"position-try\";\n}\nfunction fp(t) {\n  return op.includes(t);\n}\nfunction pp(t) {\n  return ip.includes(t);\n}\nfunction dp(t, e) {\n  const n = document.querySelector(t);\n  if (n) {\n    let s = mp(n);\n    return e.forEach((r) => {\n      s = fo(s, r);\n    }), s;\n  }\n}\nfunction gp(t, e) {\n  let n = t.declarations;\n  return e.forEach((s) => {\n    n = fo(n, s);\n  }), n;\n}\nfunction mp(t) {\n  const e = {};\n  return Xi.forEach((n) => {\n    const s = ot(t, `--${n}-${ro}`);\n    s && (e[n] = s);\n  }), e;\n}\nconst kp = {\n  \"flip-block\": {\n    top: \"bottom\",\n    bottom: \"top\",\n    \"inset-block-start\": \"inset-block-end\",\n    \"inset-block-end\": \"inset-block-start\",\n    \"margin-top\": \"margin-bottom\",\n    \"margin-bottom\": \"margin-top\"\n  },\n  \"flip-inline\": {\n    left: \"right\",\n    right: \"left\",\n    \"inset-inline-start\": \"inset-inline-end\",\n    \"inset-inline-end\": \"inset-inline-start\",\n    \"margin-left\": \"margin-right\",\n    \"margin-right\": \"margin-left\"\n  },\n  \"flip-start\": {\n    left: \"top\",\n    right: \"bottom\",\n    top: \"left\",\n    bottom: \"right\",\n    \"inset-block-start\": \"inset-block-end\",\n    \"inset-block-end\": \"inset-block-start\",\n    \"inset-inline-start\": \"inset-inline-end\",\n    \"inset-inline-end\": \"inset-inline-start\",\n    \"inset-block\": \"inset-inline\",\n    \"inset-inline\": \"inset-block\"\n  }\n}, Sp = {\n  \"flip-block\": {\n    top: \"bottom\",\n    bottom: \"top\",\n    start: \"end\",\n    end: \"start\",\n    \"self-end\": \"self-start\",\n    \"self-start\": \"self-end\"\n  },\n  \"flip-inline\": {\n    left: \"right\",\n    right: \"left\",\n    start: \"end\",\n    end: \"start\",\n    \"self-end\": \"self-start\",\n    \"self-start\": \"self-end\"\n  },\n  \"flip-start\": {\n    top: \"left\",\n    left: \"top\",\n    right: \"bottom\",\n    bottom: \"right\"\n  }\n}, yp = {\n  \"flip-block\": {\n    top: \"bottom\",\n    bottom: \"top\",\n    start: \"end\",\n    end: \"start\"\n  },\n  \"flip-inline\": {\n    left: \"right\",\n    right: \"left\",\n    start: \"end\",\n    end: \"start\"\n  },\n  \"flip-start\": {\n    // TODO: Requires fuller logic\n  }\n};\nfunction bp(t, e) {\n  return kp[e][t] || t;\n}\nfunction xp(t, e) {\n  return Sp[e][t] || t;\n}\nfunction Cp(t, e) {\n  if (e === \"flip-start\")\n    return t;\n  {\n    const n = yp[e];\n    return t.split(\"-\").map((s) => n[s] || s).join(\"-\");\n  }\n}\nfunction wp(t, e, n) {\n  if (t === \"margin\") {\n    const [s, r, o, a] = e.children.toArray();\n    n === \"flip-block\" ? a ? e.children.fromArray([o, r, s, a]) : o && e.children.fromArray([o, r, s]) : n === \"flip-inline\" && a && e.children.fromArray([s, a, o, r]);\n  } else if (t === \"margin-block\") {\n    const [s, r] = e.children.toArray();\n    n === \"flip-block\" && r && e.children.fromArray([r, s]);\n  } else if (t === \"margin-inline\") {\n    const [s, r] = e.children.toArray();\n    n === \"flip-inline\" && r && e.children.fromArray([r, s]);\n  }\n}\nconst Tp = (t, e) => {\n  var r;\n  return ((r = Lt(`#id{${t}: ${e};}`).children.first) == null ? void 0 : r.block.children.first).value;\n};\nfunction fo(t, e) {\n  const n = {};\n  return Object.entries(t).forEach(([s, r]) => {\n    var u;\n    const o = s, a = Tp(o, r), l = bp(o, e);\n    l !== o && ((u = n[o]) != null || (n[o] = \"revert\")), $t(a, {\n      visit: \"Function\",\n      enter(i) {\n        Oe(i) && i.children.forEach((c) => {\n          oe(c) && Zi(c.name) && (c.name = xp(c.name, e));\n        });\n      }\n    }), o === \"position-area\" && a.children.forEach((i) => {\n      oe(i) && uo(i.name) && (i.name = Cp(i.name, e));\n    }), o.startsWith(\"margin\") && wp(o, a, e), n[l] = Z(a);\n  }), n;\n}\nfunction po(t) {\n  const e = bf(t), n = [];\n  return e.forEach((s) => {\n    const r = {\n      atRules: [],\n      tactics: [],\n      positionAreas: []\n    };\n    s.forEach((o) => {\n      fp(o.name) ? r.tactics.push(o.name) : o.name.startsWith(\"--\") ? r.atRules.push(o.name) : uo(o.name) && r.positionAreas.push(o.name);\n    }), r.positionAreas.length ? n.push({\n      positionArea: r.positionAreas[0],\n      type: \"position-area\"\n    }) : r.atRules.length && r.tactics.length ? n.push({\n      tactics: r.tactics,\n      atRule: r.atRules[0],\n      type: \"at-rule-with-try-tactic\"\n    }) : r.atRules.length ? n.push({\n      atRule: r.atRules[0],\n      type: \"at-rule\"\n    }) : r.tactics.length && n.push({\n      tactics: r.tactics,\n      type: \"try-tactic\"\n    });\n  }), n;\n}\nfunction Ap(t) {\n  return lp(t) && t.value.children.first ? po(t.value.children) : [];\n}\nfunction vp(t) {\n  if (up(t) && t.value.children.first) {\n    const e = Pe(t);\n    let n;\n    const s = e.value.children.first.name;\n    s && pp(s) && (n = s, e.value.children.shift());\n    const r = po(e.value.children);\n    return { order: n, options: r };\n  }\n  return {};\n}\nfunction Ep(t) {\n  return cp(t) && t.value.children.first ? {\n    order: t.value.children.first.name\n  } : {};\n}\nfunction $p(t) {\n  const { order: e, options: n } = vp(t);\n  if (e || n)\n    return { order: e, options: n };\n  const { order: s } = Ep(t), r = Ap(t);\n  return s || r ? { order: s, options: r } : {};\n}\nfunction Lp(t) {\n  return ue(t.property) || oh(t.property) || Qi(t.property) || ah(t.property) || [\"position-anchor\", \"position-area\"].includes(t.property);\n}\nfunction Pp(t) {\n  var e, n;\n  if (hp(t) && ((e = t.prelude) != null && e.value) && ((n = t.block) != null && n.children)) {\n    const s = t.prelude.value, r = t.block.children.filter(\n      (a) => ap(a) && Lp(a)\n    ), o = {\n      uuid: `${s}-try-${lt(12)}`,\n      declarations: Object.fromEntries(\n        r.map((a) => [a.property, Z(a.value)])\n      )\n    };\n    return { name: s, tryBlock: o };\n  }\n  return {};\n}\nfunction Op(t) {\n  const e = {}, n = {}, s = {};\n  for (const r of t) {\n    const o = Lt(r.css);\n    $t(o, {\n      visit: \"Atrule\",\n      enter(a) {\n        const { name: l, tryBlock: u } = Pp(a);\n        l && u && (e[l] = u);\n      }\n    });\n  }\n  for (const r of t) {\n    let o = !1;\n    const a = /* @__PURE__ */ new Set(), l = Lt(r.css);\n    $t(l, {\n      visit: \"Declaration\",\n      enter(u) {\n        var d;\n        const i = (d = this.rule) == null ? void 0 : d.prelude, c = fn(i);\n        if (!c.length) return;\n        const { order: h, options: f } = $p(u), p = {};\n        h && (p.order = h), c.forEach(({ selector: m }) => {\n          var k, y;\n          f == null || f.forEach((x) => {\n            var M, et, w;\n            let A;\n            if (x.type === \"at-rule\")\n              A = x.atRule;\n            else if (x.type === \"try-tactic\") {\n              A = `${m}-${x.tactics.join(\"-\")}`;\n              const C = dp(\n                m,\n                x.tactics\n              );\n              C && (e[A] = {\n                uuid: `${m}-${x.tactics.join(\"-\")}-try-${lt(12)}`,\n                declarations: C\n              });\n            } else if (x.type === \"at-rule-with-try-tactic\") {\n              A = `${m}-${x.atRule}-${x.tactics.join(\"-\")}`;\n              const C = e[x.atRule], O = gp(\n                C,\n                x.tactics\n              );\n              O && (e[A] = {\n                uuid: `${m}-${x.atRule}-${x.tactics.join(\"-\")}-try-${lt(12)}`,\n                declarations: O\n              });\n            }\n            if (A && e[A]) {\n              const C = `[data-anchor-polyfill=\"${e[A].uuid}\"]`;\n              (M = n[C]) != null || (n[C] = []), n[C].push(m), a.has(A) || ((et = p.fallbacks) != null || (p.fallbacks = []), p.fallbacks.push(e[A]), a.add(A), (w = this.stylesheet) == null || w.children.prependData({\n                type: \"Rule\",\n                prelude: {\n                  type: \"Raw\",\n                  value: C\n                },\n                block: {\n                  type: \"Block\",\n                  children: new K().fromArray(\n                    Object.entries(e[A].declarations).map(\n                      ([O, P]) => ({\n                        type: \"Declaration\",\n                        important: !0,\n                        property: O,\n                        value: {\n                          type: \"Raw\",\n                          value: P\n                        }\n                      })\n                    )\n                  )\n                }\n              }), o = !0);\n            }\n          }), Object.keys(p).length > 0 && (s[m] ? (p.order && (s[m].order = p.order), p.fallbacks && ((y = (k = s[m]).fallbacks) != null || (k.fallbacks = []), s[m].fallbacks.push(\n            ...p.fallbacks\n          ))) : s[m] = p);\n        });\n      }\n    }), o && (r.css = Z(l), r.changed = !0);\n  }\n  return { fallbackTargets: n, validPositions: s };\n}\nfunction Rp(t, e) {\n  return !t || t === e ? !1 : go(t) ? t.document.contains(e) : t.contains(e);\n}\nfunction go(t) {\n  return !!(t && t === t.window);\n}\nfunction _p(t) {\n  return Zt(t, \"position\", \"fixed\");\n}\nfunction gn(t) {\n  return !!(t && (_p(t) || Zt(t, \"position\", \"absolute\")));\n}\nfunction Ts(t, e) {\n  return t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING;\n}\nfunction Ip(t) {\n  return R(this, null, function* () {\n    return yield V.getOffsetParent(t);\n  });\n}\nfunction tn(t) {\n  return R(this, null, function* () {\n    if (![\"absolute\", \"fixed\"].includes(ot(t, \"position\")))\n      return yield Ip(t);\n    let e = t.parentElement;\n    for (; e; ) {\n      if (!Zt(e, \"position\", \"static\") && Zt(e, \"display\", \"block\"))\n        return e;\n      e = e.parentElement;\n    }\n    return window;\n  });\n}\nfunction Np(t, e, n, s) {\n  return R(this, null, function* () {\n    const r = yield tn(t), o = yield tn(n);\n    if (!(Rp(o, t) || go(o)) || r === o && !(!gn(t) || Ts(t, n)))\n      return !1;\n    if (r !== o) {\n      let a;\n      const l = [];\n      for (a = r; a && a !== o && a !== window; )\n        l.push(a), a = yield tn(a);\n      const u = l[l.length - 1];\n      if (u instanceof HTMLElement && !(!gn(u) || Ts(u, n)))\n        return !1;\n    }\n    {\n      let a = t.parentElement;\n      for (; a; ) {\n        if (Zt(a, \"content-visibility\", \"hidden\"))\n          return !1;\n        a = a.parentElement;\n      }\n    }\n    return !(e && s && As(t, e, s) !== As(n, e, s));\n  });\n}\nfunction As(t, e, n) {\n  for (; !(t.matches(n) && Pf(t, e)); ) {\n    if (!t.parentElement)\n      return null;\n    t = t.parentElement;\n  }\n  return t;\n}\nfunction Dp(t, e, n, s, r) {\n  return R(this, null, function* () {\n    if (!(t instanceof HTMLElement && n.length && gn(t)))\n      return null;\n    const o = n.flatMap((l) => $f(l, r)).filter((l) => Lf(l, e)), a = s.map((l) => l.selector).join(\",\") || null;\n    for (let l = o.length - 1; l >= 0; l--) {\n      const u = o[l], i = \"fakePseudoElement\" in u;\n      if (yield Np(\n        i ? u.fakePseudoElement : u,\n        e,\n        t,\n        a\n      ))\n        return i && u.removeFakePseudoElement(), u;\n    }\n    return null;\n  });\n}\nfunction Fp(t) {\n  return t.type === \"Declaration\" && t.property === \"anchor-name\";\n}\nfunction Mp(t) {\n  return t.type === \"Declaration\" && t.property === \"anchor-scope\";\n}\nfunction mn(t) {\n  return !!(t && t.type === \"Function\" && t.name === \"anchor-size\");\n}\nfunction we(t) {\n  return !!(t && t.type === \"Function\" && t.name === \"var\");\n}\nfunction oe(t) {\n  return !!(t.type === \"Identifier\" && t.name);\n}\nfunction jp(t) {\n  return !!(t.type === \"Percentage\" && t.value);\n}\nfunction vs(t, e) {\n  let n, s, r, o = \"\", a = !1, l;\n  const u = [];\n  t.children.toArray().forEach((f) => {\n    if (a) {\n      o = `${o}${Z(f)}`;\n      return;\n    }\n    if (f.type === \"Operator\" && f.value === \",\") {\n      a = !0;\n      return;\n    }\n    u.push(f);\n  });\n  let [i, c] = u;\n  if (c || (c = i, i = void 0), i && (oe(i) && i.name.startsWith(\"--\") ? n = i.name : we(i) && i.children.first && (l = i.children.first.name)), c)\n    if (Oe(t)) {\n      if (oe(c) && Zi(c.name))\n        s = c.name;\n      else if (jp(c)) {\n        const f = Number(c.value);\n        s = Number.isNaN(f) ? void 0 : f;\n      }\n    } else mn(t) && oe(c) && hh(c.name) && (r = c.name);\n  const h = `--anchor-${lt(12)}`;\n  return Object.assign(t, {\n    type: \"Raw\",\n    value: `var(${h})`,\n    children: null\n  }), Reflect.deleteProperty(t, \"name\"), {\n    anchorName: n,\n    anchorSide: s,\n    anchorSize: r,\n    fallbackValue: o || \"0px\",\n    customPropName: l,\n    uuid: h\n  };\n}\nfunction Es(t) {\n  return t.value.children.map(({ name: e }) => e);\n}\nlet Ht = {}, Et = {}, Nt = {}, ae = {}, It = {};\nfunction Bp() {\n  Ht = {}, Et = {}, Nt = {}, ae = {}, It = {};\n}\nfunction Wp(t, e) {\n  var n;\n  if ((Oe(t) || mn(t)) && e) {\n    if (e.property.startsWith(\"--\")) {\n      const s = Z(e.value), r = vs(t);\n      return ae[r.uuid] = s, Nt[e.property] = [\n        ...(n = Nt[e.property]) != null ? n : [],\n        r\n      ], { changed: !0 };\n    }\n    if (Oe(t) && ue(e.property) || mn(t) && Ji(e.property)) {\n      const s = vs(t);\n      return { prop: e.property, data: s, changed: !0 };\n    }\n  }\n  return {};\n}\nfunction $s(t, e, n) {\n  return R(this, null, function* () {\n    let s = e == null ? void 0 : e.anchorName;\n    const r = e == null ? void 0 : e.customPropName;\n    if (t && !s) {\n      const u = ot(\n        t,\n        \"position-anchor\"\n      );\n      u ? s = u : r && (s = ot(t, r));\n    }\n    const o = s ? Ht[s] || [] : [], a = s ? Et[io.All] || [] : [], l = s ? Et[s] || [] : [];\n    return yield Dp(\n      t,\n      s || null,\n      o,\n      [...a, ...l],\n      { roots: n.roots }\n    );\n  });\n}\nfunction Up(t, e) {\n  return R(this, null, function* () {\n    var h, f, p, d, m, k, y, x, A, M, et;\n    const n = {}, s = {};\n    Bp();\n    const { fallbackTargets: r, validPositions: o } = Op(t);\n    for (const w of t) {\n      let C = !1;\n      const O = Lt(w.css);\n      $t(O, function(P) {\n        var J, xt, Ot, Ct, pt, wt;\n        const N = (J = this.rule) == null ? void 0 : J.prelude, $ = fn(N);\n        if (Fp(P) && $.length)\n          for (const B of Es(P))\n            (xt = Ht[B]) != null || (Ht[B] = []), Ht[B].push(...$);\n        if (Mp(P) && $.length)\n          for (const B of Es(P))\n            (Ot = Et[B]) != null || (Et[B] = []), Et[B].push(...$);\n        const {\n          prop: v,\n          data: j,\n          changed: D\n        } = Wp(P, this.declaration);\n        if (v && j && $.length)\n          for (const { selector: B } of $)\n            n[B] = q(U({}, n[B]), {\n              [v]: [...(pt = (Ct = n[B]) == null ? void 0 : Ct[v]) != null ? pt : [], j]\n            });\n        let H;\n        if (this.block && (H = tp(P), H)) {\n          ep(\n            H,\n            this.block\n          );\n          for (const { selector: B } of $)\n            s[B] = [\n              ...(wt = s[B]) != null ? wt : [],\n              H\n            ];\n        }\n        (D || H) && (C = !0);\n      }), C && (w.css = Z(O), w.changed = !0);\n    }\n    const a = new Set(Object.keys(Nt)), l = {}, u = (w) => {\n      var P, N, $, v, j;\n      const C = [], O = new Set((N = (P = l[w]) == null ? void 0 : P.names) != null ? N : []);\n      for (; O.size > 0; )\n        for (const D of O)\n          C.push(...($ = Nt[D]) != null ? $ : []), O.delete(D), (j = (v = l[D]) == null ? void 0 : v.names) != null && j.length && l[D].names.forEach((H) => O.add(H));\n      return C;\n    };\n    for (; a.size > 0; ) {\n      const w = [];\n      for (const C of t) {\n        let O = !1;\n        const P = Lt(C.css);\n        $t(P, {\n          visit: \"Function\",\n          enter(N) {\n            var D, H;\n            const $ = (D = this.rule) == null ? void 0 : D.prelude, v = this.declaration, j = v == null ? void 0 : v.property;\n            if (($ == null ? void 0 : $.children.isEmpty) === !1 && we(N) && v && j && N.children.first && a.has(N.children.first.name) && // For now, we only want assignments to other CSS custom properties\n            j.startsWith(\"--\")) {\n              const J = N.children.first, xt = (H = Nt[J.name]) != null ? H : [], Ot = u(J.name);\n              if (!(xt.length || Ot.length))\n                return;\n              const Ct = `${J.name}-anchor-${lt(12)}`, pt = Z(v.value);\n              ae[Ct] = pt, l[j] || (l[j] = { names: [], uuids: [] });\n              const wt = l[j];\n              wt.names.includes(J.name) || wt.names.push(J.name), wt.uuids.push(Ct), w.push(j), J.name = Ct, O = !0;\n            }\n          }\n        }), O && (C.css = Z(P), C.changed = !0);\n      }\n      a.clear(), w.forEach((C) => a.add(C));\n    }\n    for (const w of t) {\n      let C = !1;\n      const O = Lt(w.css);\n      $t(O, {\n        visit: \"Function\",\n        enter(P) {\n          var j, D, H, J, xt, Ot, Ct;\n          const N = (j = this.rule) == null ? void 0 : j.prelude, $ = this.declaration, v = $ == null ? void 0 : $.property;\n          if ((N == null ? void 0 : N.children.isEmpty) === !1 && we(P) && $ && v && P.children.first && // Now we only want assignments to inset/sizing properties\n          (ue(v) || Qi(v))) {\n            const pt = P.children.first, wt = (D = Nt[pt.name]) != null ? D : [], B = u(pt.name);\n            if (!(wt.length || B.length))\n              return;\n            const fe = `${v}-${lt(12)}`;\n            if (B.length) {\n              const jt = /* @__PURE__ */ new Set([pt.name]);\n              for (; jt.size > 0; )\n                for (const Bt of jt) {\n                  const G = l[Bt];\n                  if ((H = G == null ? void 0 : G.names) != null && H.length && ((J = G == null ? void 0 : G.uuids) != null && J.length))\n                    for (const Wt of G.names)\n                      for (const Ut of G.uuids)\n                        It[Ut] = q(U({}, It[Ut]), {\n                          // - `key` (`propUuid`) is the property-specific\n                          //   uuid to append to the new custom property name\n                          // - `value` is the new property-specific custom\n                          //   property value to use\n                          [fe]: `${Wt}-${fe}`\n                        });\n                  jt.delete(Bt), (xt = G == null ? void 0 : G.names) != null && xt.length && G.names.forEach((Wt) => jt.add(Wt));\n                }\n            }\n            const mo = fn(N);\n            for (const jt of [...wt, ...B]) {\n              const Bt = U({}, jt), G = `--anchor-${lt(12)}-${v}`, Wt = Bt.uuid;\n              Bt.uuid = G;\n              for (const { selector: Ut } of mo)\n                n[Ut] = q(U({}, n[Ut]), {\n                  [v]: [...(Ct = (Ot = n[Ut]) == null ? void 0 : Ot[v]) != null ? Ct : [], Bt]\n                });\n              It[Wt] = q(U({}, It[Wt]), {\n                // - `key` (`propUuid`) is the property-specific\n                //   uuid to append to the new custom property name\n                // - `value` is the new property-specific custom\n                //   property value to use\n                [fe]: G\n              });\n            }\n            pt.name = `${pt.name}-${fe}`, C = !0;\n          }\n        }\n      }), C && (w.css = Z(O), w.changed = !0);\n    }\n    if (Object.keys(It).length > 0)\n      for (const w of t) {\n        let C = !1;\n        const O = Lt(w.css);\n        $t(O, {\n          visit: \"Function\",\n          enter(P) {\n            var N, $, v, j;\n            if (we(P) && (($ = (N = P.children.first) == null ? void 0 : N.name) != null && $.startsWith(\"--\")) && ((j = (v = this.declaration) == null ? void 0 : v.property) != null && j.startsWith(\"--\")) && this.block) {\n              const D = P.children.first, H = It[D.name];\n              if (H)\n                for (const [J, xt] of Object.entries(H))\n                  this.block.children.appendData({\n                    type: \"Declaration\",\n                    important: !1,\n                    property: `${this.declaration.property}-${J}`,\n                    value: {\n                      type: \"Raw\",\n                      value: Z(this.declaration.value).replace(\n                        `var(${D.name})`,\n                        `var(${xt})`\n                      )\n                    }\n                  }), C = !0;\n              ae[D.name] && (this.declaration.value = {\n                type: \"Raw\",\n                value: ae[D.name]\n              }, C = !0);\n            }\n          }\n        }), C && (w.css = Z(O), w.changed = !0);\n      }\n    const i = /* @__PURE__ */ new Map();\n    for (const [w, C] of Object.entries(n)) {\n      let O;\n      w.startsWith(\"[data-anchor-polyfill=\") && ((h = r[w]) != null && h.length) ? O = ie(\n        e.roots,\n        r[w].join(\",\")\n      ) : O = ie(e.roots, w);\n      for (const [P, N] of Object.entries(C))\n        for (const $ of N)\n          for (const v of O) {\n            const j = yield $s(v, $, {\n              roots: e.roots\n            }), D = `--anchor-${lt(12)}`;\n            i.set(v, q(U({}, (f = i.get(v)) != null ? f : {}), {\n              [$.uuid]: D\n            })), v.setAttribute(\n              \"style\",\n              `${$.uuid}: var(${D}); ${(p = v.getAttribute(\"style\")) != null ? p : \"\"}`\n            ), o[w] = q(U({}, o[w]), {\n              declarations: q(U({}, (d = o[w]) == null ? void 0 : d.declarations), {\n                [P]: [\n                  ...(y = (k = (m = o[w]) == null ? void 0 : m.declarations) == null ? void 0 : k[P]) != null ? y : [],\n                  q(U({}, $), { anchorEl: j, targetEl: v, uuid: D })\n                ]\n              })\n            });\n          }\n    }\n    const c = {\n      el: document.createElement(\"link\"),\n      changed: !1,\n      created: !0,\n      css: \"\"\n    };\n    t.push(c);\n    for (const [w, C] of Object.entries(s)) {\n      const O = ie(e.roots, w);\n      for (const P of O) {\n        const N = yield $s(P, null, {\n          roots: e.roots\n        });\n        for (const $ of C) {\n          const v = yield sp(\n            P,\n            $,\n            N\n          );\n          c.css += rp(\n            v.targetUUID,\n            $.selectorUUID\n          ), c.changed = !0, o[w] = q(U({}, o[w]), {\n            declarations: q(U({}, (x = o[w]) == null ? void 0 : x.declarations), {\n              \"position-area\": [\n                ...(et = (M = (A = o[w]) == null ? void 0 : A.declarations) == null ? void 0 : M[\"position-area\"]) != null ? et : [],\n                v\n              ]\n            })\n          });\n        }\n      }\n    }\n    return { rules: o, inlineStyles: i, anchorScopes: Et };\n  });\n}\nconst zp = [\n  \"as\",\n  \"blocking\",\n  \"crossorigin\",\n  // 'disabled' is not relevant for style elements, but this exclusion is\n  // theoretical, as a <link rel=stylesheet disabled> will not be loaded, and\n  // will not reach this part of the polyfill. See #246.\n  \"disabled\",\n  \"fetchpriority\",\n  \"href\",\n  \"hreflang\",\n  \"integrity\",\n  \"referrerpolicy\",\n  \"rel\",\n  \"type\"\n];\nfunction Ls(t, e, n = !1) {\n  const s = [];\n  for (const { el: r, css: o, changed: a, created: l = !1 } of t) {\n    const u = { el: r, css: o, changed: !1 };\n    if (a) {\n      if (r.tagName.toLowerCase() === \"style\")\n        r.innerHTML = o;\n      else if (r instanceof HTMLLinkElement) {\n        const i = document.createElement(\"style\");\n        i.textContent = o;\n        for (const c of r.getAttributeNames())\n          if (!c.startsWith(\"on\") && !zp.includes(c)) {\n            const h = r.getAttribute(c);\n            h !== null && i.setAttribute(c, h);\n          }\n        r.hasAttribute(\"href\") && i.setAttribute(\"data-original-href\", r.getAttribute(\"href\")), l ? (i.setAttribute(\"data-generated-by-polyfill\", \"true\"), document.head.insertAdjacentElement(\"beforeend\", i)) : (r.insertAdjacentElement(\"beforebegin\", i), r.remove()), u.el = i;\n      } else if (r.hasAttribute(\"data-has-inline-styles\")) {\n        const i = r.getAttribute(\"data-has-inline-styles\");\n        if (i) {\n          const c = `[data-has-inline-styles=\"${i}\"]{`;\n          let f = o.slice(c.length, 0 - \"}\".length);\n          const p = e == null ? void 0 : e.get(r);\n          if (p)\n            for (const [d, m] of Object.entries(p))\n              f = `${d}: var(${m}); ${f}`;\n          r.setAttribute(\"style\", f);\n        }\n      }\n    }\n    n && r.hasAttribute(\"data-has-inline-styles\") && r.removeAttribute(\"data-has-inline-styles\"), s.push(u);\n  }\n  return s;\n}\nconst Vp = q(U({}, V), { _c: /* @__PURE__ */ new Map() }), Hp = (t, e) => {\n  let n;\n  switch (t) {\n    case \"start\":\n    case \"self-start\":\n      n = 0;\n      break;\n    case \"end\":\n    case \"self-end\":\n      n = 100;\n      break;\n    default:\n      typeof t == \"number\" && !Number.isNaN(t) && (n = t);\n  }\n  if (n !== void 0)\n    return e ? 100 - n : n;\n}, Gp = (t, e) => {\n  let n;\n  switch (t) {\n    case \"block\":\n    case \"self-block\":\n      n = e ? \"width\" : \"height\";\n      break;\n    case \"inline\":\n    case \"self-inline\":\n      n = e ? \"height\" : \"width\";\n      break;\n  }\n  return n;\n}, Ps = (t) => {\n  switch (t) {\n    case \"top\":\n    case \"bottom\":\n      return \"y\";\n    case \"left\":\n    case \"right\":\n      return \"x\";\n  }\n  return null;\n}, qp = (t) => {\n  switch (t) {\n    case \"x\":\n      return \"width\";\n    case \"y\":\n      return \"height\";\n  }\n  return null;\n}, Os = (t) => ot(t, \"display\") === \"inline\", Rs = (t, e) => (e === \"x\" ? [\"border-left-width\", \"border-right-width\"] : [\"border-top-width\", \"border-bottom-width\"]).reduce(\n  (s, r) => s + parseInt(ot(t, r), 10),\n  0\n) || 0, Se = (t, e) => parseInt(ot(t, `margin-${e}`), 10) || 0, Kp = (t) => ({\n  top: Se(t, \"top\"),\n  right: Se(t, \"right\"),\n  bottom: Se(t, \"bottom\"),\n  left: Se(t, \"left\")\n}), en = (a) => R(null, [a], function* ({\n  targetEl: t,\n  targetProperty: e,\n  anchorRect: n,\n  anchorSide: s,\n  anchorSize: r,\n  fallback: o = null\n}) {\n  var l;\n  if (!((r || s !== void 0) && t && n))\n    return o;\n  if (r) {\n    if (!Ji(e))\n      return o;\n    let u;\n    switch (r) {\n      case \"width\":\n      case \"height\":\n        u = r;\n        break;\n      default: {\n        let i = !1;\n        const c = ot(t, \"writing-mode\");\n        i = c.startsWith(\"vertical-\") || c.startsWith(\"sideways-\"), u = Gp(r, i);\n      }\n    }\n    return u ? `${n[u]}px` : o;\n  }\n  if (s !== void 0) {\n    let u, i;\n    const c = Ps(e);\n    if (!(ue(e) && c && (!ue(s) || c === Ps(s))))\n      return o;\n    const h = [\"top\", \"left\"];\n    switch (s) {\n      case \"left\":\n      case \"top\":\n        u = 0;\n        break;\n      case \"right\":\n      case \"bottom\":\n        u = 100;\n        break;\n      case \"center\":\n        u = 50;\n        break;\n      case \"inside\":\n        u = h.includes(e) ? 0 : 100;\n        break;\n      case \"outside\":\n        u = h.includes(e) ? 100 : 0;\n        break;\n      default:\n        if (t) {\n          const d = (yield (l = V.isRTL) == null ? void 0 : l.call(V, t)) || !1;\n          u = Hp(s, d);\n        }\n    }\n    const f = typeof u == \"number\" && !Number.isNaN(u), p = qp(c);\n    if (f && p) {\n      (e === \"bottom\" || e === \"right\") && (i = yield vn(t));\n      let d = n[c] + n[p] * (u / 100);\n      switch (e) {\n        case \"bottom\": {\n          if (!i)\n            break;\n          let m = i.clientHeight;\n          if (m === 0 && Os(i)) {\n            const k = Rs(i, c);\n            m = i.offsetHeight - k;\n          }\n          d = m - d;\n          break;\n        }\n        case \"right\": {\n          if (!i)\n            break;\n          let m = i.clientWidth;\n          if (m === 0 && Os(i)) {\n            const k = Rs(i, c);\n            m = i.offsetWidth - k;\n          }\n          d = m - d;\n          break;\n        }\n      }\n      return `${d}px`;\n    }\n  }\n  return o;\n}), Qp = (t) => \"wrapperEl\" in t, Yp = (t) => \"uuid\" in t;\nfunction Xp(t, e = !1) {\n  return R(this, null, function* () {\n    const n = document.documentElement;\n    for (const [s, r] of Object.entries(t))\n      for (const o of r) {\n        const a = o.anchorEl, l = o.targetEl;\n        if (a && l)\n          if (Qp(o)) {\n            const u = o.wrapperEl, i = (c, h, f) => R(null, null, function* () {\n              return c === 0 ? \"0px\" : yield en({\n                targetEl: u,\n                targetProperty: h,\n                anchorRect: f,\n                anchorSide: c\n              });\n            });\n            rn(\n              a,\n              u,\n              () => R(null, null, function* () {\n                const c = ot(\n                  l,\n                  ao\n                );\n                u.setAttribute(lo, c);\n                const h = yield V.getElementRects({\n                  reference: a,\n                  floating: u,\n                  strategy: \"absolute\"\n                }), f = o.insets, p = yield i(\n                  f.block[0],\n                  \"top\",\n                  h.reference\n                ), d = yield i(\n                  f.block[1],\n                  \"bottom\",\n                  h.reference\n                ), m = yield i(\n                  f.inline[0],\n                  \"left\",\n                  h.reference\n                ), k = yield i(\n                  f.inline[1],\n                  \"right\",\n                  h.reference\n                );\n                n.style.setProperty(\n                  `${o.targetUUID}-top`,\n                  p || null\n                ), n.style.setProperty(\n                  `${o.targetUUID}-left`,\n                  m || null\n                ), n.style.setProperty(\n                  `${o.targetUUID}-right`,\n                  k || null\n                ), n.style.setProperty(\n                  `${o.targetUUID}-bottom`,\n                  d || null\n                ), n.style.setProperty(\n                  `${o.targetUUID}-justify-self`,\n                  o.alignments.inline\n                ), n.style.setProperty(\n                  `${o.targetUUID}-align-self`,\n                  o.alignments.block\n                );\n              }),\n              { animationFrame: e }\n            );\n          } else\n            rn(\n              a,\n              l,\n              () => R(null, null, function* () {\n                const u = yield V.getElementRects({\n                  reference: a,\n                  floating: l,\n                  strategy: \"absolute\"\n                }), i = yield en({\n                  targetEl: l,\n                  targetProperty: s,\n                  anchorRect: u.reference,\n                  anchorSide: o.anchorSide,\n                  anchorSize: o.anchorSize,\n                  fallback: o.fallbackValue\n                });\n                n.style.setProperty(o.uuid, i);\n              }),\n              { animationFrame: e }\n            );\n        else if (Yp(o)) {\n          const u = yield en({\n            targetProperty: s,\n            anchorSide: o.anchorSide,\n            anchorSize: o.anchorSize,\n            fallback: o.fallbackValue\n          });\n          n.style.setProperty(o.uuid, u);\n        }\n      }\n  });\n}\nfunction _s(t, e) {\n  return R(this, null, function* () {\n    const n = yield V.getElementRects({\n      reference: t,\n      floating: t,\n      strategy: \"absolute\"\n    });\n    return yield Yo(\n      {\n        x: t.offsetLeft,\n        y: t.offsetTop,\n        platform: Vp,\n        rects: n,\n        elements: {\n          floating: t,\n          reference: e\n        },\n        strategy: \"absolute\"\n      },\n      {\n        padding: Kp(t)\n      }\n    );\n  });\n}\nfunction Jp(t, e, n = !1) {\n  return R(this, null, function* () {\n    if (!e.length)\n      return;\n    const s = document.querySelectorAll(t);\n    for (const r of s) {\n      let o = !1;\n      const a = yield vn(r);\n      rn(\n        // We're just checking whether the target element overflows, so we don't\n        // care about the position of the anchor element in this case. Passing in\n        // an empty object instead of a reference element avoids unnecessarily\n        // watching for irrelevant changes.\n        {},\n        r,\n        () => R(null, null, function* () {\n          if (o)\n            return;\n          o = !0, r.removeAttribute(\"data-anchor-polyfill\");\n          const l = yield _s(r, a);\n          if (Object.values(l).every((u) => u <= 0)) {\n            r.removeAttribute(\"data-anchor-polyfill-last-successful\"), o = !1;\n            return;\n          }\n          for (const [u, { uuid: i }] of e.entries()) {\n            r.setAttribute(\"data-anchor-polyfill\", i);\n            const c = yield _s(r, a);\n            if (Object.values(c).every((h) => h <= 0)) {\n              r.setAttribute(\"data-anchor-polyfill-last-successful\", i), o = !1;\n              break;\n            }\n            if (u === e.length - 1) {\n              const h = r.getAttribute(\n                \"data-anchor-polyfill-last-successful\"\n              );\n              h ? r.setAttribute(\"data-anchor-polyfill\", h) : r.removeAttribute(\"data-anchor-polyfill\"), o = !1;\n              break;\n            }\n          }\n        }),\n        { animationFrame: n, layoutShift: !1 }\n      );\n    }\n  });\n}\nfunction Zp(t, e = !1) {\n  return R(this, null, function* () {\n    var n, s;\n    for (const r of Object.values(t))\n      yield Xp((n = r.declarations) != null ? n : {}, e);\n    for (const [r, o] of Object.entries(t))\n      yield Jp(\n        r,\n        (s = o.fallbacks) != null ? s : [],\n        e\n      );\n  });\n}\nfunction td(t = {}) {\n  const e = typeof t == \"boolean\" ? { useAnimationFrame: t } : t, n = e.useAnimationFrame === void 0 ? !!window.UPDATE_ANCHOR_ON_ANIMATION_FRAME : e.useAnimationFrame;\n  return Array.isArray(e.elements) || (e.elements = void 0), (!Array.isArray(e.roots) || e.roots.length === 0) && (e.roots = [document]), Object.assign(e, {\n    useAnimationFrame: n\n  });\n}\nfunction nd(t) {\n  return R(this, null, function* () {\n    const e = td(\n      t != null ? t : window.ANCHOR_POSITIONING_POLYFILL_OPTIONS\n    );\n    let n = yield Nf(e), s = {}, r;\n    Cf();\n    try {\n      Tf(n) && (n = Ls(n));\n      const a = yield Up(n, { roots: e.roots });\n      s = a.rules, r = a.inlineStyles;\n    } catch (o) {\n      throw xf(), o;\n    }\n    return Object.values(s).length && (Ls(n, r, !0), yield Zp(s, e.useAnimationFrame)), s;\n  });\n}\n\n//# sourceMappingURL=css-anchor-positioning-fn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kZGJpcmQvY3NzLWFuY2hvci1wb3NpdGlvbmluZy9kaXN0L2Nzcy1hbmNob3ItcG9zaXRpb25pbmctZm4uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsbUJBQW1CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXLDZDQUE2QztBQUN4RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaURBQWlEO0FBQ2pELEdBQUcsb0JBQW9CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUVBQXFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBaUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEIsc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvQG9kZGJpcmQvY3NzLWFuY2hvci1wb3NpdGlvbmluZy9kaXN0L2Nzcy1hbmNob3ItcG9zaXRpb25pbmctZm4uanM/OTZkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIga28gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIFNvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgeW8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBFbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgYm8gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCB4byA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgJG4gPSAodCwgZSwgbikgPT4gZSBpbiB0ID8ga28odCwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogbiB9KSA6IHRbZV0gPSBuLCBVID0gKHQsIGUpID0+IHtcbiAgZm9yICh2YXIgbiBpbiBlIHx8IChlID0ge30pKVxuICAgIGJvLmNhbGwoZSwgbikgJiYgJG4odCwgbiwgZVtuXSk7XG4gIGlmIChFbilcbiAgICBmb3IgKHZhciBuIG9mIEVuKGUpKVxuICAgICAgeG8uY2FsbChlLCBuKSAmJiAkbih0LCBuLCBlW25dKTtcbiAgcmV0dXJuIHQ7XG59LCBxID0gKHQsIGUpID0+IFNvKHQsIHlvKGUpKTtcbnZhciBSID0gKHQsIGUsIG4pID0+IG5ldyBQcm9taXNlKChzLCByKSA9PiB7XG4gIHZhciBvID0gKHUpID0+IHtcbiAgICB0cnkge1xuICAgICAgbChuLm5leHQodSkpO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIHIoaSk7XG4gICAgfVxuICB9LCBhID0gKHUpID0+IHtcbiAgICB0cnkge1xuICAgICAgbChuLnRocm93KHUpKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICByKGkpO1xuICAgIH1cbiAgfSwgbCA9ICh1KSA9PiB1LmRvbmUgPyBzKHUudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHUudmFsdWUpLnRoZW4obywgYSk7XG4gIGwoKG4gPSBuLmFwcGx5KHQsIGUpKS5uZXh0KCkpO1xufSk7XG5jb25zdCBubiA9IE1hdGgubWluLCBHdCA9IE1hdGgubWF4LCBUZSA9IE1hdGgucm91bmQsIHBlID0gTWF0aC5mbG9vciwgU3QgPSAodCkgPT4gKHtcbiAgeDogdCxcbiAgeTogdFxufSk7XG5mdW5jdGlvbiBDbyh0LCBlKSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KGUpIDogdDtcbn1cbmZ1bmN0aW9uIHdvKHQpIHtcbiAgcmV0dXJuIFUoe1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9LCB0KTtcbn1cbmZ1bmN0aW9uIFRvKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgPyB3byh0KSA6IHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHQsXG4gICAgYm90dG9tOiB0LFxuICAgIGxlZnQ6IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIEFlKHQpIHtcbiAgY29uc3Qge1xuICAgIHg6IGUsXG4gICAgeTogbixcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IHJcbiAgfSA9IHQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHMsXG4gICAgaGVpZ2h0OiByLFxuICAgIHRvcDogbixcbiAgICBsZWZ0OiBlLFxuICAgIHJpZ2h0OiBlICsgcyxcbiAgICBib3R0b206IG4gKyByLFxuICAgIHg6IGUsXG4gICAgeTogblxuICB9O1xufVxuZnVuY3Rpb24gQW8odCwgZSkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHZhciBuO1xuICAgIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgICBjb25zdCB7XG4gICAgICB4OiBzLFxuICAgICAgeTogcixcbiAgICAgIHBsYXRmb3JtOiBvLFxuICAgICAgcmVjdHM6IGEsXG4gICAgICBlbGVtZW50czogbCxcbiAgICAgIHN0cmF0ZWd5OiB1XG4gICAgfSA9IHQsIHtcbiAgICAgIGJvdW5kYXJ5OiBpID0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiLFxuICAgICAgcm9vdEJvdW5kYXJ5OiBjID0gXCJ2aWV3cG9ydFwiLFxuICAgICAgZWxlbWVudENvbnRleHQ6IGggPSBcImZsb2F0aW5nXCIsXG4gICAgICBhbHRCb3VuZGFyeTogZiA9ICExLFxuICAgICAgcGFkZGluZzogcCA9IDBcbiAgICB9ID0gQ28oZSwgdCksIGQgPSBUbyhwKSwgayA9IGxbZiA/IGggPT09IFwiZmxvYXRpbmdcIiA/IFwicmVmZXJlbmNlXCIgOiBcImZsb2F0aW5nXCIgOiBoXSwgeSA9IEFlKHlpZWxkIG8uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICAgIGVsZW1lbnQ6IChuID0geWllbGQgby5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaXNFbGVtZW50KGspKSA9PSBudWxsIHx8IG4gPyBrIDogay5jb250ZXh0RWxlbWVudCB8fCAoeWllbGQgby5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0RG9jdW1lbnRFbGVtZW50KGwuZmxvYXRpbmcpKSxcbiAgICAgIGJvdW5kYXJ5OiBpLFxuICAgICAgcm9vdEJvdW5kYXJ5OiBjLFxuICAgICAgc3RyYXRlZ3k6IHVcbiAgICB9KSksIHggPSBoID09PSBcImZsb2F0aW5nXCIgPyB7XG4gICAgICB4OiBzLFxuICAgICAgeTogcixcbiAgICAgIHdpZHRoOiBhLmZsb2F0aW5nLndpZHRoLFxuICAgICAgaGVpZ2h0OiBhLmZsb2F0aW5nLmhlaWdodFxuICAgIH0gOiBhLnJlZmVyZW5jZSwgQSA9IHlpZWxkIG8uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBvLmdldE9mZnNldFBhcmVudChsLmZsb2F0aW5nKSwgTSA9ICh5aWVsZCBvLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogby5pc0VsZW1lbnQoQSkpID8gKHlpZWxkIG8uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0U2NhbGUoQSkpIHx8IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfSA6IHtcbiAgICAgIHg6IDEsXG4gICAgICB5OiAxXG4gICAgfSwgZXQgPSBBZShvLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8geWllbGQgby5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgICBlbGVtZW50czogbCxcbiAgICAgIHJlY3Q6IHgsXG4gICAgICBvZmZzZXRQYXJlbnQ6IEEsXG4gICAgICBzdHJhdGVneTogdVxuICAgIH0pIDogeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogKHkudG9wIC0gZXQudG9wICsgZC50b3ApIC8gTS55LFxuICAgICAgYm90dG9tOiAoZXQuYm90dG9tIC0geS5ib3R0b20gKyBkLmJvdHRvbSkgLyBNLnksXG4gICAgICBsZWZ0OiAoeS5sZWZ0IC0gZXQubGVmdCArIGQubGVmdCkgLyBNLngsXG4gICAgICByaWdodDogKGV0LnJpZ2h0IC0geS5yaWdodCArIGQucmlnaHQpIC8gTS54XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBSZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIHRlKHQpIHtcbiAgcmV0dXJuIElzKHQpID8gKHQubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IFwiI2RvY3VtZW50XCI7XG59XG5mdW5jdGlvbiBpdCh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gKHQgPT0gbnVsbCB8fCAoZSA9IHQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGJ0KHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiAoZSA9IChJcyh0KSA/IHQub3duZXJEb2N1bWVudCA6IHQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gSXModCkge1xuICByZXR1cm4gUmUoKSA/IHQgaW5zdGFuY2VvZiBOb2RlIHx8IHQgaW5zdGFuY2VvZiBpdCh0KS5Ob2RlIDogITE7XG59XG5mdW5jdGlvbiBjdCh0KSB7XG4gIHJldHVybiBSZSgpID8gdCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdCBpbnN0YW5jZW9mIGl0KHQpLkVsZW1lbnQgOiAhMTtcbn1cbmZ1bmN0aW9uIHl0KHQpIHtcbiAgcmV0dXJuIFJlKCkgPyB0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdCBpbnN0YW5jZW9mIGl0KHQpLkhUTUxFbGVtZW50IDogITE7XG59XG5mdW5jdGlvbiBMbih0KSB7XG4gIHJldHVybiAhUmUoKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA9PSBcInVuZGVmaW5lZFwiID8gITEgOiB0IGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCB0IGluc3RhbmNlb2YgaXQodCkuU2hhZG93Um9vdDtcbn1cbmNvbnN0IHZvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5saW5lXCIsIFwiY29udGVudHNcIl0pO1xuZnVuY3Rpb24gaGUodCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3c6IGUsXG4gICAgb3ZlcmZsb3dYOiBuLFxuICAgIG92ZXJmbG93WTogcyxcbiAgICBkaXNwbGF5OiByXG4gIH0gPSB1dCh0KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KGUgKyBzICsgbikgJiYgIXZvLmhhcyhyKTtcbn1cbmNvbnN0IEVvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdKTtcbmZ1bmN0aW9uICRvKHQpIHtcbiAgcmV0dXJuIEVvLmhhcyh0ZSh0KSk7XG59XG5jb25zdCBMbyA9IFtcIjpwb3BvdmVyLW9wZW5cIiwgXCI6bW9kYWxcIl07XG5mdW5jdGlvbiBfZSh0KSB7XG4gIHJldHVybiBMby5zb21lKChlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0Lm1hdGNoZXMoZSk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBQbyA9IFtcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZVwiLCBcInNjYWxlXCIsIFwicm90YXRlXCIsIFwicGVyc3BlY3RpdmVcIl0sIE9vID0gW1widHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJwZXJzcGVjdGl2ZVwiLCBcImZpbHRlclwiXSwgUm8gPSBbXCJwYWludFwiLCBcImxheW91dFwiLCBcInN0cmljdFwiLCBcImNvbnRlbnRcIl07XG5mdW5jdGlvbiBrbih0KSB7XG4gIGNvbnN0IGUgPSBTbigpLCBuID0gY3QodCkgPyB1dCh0KSA6IHQ7XG4gIHJldHVybiBQby5zb21lKChzKSA9PiBuW3NdID8gbltzXSAhPT0gXCJub25lXCIgOiAhMSkgfHwgKG4uY29udGFpbmVyVHlwZSA/IG4uY29udGFpbmVyVHlwZSAhPT0gXCJub3JtYWxcIiA6ICExKSB8fCAhZSAmJiAobi5iYWNrZHJvcEZpbHRlciA/IG4uYmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiIDogITEpIHx8ICFlICYmIChuLmZpbHRlciA/IG4uZmlsdGVyICE9PSBcIm5vbmVcIiA6ICExKSB8fCBPby5zb21lKChzKSA9PiAobi53aWxsQ2hhbmdlIHx8IFwiXCIpLmluY2x1ZGVzKHMpKSB8fCBSby5zb21lKChzKSA9PiAobi5jb250YWluIHx8IFwiXCIpLmluY2x1ZGVzKHMpKTtcbn1cbmZ1bmN0aW9uIF9vKHQpIHtcbiAgbGV0IGUgPSBQdCh0KTtcbiAgZm9yICg7IHl0KGUpICYmICFRdChlKTsgKSB7XG4gICAgaWYgKGtuKGUpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKF9lKGUpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZSA9IFB0KGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gU24oKSB7XG4gIHJldHVybiB0eXBlb2YgQ1NTID09IFwidW5kZWZpbmVkXCIgfHwgIUNTUy5zdXBwb3J0cyA/ICExIDogQ1NTLnN1cHBvcnRzKFwiLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXJcIiwgXCJub25lXCIpO1xufVxuY29uc3QgSW8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXSk7XG5mdW5jdGlvbiBRdCh0KSB7XG4gIHJldHVybiBJby5oYXModGUodCkpO1xufVxuZnVuY3Rpb24gdXQodCkge1xuICByZXR1cm4gaXQodCkuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbn1cbmZ1bmN0aW9uIEllKHQpIHtcbiAgcmV0dXJuIGN0KHQpID8ge1xuICAgIHNjcm9sbExlZnQ6IHQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHQuc2Nyb2xsVG9wXG4gIH0gOiB7XG4gICAgc2Nyb2xsTGVmdDogdC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogdC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBQdCh0KSB7XG4gIGlmICh0ZSh0KSA9PT0gXCJodG1sXCIpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IGUgPSAoXG4gICAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gICAgdC5hc3NpZ25lZFNsb3QgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gICAgdC5wYXJlbnROb2RlIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gICAgTG4odCkgJiYgdC5ob3N0IHx8IC8vIEZhbGxiYWNrLlxuICAgIGJ0KHQpXG4gICk7XG4gIHJldHVybiBMbihlKSA/IGUuaG9zdCA6IGU7XG59XG5mdW5jdGlvbiBOcyh0KSB7XG4gIGNvbnN0IGUgPSBQdCh0KTtcbiAgcmV0dXJuIFF0KGUpID8gdC5vd25lckRvY3VtZW50ID8gdC5vd25lckRvY3VtZW50LmJvZHkgOiB0LmJvZHkgOiB5dChlKSAmJiBoZShlKSA/IGUgOiBOcyhlKTtcbn1cbmZ1bmN0aW9uIGxlKHQsIGUsIG4pIHtcbiAgdmFyIHM7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IFtdKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITApO1xuICBjb25zdCByID0gTnModCksIG8gPSByID09PSAoKHMgPSB0Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBzLmJvZHkpLCBhID0gaXQocik7XG4gIGlmIChvKSB7XG4gICAgY29uc3QgbCA9IHNuKGEpO1xuICAgIHJldHVybiBlLmNvbmNhdChhLCBhLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBoZShyKSA/IHIgOiBbXSwgbCAmJiBuID8gbGUobCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGUuY29uY2F0KHIsIGxlKHIsIFtdLCBuKSk7XG59XG5mdW5jdGlvbiBzbih0KSB7XG4gIHJldHVybiB0LnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodC5wYXJlbnQpID8gdC5mcmFtZUVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gRHModCkge1xuICBjb25zdCBlID0gdXQodCk7XG4gIGxldCBuID0gcGFyc2VGbG9hdChlLndpZHRoKSB8fCAwLCBzID0gcGFyc2VGbG9hdChlLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgciA9IHl0KHQpLCBvID0gciA/IHQub2Zmc2V0V2lkdGggOiBuLCBhID0gciA/IHQub2Zmc2V0SGVpZ2h0IDogcywgbCA9IFRlKG4pICE9PSBvIHx8IFRlKHMpICE9PSBhO1xuICByZXR1cm4gbCAmJiAobiA9IG8sIHMgPSBhKSwge1xuICAgIHdpZHRoOiBuLFxuICAgIGhlaWdodDogcyxcbiAgICAkOiBsXG4gIH07XG59XG5mdW5jdGlvbiB5bih0KSB7XG4gIHJldHVybiBjdCh0KSA/IHQgOiB0LmNvbnRleHRFbGVtZW50O1xufVxuZnVuY3Rpb24gcXQodCkge1xuICBjb25zdCBlID0geW4odCk7XG4gIGlmICgheXQoZSkpXG4gICAgcmV0dXJuIFN0KDEpO1xuICBjb25zdCBuID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwge1xuICAgIHdpZHRoOiBzLFxuICAgIGhlaWdodDogcixcbiAgICAkOiBvXG4gIH0gPSBEcyhlKTtcbiAgbGV0IGEgPSAobyA/IFRlKG4ud2lkdGgpIDogbi53aWR0aCkgLyBzLCBsID0gKG8gPyBUZShuLmhlaWdodCkgOiBuLmhlaWdodCkgLyByO1xuICByZXR1cm4gKCFhIHx8ICFOdW1iZXIuaXNGaW5pdGUoYSkpICYmIChhID0gMSksICghbCB8fCAhTnVtYmVyLmlzRmluaXRlKGwpKSAmJiAobCA9IDEpLCB7XG4gICAgeDogYSxcbiAgICB5OiBsXG4gIH07XG59XG5jb25zdCBObyA9IC8qIEBfX1BVUkVfXyAqLyBTdCgwKTtcbmZ1bmN0aW9uIEZzKHQpIHtcbiAgY29uc3QgZSA9IGl0KHQpO1xuICByZXR1cm4gIVNuKCkgfHwgIWUudmlzdWFsVmlld3BvcnQgPyBObyA6IHtcbiAgICB4OiBlLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogZS52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIERvKHQsIGUsIG4pIHtcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKSwgIW4gfHwgZSAmJiBuICE9PSBpdCh0KSA/ICExIDogZTtcbn1cbmZ1bmN0aW9uIER0KHQsIGUsIG4sIHMpIHtcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIGNvbnN0IHIgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0geW4odCk7XG4gIGxldCBhID0gU3QoMSk7XG4gIGUgJiYgKHMgPyBjdChzKSAmJiAoYSA9IHF0KHMpKSA6IGEgPSBxdCh0KSk7XG4gIGNvbnN0IGwgPSBEbyhvLCBuLCBzKSA/IEZzKG8pIDogU3QoMCk7XG4gIGxldCB1ID0gKHIubGVmdCArIGwueCkgLyBhLngsIGkgPSAoci50b3AgKyBsLnkpIC8gYS55LCBjID0gci53aWR0aCAvIGEueCwgaCA9IHIuaGVpZ2h0IC8gYS55O1xuICBpZiAobykge1xuICAgIGNvbnN0IGYgPSBpdChvKSwgcCA9IHMgJiYgY3QocykgPyBpdChzKSA6IHM7XG4gICAgbGV0IGQgPSBmLCBtID0gc24oZCk7XG4gICAgZm9yICg7IG0gJiYgcyAmJiBwICE9PSBkOyApIHtcbiAgICAgIGNvbnN0IGsgPSBxdChtKSwgeSA9IG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSB1dChtKSwgQSA9IHkubGVmdCArIChtLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KHgucGFkZGluZ0xlZnQpKSAqIGsueCwgTSA9IHkudG9wICsgKG0uY2xpZW50VG9wICsgcGFyc2VGbG9hdCh4LnBhZGRpbmdUb3ApKSAqIGsueTtcbiAgICAgIHUgKj0gay54LCBpICo9IGsueSwgYyAqPSBrLngsIGggKj0gay55LCB1ICs9IEEsIGkgKz0gTSwgZCA9IGl0KG0pLCBtID0gc24oZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBZSh7XG4gICAgd2lkdGg6IGMsXG4gICAgaGVpZ2h0OiBoLFxuICAgIHg6IHUsXG4gICAgeTogaVxuICB9KTtcbn1cbmZ1bmN0aW9uIE5lKHQsIGUpIHtcbiAgY29uc3QgbiA9IEllKHQpLnNjcm9sbExlZnQ7XG4gIHJldHVybiBlID8gZS5sZWZ0ICsgbiA6IER0KGJ0KHQpKS5sZWZ0ICsgbjtcbn1cbmZ1bmN0aW9uIE1zKHQsIGUpIHtcbiAgY29uc3QgbiA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHMgPSBuLmxlZnQgKyBlLnNjcm9sbExlZnQgLSBOZSh0LCBuKSwgciA9IG4udG9wICsgZS5zY3JvbGxUb3A7XG4gIHJldHVybiB7XG4gICAgeDogcyxcbiAgICB5OiByXG4gIH07XG59XG5mdW5jdGlvbiBGbyh0KSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHM6IGUsXG4gICAgcmVjdDogbixcbiAgICBvZmZzZXRQYXJlbnQ6IHMsXG4gICAgc3RyYXRlZ3k6IHJcbiAgfSA9IHQ7XG4gIGNvbnN0IG8gPSByID09PSBcImZpeGVkXCIsIGEgPSBidChzKSwgbCA9IGUgPyBfZShlLmZsb2F0aW5nKSA6ICExO1xuICBpZiAocyA9PT0gYSB8fCBsICYmIG8pXG4gICAgcmV0dXJuIG47XG4gIGxldCB1ID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIGkgPSBTdCgxKTtcbiAgY29uc3QgYyA9IFN0KDApLCBoID0geXQocyk7XG4gIGlmICgoaCB8fCAhaCAmJiAhbykgJiYgKCh0ZShzKSAhPT0gXCJib2R5XCIgfHwgaGUoYSkpICYmICh1ID0gSWUocykpLCB5dChzKSkpIHtcbiAgICBjb25zdCBwID0gRHQocyk7XG4gICAgaSA9IHF0KHMpLCBjLnggPSBwLnggKyBzLmNsaWVudExlZnQsIGMueSA9IHAueSArIHMuY2xpZW50VG9wO1xuICB9XG4gIGNvbnN0IGYgPSBhICYmICFoICYmICFvID8gTXMoYSwgdSkgOiBTdCgwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbi53aWR0aCAqIGkueCxcbiAgICBoZWlnaHQ6IG4uaGVpZ2h0ICogaS55LFxuICAgIHg6IG4ueCAqIGkueCAtIHUuc2Nyb2xsTGVmdCAqIGkueCArIGMueCArIGYueCxcbiAgICB5OiBuLnkgKiBpLnkgLSB1LnNjcm9sbFRvcCAqIGkueSArIGMueSArIGYueVxuICB9O1xufVxuZnVuY3Rpb24gTW8odCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0LmdldENsaWVudFJlY3RzKCkpO1xufVxuZnVuY3Rpb24gam8odCkge1xuICBjb25zdCBlID0gYnQodCksIG4gPSBJZSh0KSwgcyA9IHQub3duZXJEb2N1bWVudC5ib2R5LCByID0gR3QoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgcy5zY3JvbGxXaWR0aCwgcy5jbGllbnRXaWR0aCksIG8gPSBHdChlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIHMuc2Nyb2xsSGVpZ2h0LCBzLmNsaWVudEhlaWdodCk7XG4gIGxldCBhID0gLW4uc2Nyb2xsTGVmdCArIE5lKHQpO1xuICBjb25zdCBsID0gLW4uc2Nyb2xsVG9wO1xuICByZXR1cm4gdXQocykuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChhICs9IEd0KGUuY2xpZW50V2lkdGgsIHMuY2xpZW50V2lkdGgpIC0gciksIHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IG8sXG4gICAgeDogYSxcbiAgICB5OiBsXG4gIH07XG59XG5jb25zdCBQbiA9IDI1O1xuZnVuY3Rpb24gQm8odCwgZSkge1xuICBjb25zdCBuID0gaXQodCksIHMgPSBidCh0KSwgciA9IG4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCBvID0gcy5jbGllbnRXaWR0aCwgYSA9IHMuY2xpZW50SGVpZ2h0LCBsID0gMCwgdSA9IDA7XG4gIGlmIChyKSB7XG4gICAgbyA9IHIud2lkdGgsIGEgPSByLmhlaWdodDtcbiAgICBjb25zdCBjID0gU24oKTtcbiAgICAoIWMgfHwgYyAmJiBlID09PSBcImZpeGVkXCIpICYmIChsID0gci5vZmZzZXRMZWZ0LCB1ID0gci5vZmZzZXRUb3ApO1xuICB9XG4gIGNvbnN0IGkgPSBOZShzKTtcbiAgaWYgKGkgPD0gMCkge1xuICAgIGNvbnN0IGMgPSBzLm93bmVyRG9jdW1lbnQsIGggPSBjLmJvZHksIGYgPSBnZXRDb21wdXRlZFN0eWxlKGgpLCBwID0gYy5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIiAmJiBwYXJzZUZsb2F0KGYubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KGYubWFyZ2luUmlnaHQpIHx8IDAsIGQgPSBNYXRoLmFicyhzLmNsaWVudFdpZHRoIC0gaC5jbGllbnRXaWR0aCAtIHApO1xuICAgIGQgPD0gUG4gJiYgKG8gLT0gZCk7XG4gIH0gZWxzZSBpIDw9IFBuICYmIChvICs9IGkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogYSxcbiAgICB4OiBsLFxuICAgIHk6IHVcbiAgfTtcbn1cbmNvbnN0IFdvID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXSk7XG5mdW5jdGlvbiBVbyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBEdCh0LCAhMCwgZSA9PT0gXCJmaXhlZFwiKSwgcyA9IG4udG9wICsgdC5jbGllbnRUb3AsIHIgPSBuLmxlZnQgKyB0LmNsaWVudExlZnQsIG8gPSB5dCh0KSA/IHF0KHQpIDogU3QoMSksIGEgPSB0LmNsaWVudFdpZHRoICogby54LCBsID0gdC5jbGllbnRIZWlnaHQgKiBvLnksIHUgPSByICogby54LCBpID0gcyAqIG8ueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogYSxcbiAgICBoZWlnaHQ6IGwsXG4gICAgeDogdSxcbiAgICB5OiBpXG4gIH07XG59XG5mdW5jdGlvbiBPbih0LCBlLCBuKSB7XG4gIGxldCBzO1xuICBpZiAoZSA9PT0gXCJ2aWV3cG9ydFwiKVxuICAgIHMgPSBCbyh0LCBuKTtcbiAgZWxzZSBpZiAoZSA9PT0gXCJkb2N1bWVudFwiKVxuICAgIHMgPSBqbyhidCh0KSk7XG4gIGVsc2UgaWYgKGN0KGUpKVxuICAgIHMgPSBVbyhlLCBuKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgciA9IEZzKHQpO1xuICAgIHMgPSB7XG4gICAgICB4OiBlLnggLSByLngsXG4gICAgICB5OiBlLnkgLSByLnksXG4gICAgICB3aWR0aDogZS53aWR0aCxcbiAgICAgIGhlaWdodDogZS5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiBBZShzKTtcbn1cbmZ1bmN0aW9uIGpzKHQsIGUpIHtcbiAgY29uc3QgbiA9IFB0KHQpO1xuICByZXR1cm4gbiA9PT0gZSB8fCAhY3QobikgfHwgUXQobikgPyAhMSA6IHV0KG4pLnBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwganMobiwgZSk7XG59XG5mdW5jdGlvbiB6byh0LCBlKSB7XG4gIGNvbnN0IG4gPSBlLmdldCh0KTtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIG47XG4gIGxldCBzID0gbGUodCwgW10sICExKS5maWx0ZXIoKGwpID0+IGN0KGwpICYmIHRlKGwpICE9PSBcImJvZHlcIiksIHIgPSBudWxsO1xuICBjb25zdCBvID0gdXQodCkucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgbGV0IGEgPSBvID8gUHQodCkgOiB0O1xuICBmb3IgKDsgY3QoYSkgJiYgIVF0KGEpOyApIHtcbiAgICBjb25zdCBsID0gdXQoYSksIHUgPSBrbihhKTtcbiAgICAhdSAmJiBsLnBvc2l0aW9uID09PSBcImZpeGVkXCIgJiYgKHIgPSBudWxsKSwgKG8gPyAhdSAmJiAhciA6ICF1ICYmIGwucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgISFyICYmIFdvLmhhcyhyLnBvc2l0aW9uKSB8fCBoZShhKSAmJiAhdSAmJiBqcyh0LCBhKSkgPyBzID0gcy5maWx0ZXIoKGMpID0+IGMgIT09IGEpIDogciA9IGwsIGEgPSBQdChhKTtcbiAgfVxuICByZXR1cm4gZS5zZXQodCwgcyksIHM7XG59XG5mdW5jdGlvbiBWbyh0KSB7XG4gIGxldCB7XG4gICAgZWxlbWVudDogZSxcbiAgICBib3VuZGFyeTogbixcbiAgICByb290Qm91bmRhcnk6IHMsXG4gICAgc3RyYXRlZ3k6IHJcbiAgfSA9IHQ7XG4gIGNvbnN0IGEgPSBbLi4ubiA9PT0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiID8gX2UoZSkgPyBbXSA6IHpvKGUsIHRoaXMuX2MpIDogW10uY29uY2F0KG4pLCBzXSwgbCA9IGFbMF0sIHUgPSBhLnJlZHVjZSgoaSwgYykgPT4ge1xuICAgIGNvbnN0IGggPSBPbihlLCBjLCByKTtcbiAgICByZXR1cm4gaS50b3AgPSBHdChoLnRvcCwgaS50b3ApLCBpLnJpZ2h0ID0gbm4oaC5yaWdodCwgaS5yaWdodCksIGkuYm90dG9tID0gbm4oaC5ib3R0b20sIGkuYm90dG9tKSwgaS5sZWZ0ID0gR3QoaC5sZWZ0LCBpLmxlZnQpLCBpO1xuICB9LCBPbihlLCBsLCByKSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHUucmlnaHQgLSB1LmxlZnQsXG4gICAgaGVpZ2h0OiB1LmJvdHRvbSAtIHUudG9wLFxuICAgIHg6IHUubGVmdCxcbiAgICB5OiB1LnRvcFxuICB9O1xufVxuZnVuY3Rpb24gSG8odCkge1xuICBjb25zdCB7XG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBuXG4gIH0gPSBEcyh0KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogZSxcbiAgICBoZWlnaHQ6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEdvKHQsIGUsIG4pIHtcbiAgY29uc3QgcyA9IHl0KGUpLCByID0gYnQoZSksIG8gPSBuID09PSBcImZpeGVkXCIsIGEgPSBEdCh0LCAhMCwgbywgZSk7XG4gIGxldCBsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IHUgPSBTdCgwKTtcbiAgZnVuY3Rpb24gaSgpIHtcbiAgICB1LnggPSBOZShyKTtcbiAgfVxuICBpZiAocyB8fCAhcyAmJiAhbylcbiAgICBpZiAoKHRlKGUpICE9PSBcImJvZHlcIiB8fCBoZShyKSkgJiYgKGwgPSBJZShlKSksIHMpIHtcbiAgICAgIGNvbnN0IHAgPSBEdChlLCAhMCwgbywgZSk7XG4gICAgICB1LnggPSBwLnggKyBlLmNsaWVudExlZnQsIHUueSA9IHAueSArIGUuY2xpZW50VG9wO1xuICAgIH0gZWxzZSByICYmIGkoKTtcbiAgbyAmJiAhcyAmJiByICYmIGkoKTtcbiAgY29uc3QgYyA9IHIgJiYgIXMgJiYgIW8gPyBNcyhyLCBsKSA6IFN0KDApLCBoID0gYS5sZWZ0ICsgbC5zY3JvbGxMZWZ0IC0gdS54IC0gYy54LCBmID0gYS50b3AgKyBsLnNjcm9sbFRvcCAtIHUueSAtIGMueTtcbiAgcmV0dXJuIHtcbiAgICB4OiBoLFxuICAgIHk6IGYsXG4gICAgd2lkdGg6IGEud2lkdGgsXG4gICAgaGVpZ2h0OiBhLmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gRmUodCkge1xuICByZXR1cm4gdXQodCkucG9zaXRpb24gPT09IFwic3RhdGljXCI7XG59XG5mdW5jdGlvbiBSbih0LCBlKSB7XG4gIGlmICgheXQodCkgfHwgdXQodCkucG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIGUodCk7XG4gIGxldCBuID0gdC5vZmZzZXRQYXJlbnQ7XG4gIHJldHVybiBidCh0KSA9PT0gbiAmJiAobiA9IG4ub3duZXJEb2N1bWVudC5ib2R5KSwgbjtcbn1cbmZ1bmN0aW9uIEJzKHQsIGUpIHtcbiAgY29uc3QgbiA9IGl0KHQpO1xuICBpZiAoX2UodCkpXG4gICAgcmV0dXJuIG47XG4gIGlmICgheXQodCkpIHtcbiAgICBsZXQgciA9IFB0KHQpO1xuICAgIGZvciAoOyByICYmICFRdChyKTsgKSB7XG4gICAgICBpZiAoY3QocikgJiYgIUZlKHIpKVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIHIgPSBQdChyKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgbGV0IHMgPSBSbih0LCBlKTtcbiAgZm9yICg7IHMgJiYgJG8ocykgJiYgRmUocyk7IClcbiAgICBzID0gUm4ocywgZSk7XG4gIHJldHVybiBzICYmIFF0KHMpICYmIEZlKHMpICYmICFrbihzKSA/IG4gOiBzIHx8IF9vKHQpIHx8IG47XG59XG5jb25zdCBxbyA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIFIodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgQnMsIG4gPSB0aGlzLmdldERpbWVuc2lvbnMsIHMgPSB5aWVsZCBuKHQuZmxvYXRpbmcpO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IEdvKHQucmVmZXJlbmNlLCB5aWVsZCBlKHQuZmxvYXRpbmcpLCB0LnN0cmF0ZWd5KSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gS28odCkge1xuICByZXR1cm4gdXQodCkuZGlyZWN0aW9uID09PSBcInJ0bFwiO1xufVxuY29uc3QgViA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Q6IEZvLFxuICBnZXREb2N1bWVudEVsZW1lbnQ6IGJ0LFxuICBnZXRDbGlwcGluZ1JlY3Q6IFZvLFxuICBnZXRPZmZzZXRQYXJlbnQ6IEJzLFxuICBnZXRFbGVtZW50UmVjdHM6IHFvLFxuICBnZXRDbGllbnRSZWN0czogTW8sXG4gIGdldERpbWVuc2lvbnM6IEhvLFxuICBnZXRTY2FsZTogcXQsXG4gIGlzRWxlbWVudDogY3QsXG4gIGlzUlRMOiBLb1xufTtcbmZ1bmN0aW9uIFdzKHQsIGUpIHtcbiAgcmV0dXJuIHQueCA9PT0gZS54ICYmIHQueSA9PT0gZS55ICYmIHQud2lkdGggPT09IGUud2lkdGggJiYgdC5oZWlnaHQgPT09IGUuaGVpZ2h0O1xufVxuZnVuY3Rpb24gUW8odCwgZSkge1xuICBsZXQgbiA9IG51bGwsIHM7XG4gIGNvbnN0IHIgPSBidCh0KTtcbiAgZnVuY3Rpb24gbygpIHtcbiAgICB2YXIgbDtcbiAgICBjbGVhclRpbWVvdXQocyksIChsID0gbikgPT0gbnVsbCB8fCBsLmRpc2Nvbm5lY3QoKSwgbiA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gYShsLCB1KSB7XG4gICAgbCA9PT0gdm9pZCAwICYmIChsID0gITEpLCB1ID09PSB2b2lkIDAgJiYgKHUgPSAxKSwgbygpO1xuICAgIGNvbnN0IGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XG4gICAgICBsZWZ0OiBjLFxuICAgICAgdG9wOiBoLFxuICAgICAgd2lkdGg6IGYsXG4gICAgICBoZWlnaHQ6IHBcbiAgICB9ID0gaTtcbiAgICBpZiAobCB8fCBlKCksICFmIHx8ICFwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGQgPSBwZShoKSwgbSA9IHBlKHIuY2xpZW50V2lkdGggLSAoYyArIGYpKSwgayA9IHBlKHIuY2xpZW50SGVpZ2h0IC0gKGggKyBwKSksIHkgPSBwZShjKSwgQSA9IHtcbiAgICAgIHJvb3RNYXJnaW46IC1kICsgXCJweCBcIiArIC1tICsgXCJweCBcIiArIC1rICsgXCJweCBcIiArIC15ICsgXCJweFwiLFxuICAgICAgdGhyZXNob2xkOiBHdCgwLCBubigxLCB1KSkgfHwgMVxuICAgIH07XG4gICAgbGV0IE0gPSAhMDtcbiAgICBmdW5jdGlvbiBldCh3KSB7XG4gICAgICBjb25zdCBDID0gd1swXS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgIGlmIChDICE9PSB1KSB7XG4gICAgICAgIGlmICghTSlcbiAgICAgICAgICByZXR1cm4gYSgpO1xuICAgICAgICBDID8gYSghMSwgQykgOiBzID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYSghMSwgMWUtNyk7XG4gICAgICAgIH0sIDFlMyk7XG4gICAgICB9XG4gICAgICBDID09PSAxICYmICFXcyhpLCB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSAmJiBhKCksIE0gPSAhMTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG4gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZXQsIHEoVSh7fSwgQSksIHtcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByLm93bmVyRG9jdW1lbnRcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoICh3KSB7XG4gICAgICBuID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGV0LCBBKTtcbiAgICB9XG4gICAgbi5vYnNlcnZlKHQpO1xuICB9XG4gIHJldHVybiBhKCEwKSwgbztcbn1cbmZ1bmN0aW9uIHJuKHQsIGUsIG4sIHMpIHtcbiAgcyA9PT0gdm9pZCAwICYmIChzID0ge30pO1xuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGw6IHIgPSAhMCxcbiAgICBhbmNlc3RvclJlc2l6ZTogbyA9ICEwLFxuICAgIGVsZW1lbnRSZXNpemU6IGEgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiLFxuICAgIGxheW91dFNoaWZ0OiBsID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIixcbiAgICBhbmltYXRpb25GcmFtZTogdSA9ICExXG4gIH0gPSBzLCBpID0geW4odCksIGMgPSByIHx8IG8gPyBbLi4uaSA/IGxlKGkpIDogW10sIC4uLmxlKGUpXSA6IFtdO1xuICBjLmZvckVhY2goKHkpID0+IHtcbiAgICByICYmIHkuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBuLCB7XG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pLCBvICYmIHkuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBuKTtcbiAgfSk7XG4gIGNvbnN0IGggPSBpICYmIGwgPyBRbyhpLCBuKSA6IG51bGw7XG4gIGxldCBmID0gLTEsIHAgPSBudWxsO1xuICBhICYmIChwID0gbmV3IFJlc2l6ZU9ic2VydmVyKCh5KSA9PiB7XG4gICAgbGV0IFt4XSA9IHk7XG4gICAgeCAmJiB4LnRhcmdldCA9PT0gaSAmJiBwICYmIChwLnVub2JzZXJ2ZShlKSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZiksIGYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdmFyIEE7XG4gICAgICAoQSA9IHApID09IG51bGwgfHwgQS5vYnNlcnZlKGUpO1xuICAgIH0pKSwgbigpO1xuICB9KSwgaSAmJiAhdSAmJiBwLm9ic2VydmUoaSksIHAub2JzZXJ2ZShlKSk7XG4gIGxldCBkLCBtID0gdSA/IER0KHQpIDogbnVsbDtcbiAgdSAmJiBrKCk7XG4gIGZ1bmN0aW9uIGsoKSB7XG4gICAgY29uc3QgeSA9IER0KHQpO1xuICAgIG0gJiYgIVdzKG0sIHkpICYmIG4oKSwgbSA9IHksIGQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoayk7XG4gIH1cbiAgcmV0dXJuIG4oKSwgKCkgPT4ge1xuICAgIHZhciB5O1xuICAgIGMuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgciAmJiB4LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbiksIG8gJiYgeC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG4pO1xuICAgIH0pLCBoID09IG51bGwgfHwgaCgpLCAoeSA9IHApID09IG51bGwgfHwgeS5kaXNjb25uZWN0KCksIHAgPSBudWxsLCB1ICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGQpO1xuICB9O1xufVxuY29uc3QgWW8gPSBBbywgeyBoYXNPd25Qcm9wZXJ0eTogYm4gfSA9IE9iamVjdC5wcm90b3R5cGUsIG5lID0gZnVuY3Rpb24oKSB7XG59O1xuZnVuY3Rpb24gX24odCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCA6IG5lO1xufVxuZnVuY3Rpb24gSW4odCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24obiwgcywgcikge1xuICAgIG4udHlwZSA9PT0gZSAmJiB0LmNhbGwodGhpcywgbiwgcywgcik7XG4gIH07XG59XG5mdW5jdGlvbiBYbyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBlLnN0cnVjdHVyZSwgcyA9IFtdO1xuICBmb3IgKGNvbnN0IHIgaW4gbikge1xuICAgIGlmIChibi5jYWxsKG4sIHIpID09PSAhMSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGxldCBvID0gbltyXTtcbiAgICBjb25zdCBhID0ge1xuICAgICAgbmFtZTogcixcbiAgICAgIHR5cGU6ICExLFxuICAgICAgbnVsbGFibGU6ICExXG4gICAgfTtcbiAgICBBcnJheS5pc0FycmF5KG8pIHx8IChvID0gW29dKTtcbiAgICBmb3IgKGNvbnN0IGwgb2YgbylcbiAgICAgIGwgPT09IG51bGwgPyBhLm51bGxhYmxlID0gITAgOiB0eXBlb2YgbCA9PSBcInN0cmluZ1wiID8gYS50eXBlID0gXCJub2RlXCIgOiBBcnJheS5pc0FycmF5KGwpICYmIChhLnR5cGUgPSBcImxpc3RcIik7XG4gICAgYS50eXBlICYmIHMucHVzaChhKTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyB7XG4gICAgY29udGV4dDogZS53YWxrQ29udGV4dCxcbiAgICBmaWVsZHM6IHNcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiBKbyh0KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIHQubm9kZSlcbiAgICBpZiAoYm4uY2FsbCh0Lm5vZGUsIG4pKSB7XG4gICAgICBjb25zdCBzID0gdC5ub2RlW25dO1xuICAgICAgaWYgKCFzLnN0cnVjdHVyZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2VkIGBzdHJ1Y3R1cmVgIGZpZWxkIGluIGBcIiArIG4gKyBcImAgbm9kZSB0eXBlIGRlZmluaXRpb25cIik7XG4gICAgICBlW25dID0gWG8obiwgcyk7XG4gICAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE5uKHQsIGUpIHtcbiAgY29uc3QgbiA9IHQuZmllbGRzLnNsaWNlKCksIHMgPSB0LmNvbnRleHQsIHIgPSB0eXBlb2YgcyA9PSBcInN0cmluZ1wiO1xuICByZXR1cm4gZSAmJiBuLnJldmVyc2UoKSwgZnVuY3Rpb24obywgYSwgbCwgdSkge1xuICAgIGxldCBpO1xuICAgIHIgJiYgKGkgPSBhW3NdLCBhW3NdID0gbyk7XG4gICAgZm9yIChjb25zdCBjIG9mIG4pIHtcbiAgICAgIGNvbnN0IGggPSBvW2MubmFtZV07XG4gICAgICBpZiAoIWMubnVsbGFibGUgfHwgaCkge1xuICAgICAgICBpZiAoYy50eXBlID09PSBcImxpc3RcIikge1xuICAgICAgICAgIGlmIChlID8gaC5yZWR1Y2VSaWdodCh1LCAhMSkgOiBoLnJlZHVjZSh1LCAhMSkpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0gZWxzZSBpZiAobChoKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIHIgJiYgKGFbc10gPSBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIERuKHtcbiAgU3R5bGVTaGVldDogdCxcbiAgQXRydWxlOiBlLFxuICBSdWxlOiBuLFxuICBCbG9jazogcyxcbiAgRGVjbGFyYXRpb25MaXN0OiByXG59KSB7XG4gIHJldHVybiB7XG4gICAgQXRydWxlOiB7XG4gICAgICBTdHlsZVNoZWV0OiB0LFxuICAgICAgQXRydWxlOiBlLFxuICAgICAgUnVsZTogbixcbiAgICAgIEJsb2NrOiBzXG4gICAgfSxcbiAgICBSdWxlOiB7XG4gICAgICBTdHlsZVNoZWV0OiB0LFxuICAgICAgQXRydWxlOiBlLFxuICAgICAgUnVsZTogbixcbiAgICAgIEJsb2NrOiBzXG4gICAgfSxcbiAgICBEZWNsYXJhdGlvbjoge1xuICAgICAgU3R5bGVTaGVldDogdCxcbiAgICAgIEF0cnVsZTogZSxcbiAgICAgIFJ1bGU6IG4sXG4gICAgICBCbG9jazogcyxcbiAgICAgIERlY2xhcmF0aW9uTGlzdDogclxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFpvKHQpIHtcbiAgY29uc3QgZSA9IEpvKHQpLCBuID0ge30sIHMgPSB7fSwgciA9IFN5bWJvbChcImJyZWFrLXdhbGtcIiksIG8gPSBTeW1ib2woXCJza2lwLW5vZGVcIik7XG4gIGZvciAoY29uc3QgaSBpbiBlKVxuICAgIGJuLmNhbGwoZSwgaSkgJiYgZVtpXSAhPT0gbnVsbCAmJiAobltpXSA9IE5uKGVbaV0sICExKSwgc1tpXSA9IE5uKGVbaV0sICEwKSk7XG4gIGNvbnN0IGEgPSBEbihuKSwgbCA9IERuKHMpLCB1ID0gZnVuY3Rpb24oaSwgYykge1xuICAgIGZ1bmN0aW9uIGgoeSwgeCwgQSkge1xuICAgICAgY29uc3QgTSA9IGYuY2FsbChrLCB5LCB4LCBBKTtcbiAgICAgIHJldHVybiBNID09PSByID8gITAgOiBNID09PSBvID8gITEgOiAhIShkLmhhc093blByb3BlcnR5KHkudHlwZSkgJiYgZFt5LnR5cGVdKHksIGssIGgsIG0pIHx8IHAuY2FsbChrLCB5LCB4LCBBKSA9PT0gcik7XG4gICAgfVxuICAgIGxldCBmID0gbmUsIHAgPSBuZSwgZCA9IG4sIG0gPSAoeSwgeCwgQSwgTSkgPT4geSB8fCBoKHgsIEEsIE0pO1xuICAgIGNvbnN0IGsgPSB7XG4gICAgICBicmVhazogcixcbiAgICAgIHNraXA6IG8sXG4gICAgICByb290OiBpLFxuICAgICAgc3R5bGVzaGVldDogbnVsbCxcbiAgICAgIGF0cnVsZTogbnVsbCxcbiAgICAgIGF0cnVsZVByZWx1ZGU6IG51bGwsXG4gICAgICBydWxlOiBudWxsLFxuICAgICAgc2VsZWN0b3I6IG51bGwsXG4gICAgICBibG9jazogbnVsbCxcbiAgICAgIGRlY2xhcmF0aW9uOiBudWxsLFxuICAgICAgZnVuY3Rpb246IG51bGxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmID0gYztcbiAgICBlbHNlIGlmIChjICYmIChmID0gX24oYy5lbnRlciksIHAgPSBfbihjLmxlYXZlKSwgYy5yZXZlcnNlICYmIChkID0gcyksIGMudmlzaXQpKSB7XG4gICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShjLnZpc2l0KSlcbiAgICAgICAgZCA9IGMucmV2ZXJzZSA/IGxbYy52aXNpdF0gOiBhW2MudmlzaXRdO1xuICAgICAgZWxzZSBpZiAoIWUuaGFzT3duUHJvcGVydHkoYy52aXNpdCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2YWx1ZSBgXCIgKyBjLnZpc2l0ICsgXCJgIGZvciBgdmlzaXRgIG9wdGlvbiAoc2hvdWxkIGJlOiBcIiArIE9iamVjdC5rZXlzKGUpLnNvcnQoKS5qb2luKFwiLCBcIikgKyBcIilcIik7XG4gICAgICBmID0gSW4oZiwgYy52aXNpdCksIHAgPSBJbihwLCBjLnZpc2l0KTtcbiAgICB9XG4gICAgaWYgKGYgPT09IG5lICYmIHAgPT09IG5lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciBgZW50ZXJgIG5vciBgbGVhdmVgIHdhbGtlciBoYW5kbGVyIGlzIHNldCBvciBib3RoIGFyZW4ndCBhIGZ1bmN0aW9uXCIpO1xuICAgIGgoaSk7XG4gIH07XG4gIHJldHVybiB1LmJyZWFrID0gciwgdS5za2lwID0gbywgdS5maW5kID0gZnVuY3Rpb24oaSwgYykge1xuICAgIGxldCBoID0gbnVsbDtcbiAgICByZXR1cm4gdShpLCBmdW5jdGlvbihmLCBwLCBkKSB7XG4gICAgICBpZiAoYy5jYWxsKHRoaXMsIGYsIHAsIGQpKVxuICAgICAgICByZXR1cm4gaCA9IGYsIHI7XG4gICAgfSksIGg7XG4gIH0sIHUuZmluZExhc3QgPSBmdW5jdGlvbihpLCBjKSB7XG4gICAgbGV0IGggPSBudWxsO1xuICAgIHJldHVybiB1KGksIHtcbiAgICAgIHJldmVyc2U6ICEwLFxuICAgICAgZW50ZXIoZiwgcCwgZCkge1xuICAgICAgICBpZiAoYy5jYWxsKHRoaXMsIGYsIHAsIGQpKVxuICAgICAgICAgIHJldHVybiBoID0gZiwgcjtcbiAgICAgIH1cbiAgICB9KSwgaDtcbiAgfSwgdS5maW5kQWxsID0gZnVuY3Rpb24oaSwgYykge1xuICAgIGNvbnN0IGggPSBbXTtcbiAgICByZXR1cm4gdShpLCBmdW5jdGlvbihmLCBwLCBkKSB7XG4gICAgICBjLmNhbGwodGhpcywgZiwgcCwgZCkgJiYgaC5wdXNoKGYpO1xuICAgIH0pLCBoO1xuICB9LCB1O1xufVxuY29uc3QgdnQgPSAwLCBnID0gMSwgVCA9IDIsIHogPSAzLCBJID0gNCwgVHQgPSA1LCB0YSA9IDYsIFEgPSA3LCBhdCA9IDgsIEwgPSA5LCBiID0gMTAsIEYgPSAxMSwgRSA9IDEyLCBXID0gMTMsIERlID0gMTQsIG50ID0gMTUsIFggPSAxNiwgdHQgPSAxNywgZnQgPSAxOCwgZWUgPSAxOSwgY2UgPSAyMCwgXyA9IDIxLCBTID0gMjIsIGh0ID0gMjMsIFl0ID0gMjQsIFkgPSAyNSwgZWEgPSAwO1xuZnVuY3Rpb24gcnQodCkge1xuICByZXR1cm4gdCA+PSA0OCAmJiB0IDw9IDU3O1xufVxuZnVuY3Rpb24gWHQodCkge1xuICByZXR1cm4gcnQodCkgfHwgLy8gMCAuLiA5XG4gIHQgPj0gNjUgJiYgdCA8PSA3MCB8fCAvLyBBIC4uIEZcbiAgdCA+PSA5NyAmJiB0IDw9IDEwMjtcbn1cbmZ1bmN0aW9uIHhuKHQpIHtcbiAgcmV0dXJuIHQgPj0gNjUgJiYgdCA8PSA5MDtcbn1cbmZ1bmN0aW9uIG5hKHQpIHtcbiAgcmV0dXJuIHQgPj0gOTcgJiYgdCA8PSAxMjI7XG59XG5mdW5jdGlvbiBzYSh0KSB7XG4gIHJldHVybiB4bih0KSB8fCBuYSh0KTtcbn1cbmZ1bmN0aW9uIHJhKHQpIHtcbiAgcmV0dXJuIHQgPj0gMTI4O1xufVxuZnVuY3Rpb24gdmUodCkge1xuICByZXR1cm4gc2EodCkgfHwgcmEodCkgfHwgdCA9PT0gOTU7XG59XG5mdW5jdGlvbiBVcyh0KSB7XG4gIHJldHVybiB2ZSh0KSB8fCBydCh0KSB8fCB0ID09PSA0NTtcbn1cbmZ1bmN0aW9uIGlhKHQpIHtcbiAgcmV0dXJuIHQgPj0gMCAmJiB0IDw9IDggfHwgdCA9PT0gMTEgfHwgdCA+PSAxNCAmJiB0IDw9IDMxIHx8IHQgPT09IDEyNztcbn1cbmZ1bmN0aW9uIEVlKHQpIHtcbiAgcmV0dXJuIHQgPT09IDEwIHx8IHQgPT09IDEzIHx8IHQgPT09IDEyO1xufVxuZnVuY3Rpb24gRnQodCkge1xuICByZXR1cm4gRWUodCkgfHwgdCA9PT0gMzIgfHwgdCA9PT0gOTtcbn1cbmZ1bmN0aW9uIGt0KHQsIGUpIHtcbiAgcmV0dXJuICEodCAhPT0gOTIgfHwgRWUoZSkgfHwgZSA9PT0gZWEpO1xufVxuZnVuY3Rpb24gTWUodCwgZSwgbikge1xuICByZXR1cm4gdCA9PT0gNDUgPyB2ZShlKSB8fCBlID09PSA0NSB8fCBrdChlLCBuKSA6IHZlKHQpID8gITAgOiB0ID09PSA5MiA/IGt0KHQsIGUpIDogITE7XG59XG5mdW5jdGlvbiBqZSh0LCBlLCBuKSB7XG4gIHJldHVybiB0ID09PSA0MyB8fCB0ID09PSA0NSA/IHJ0KGUpID8gMiA6IGUgPT09IDQ2ICYmIHJ0KG4pID8gMyA6IDAgOiB0ID09PSA0NiA/IHJ0KGUpID8gMiA6IDAgOiBydCh0KSA/IDEgOiAwO1xufVxuZnVuY3Rpb24genModCkge1xuICByZXR1cm4gdCA9PT0gNjUyNzkgfHwgdCA9PT0gNjU1MzQgPyAxIDogMDtcbn1cbmNvbnN0IG9uID0gbmV3IEFycmF5KDEyOCksIG9hID0gMTI4LCB5ZSA9IDEzMCwgVnMgPSAxMzEsIENuID0gMTMyLCBIcyA9IDEzMztcbmZvciAobGV0IHQgPSAwOyB0IDwgb24ubGVuZ3RoOyB0KyspXG4gIG9uW3RdID0gRnQodCkgJiYgeWUgfHwgcnQodCkgJiYgVnMgfHwgdmUodCkgJiYgQ24gfHwgaWEodCkgJiYgSHMgfHwgdCB8fCBvYTtcbmZ1bmN0aW9uIEJlKHQpIHtcbiAgcmV0dXJuIHQgPCAxMjggPyBvblt0XSA6IENuO1xufVxuZnVuY3Rpb24gS3QodCwgZSkge1xuICByZXR1cm4gZSA8IHQubGVuZ3RoID8gdC5jaGFyQ29kZUF0KGUpIDogMDtcbn1cbmZ1bmN0aW9uIGFuKHQsIGUsIG4pIHtcbiAgcmV0dXJuIG4gPT09IDEzICYmIEt0KHQsIGUgKyAxKSA9PT0gMTAgPyAyIDogMTtcbn1cbmZ1bmN0aW9uIEdzKHQsIGUsIG4pIHtcbiAgbGV0IHMgPSB0LmNoYXJDb2RlQXQoZSk7XG4gIHJldHVybiB4bihzKSAmJiAocyA9IHMgfCAzMiksIHMgPT09IG47XG59XG5mdW5jdGlvbiAkZSh0LCBlLCBuLCBzKSB7XG4gIGlmIChuIC0gZSAhPT0gcy5sZW5ndGggfHwgZSA8IDAgfHwgbiA+IHQubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgciA9IGU7IHIgPCBuOyByKyspIHtcbiAgICBjb25zdCBvID0gcy5jaGFyQ29kZUF0KHIgLSBlKTtcbiAgICBsZXQgYSA9IHQuY2hhckNvZGVBdChyKTtcbiAgICBpZiAoeG4oYSkgJiYgKGEgPSBhIHwgMzIpLCBhICE9PSBvKVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGFhKHQsIGUpIHtcbiAgZm9yICg7IGUgPj0gMCAmJiBGdCh0LmNoYXJDb2RlQXQoZSkpOyBlLS0pXG4gICAgO1xuICByZXR1cm4gZSArIDE7XG59XG5mdW5jdGlvbiBkZSh0LCBlKSB7XG4gIGZvciAoOyBlIDwgdC5sZW5ndGggJiYgRnQodC5jaGFyQ29kZUF0KGUpKTsgZSsrKVxuICAgIDtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBXZSh0LCBlKSB7XG4gIGZvciAoOyBlIDwgdC5sZW5ndGggJiYgcnQodC5jaGFyQ29kZUF0KGUpKTsgZSsrKVxuICAgIDtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBKdCh0LCBlKSB7XG4gIGlmIChlICs9IDIsIFh0KEt0KHQsIGUgLSAxKSkpIHtcbiAgICBmb3IgKGNvbnN0IHMgPSBNYXRoLm1pbih0Lmxlbmd0aCwgZSArIDUpOyBlIDwgcyAmJiBYdChLdCh0LCBlKSk7IGUrKylcbiAgICAgIDtcbiAgICBjb25zdCBuID0gS3QodCwgZSk7XG4gICAgRnQobikgJiYgKGUgKz0gYW4odCwgZSwgbikpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZ2UodCwgZSkge1xuICBmb3IgKDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICBjb25zdCBuID0gdC5jaGFyQ29kZUF0KGUpO1xuICAgIGlmICghVXMobikpIHtcbiAgICAgIGlmIChrdChuLCBLdCh0LCBlICsgMSkpKSB7XG4gICAgICAgIGUgPSBKdCh0LCBlKSAtIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXModCwgZSkge1xuICBsZXQgbiA9IHQuY2hhckNvZGVBdChlKTtcbiAgaWYgKChuID09PSA0MyB8fCBuID09PSA0NSkgJiYgKG4gPSB0LmNoYXJDb2RlQXQoZSArPSAxKSksIHJ0KG4pICYmIChlID0gV2UodCwgZSArIDEpLCBuID0gdC5jaGFyQ29kZUF0KGUpKSwgbiA9PT0gNDYgJiYgcnQodC5jaGFyQ29kZUF0KGUgKyAxKSkgJiYgKGUgKz0gMiwgZSA9IFdlKHQsIGUpKSwgR3MoXG4gICAgdCxcbiAgICBlLFxuICAgIDEwMVxuICAgIC8qIGUgKi9cbiAgKSkge1xuICAgIGxldCBzID0gMDtcbiAgICBuID0gdC5jaGFyQ29kZUF0KGUgKyAxKSwgKG4gPT09IDQ1IHx8IG4gPT09IDQzKSAmJiAocyA9IDEsIG4gPSB0LmNoYXJDb2RlQXQoZSArIDIpKSwgcnQobikgJiYgKGUgPSBXZSh0LCBlICsgMSArIHMgKyAxKSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBVZSh0LCBlKSB7XG4gIGZvciAoOyBlIDwgdC5sZW5ndGg7IGUrKykge1xuICAgIGNvbnN0IG4gPSB0LmNoYXJDb2RlQXQoZSk7XG4gICAgaWYgKG4gPT09IDQxKSB7XG4gICAgICBlKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAga3QobiwgS3QodCwgZSArIDEpKSAmJiAoZSA9IEp0KHQsIGUpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEtzKHQpIHtcbiAgaWYgKHQubGVuZ3RoID09PSAxICYmICFYdCh0LmNoYXJDb2RlQXQoMCkpKVxuICAgIHJldHVybiB0WzBdO1xuICBsZXQgZSA9IHBhcnNlSW50KHQsIDE2KTtcbiAgcmV0dXJuIChlID09PSAwIHx8IC8vIElmIHRoaXMgbnVtYmVyIGlzIHplcm8sXG4gIGUgPj0gNTUyOTYgJiYgZSA8PSA1NzM0MyB8fCAvLyBvciBpcyBmb3IgYSBzdXJyb2dhdGUsXG4gIGUgPiAxMTE0MTExKSAmJiAoZSA9IDY1NTMzKSwgU3RyaW5nLmZyb21Db2RlUG9pbnQoZSk7XG59XG5jb25zdCBRcyA9IFtcbiAgXCJFT0YtdG9rZW5cIixcbiAgXCJpZGVudC10b2tlblwiLFxuICBcImZ1bmN0aW9uLXRva2VuXCIsXG4gIFwiYXQta2V5d29yZC10b2tlblwiLFxuICBcImhhc2gtdG9rZW5cIixcbiAgXCJzdHJpbmctdG9rZW5cIixcbiAgXCJiYWQtc3RyaW5nLXRva2VuXCIsXG4gIFwidXJsLXRva2VuXCIsXG4gIFwiYmFkLXVybC10b2tlblwiLFxuICBcImRlbGltLXRva2VuXCIsXG4gIFwibnVtYmVyLXRva2VuXCIsXG4gIFwicGVyY2VudGFnZS10b2tlblwiLFxuICBcImRpbWVuc2lvbi10b2tlblwiLFxuICBcIndoaXRlc3BhY2UtdG9rZW5cIixcbiAgXCJDRE8tdG9rZW5cIixcbiAgXCJDREMtdG9rZW5cIixcbiAgXCJjb2xvbi10b2tlblwiLFxuICBcInNlbWljb2xvbi10b2tlblwiLFxuICBcImNvbW1hLXRva2VuXCIsXG4gIFwiWy10b2tlblwiLFxuICBcIl0tdG9rZW5cIixcbiAgXCIoLXRva2VuXCIsXG4gIFwiKS10b2tlblwiLFxuICBcInstdG9rZW5cIixcbiAgXCJ9LXRva2VuXCIsXG4gIFwiY29tbWVudC10b2tlblwiXG5dLCBsYSA9IDE2ICogMTAyNDtcbmZ1bmN0aW9uIExlKHQgPSBudWxsLCBlKSB7XG4gIHJldHVybiB0ID09PSBudWxsIHx8IHQubGVuZ3RoIDwgZSA/IG5ldyBVaW50MzJBcnJheShNYXRoLm1heChlICsgMTAyNCwgbGEpKSA6IHQ7XG59XG5jb25zdCBGbiA9IDEwLCBjYSA9IDEyLCBNbiA9IDEzO1xuZnVuY3Rpb24gam4odCkge1xuICBjb25zdCBlID0gdC5zb3VyY2UsIG4gPSBlLmxlbmd0aCwgcyA9IGUubGVuZ3RoID4gMCA/IHpzKGUuY2hhckNvZGVBdCgwKSkgOiAwLCByID0gTGUodC5saW5lcywgbiksIG8gPSBMZSh0LmNvbHVtbnMsIG4pO1xuICBsZXQgYSA9IHQuc3RhcnRMaW5lLCBsID0gdC5zdGFydENvbHVtbjtcbiAgZm9yIChsZXQgdSA9IHM7IHUgPCBuOyB1KyspIHtcbiAgICBjb25zdCBpID0gZS5jaGFyQ29kZUF0KHUpO1xuICAgIHJbdV0gPSBhLCBvW3VdID0gbCsrLCAoaSA9PT0gRm4gfHwgaSA9PT0gTW4gfHwgaSA9PT0gY2EpICYmIChpID09PSBNbiAmJiB1ICsgMSA8IG4gJiYgZS5jaGFyQ29kZUF0KHUgKyAxKSA9PT0gRm4gJiYgKHUrKywgclt1XSA9IGEsIG9bdV0gPSBsKSwgYSsrLCBsID0gMSk7XG4gIH1cbiAgcltuXSA9IGEsIG9bbl0gPSBsLCB0LmxpbmVzID0gciwgdC5jb2x1bW5zID0gbywgdC5jb21wdXRlZCA9ICEwO1xufVxuY2xhc3MgdWEge1xuICBjb25zdHJ1Y3RvcihlLCBuLCBzLCByKSB7XG4gICAgdGhpcy5zZXRTb3VyY2UoZSwgbiwgcywgciksIHRoaXMubGluZXMgPSBudWxsLCB0aGlzLmNvbHVtbnMgPSBudWxsO1xuICB9XG4gIHNldFNvdXJjZShlID0gXCJcIiwgbiA9IDAsIHMgPSAxLCByID0gMSkge1xuICAgIHRoaXMuc291cmNlID0gZSwgdGhpcy5zdGFydE9mZnNldCA9IG4sIHRoaXMuc3RhcnRMaW5lID0gcywgdGhpcy5zdGFydENvbHVtbiA9IHIsIHRoaXMuY29tcHV0ZWQgPSAhMTtcbiAgfVxuICBnZXRMb2NhdGlvbihlLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZWQgfHwgam4odGhpcyksIHtcbiAgICAgIHNvdXJjZTogbixcbiAgICAgIG9mZnNldDogdGhpcy5zdGFydE9mZnNldCArIGUsXG4gICAgICBsaW5lOiB0aGlzLmxpbmVzW2VdLFxuICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbnNbZV1cbiAgICB9O1xuICB9XG4gIGdldExvY2F0aW9uUmFuZ2UoZSwgbiwgcykge1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVkIHx8IGpuKHRoaXMpLCB7XG4gICAgICBzb3VyY2U6IHMsXG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHRoaXMuc3RhcnRPZmZzZXQgKyBlLFxuICAgICAgICBsaW5lOiB0aGlzLmxpbmVzW2VdLFxuICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uc1tlXVxuICAgICAgfSxcbiAgICAgIGVuZDoge1xuICAgICAgICBvZmZzZXQ6IHRoaXMuc3RhcnRPZmZzZXQgKyBuLFxuICAgICAgICBsaW5lOiB0aGlzLmxpbmVzW25dLFxuICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uc1tuXVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IGR0ID0gMTY3NzcyMTUsIGd0ID0gMjQsIE10ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuTXRbVF0gPSBTO1xuTXRbX10gPSBTO1xuTXRbZWVdID0gY2U7XG5NdFtodF0gPSBZdDtcbmZ1bmN0aW9uIEJuKHQpIHtcbiAgcmV0dXJuIE10W3RdICE9PSAwO1xufVxuY2xhc3MgaGEge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5zZXRTb3VyY2UoZSwgbik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5lb2YgPSAhMSwgdGhpcy50b2tlbkluZGV4ID0gLTEsIHRoaXMudG9rZW5UeXBlID0gMCwgdGhpcy50b2tlblN0YXJ0ID0gdGhpcy5maXJzdENoYXJPZmZzZXQsIHRoaXMudG9rZW5FbmQgPSB0aGlzLmZpcnN0Q2hhck9mZnNldDtcbiAgfVxuICBzZXRTb3VyY2UoZSA9IFwiXCIsIG4gPSAoKSA9PiB7XG4gIH0pIHtcbiAgICBlID0gU3RyaW5nKGUgfHwgXCJcIik7XG4gICAgY29uc3QgcyA9IGUubGVuZ3RoLCByID0gTGUodGhpcy5vZmZzZXRBbmRUeXBlLCBlLmxlbmd0aCArIDEpLCBvID0gTGUodGhpcy5iYWxhbmNlLCBlLmxlbmd0aCArIDEpO1xuICAgIGxldCBhID0gMCwgbCA9IC0xLCB1ID0gMCwgaSA9IGUubGVuZ3RoO1xuICAgIHRoaXMub2Zmc2V0QW5kVHlwZSA9IG51bGwsIHRoaXMuYmFsYW5jZSA9IG51bGwsIG8uZmlsbCgwKSwgbihlLCAoYywgaCwgZikgPT4ge1xuICAgICAgY29uc3QgcCA9IGErKztcbiAgICAgIGlmIChyW3BdID0gYyA8PCBndCB8IGYsIGwgPT09IC0xICYmIChsID0gaCksIG9bcF0gPSBpLCBjID09PSB1KSB7XG4gICAgICAgIGNvbnN0IGQgPSBvW2ldO1xuICAgICAgICBvW2ldID0gcCwgaSA9IGQsIHUgPSBNdFtyW2RdID4+IGd0XTtcbiAgICAgIH0gZWxzZSBCbihjKSAmJiAoaSA9IHAsIHUgPSBNdFtjXSk7XG4gICAgfSksIHJbYV0gPSB2dCA8PCBndCB8IHMsIG9bYV0gPSBhO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYTsgYysrKSB7XG4gICAgICBjb25zdCBoID0gb1tjXTtcbiAgICAgIGlmIChoIDw9IGMpIHtcbiAgICAgICAgY29uc3QgZiA9IG9baF07XG4gICAgICAgIGYgIT09IGMgJiYgKG9bY10gPSBmKTtcbiAgICAgIH0gZWxzZSBoID4gYSAmJiAob1tjXSA9IGEpO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IGUsIHRoaXMuZmlyc3RDaGFyT2Zmc2V0ID0gbCA9PT0gLTEgPyAwIDogbCwgdGhpcy50b2tlbkNvdW50ID0gYSwgdGhpcy5vZmZzZXRBbmRUeXBlID0gciwgdGhpcy5iYWxhbmNlID0gbywgdGhpcy5yZXNldCgpLCB0aGlzLm5leHQoKTtcbiAgfVxuICBsb29rdXBUeXBlKGUpIHtcbiAgICByZXR1cm4gZSArPSB0aGlzLnRva2VuSW5kZXgsIGUgPCB0aGlzLnRva2VuQ291bnQgPyB0aGlzLm9mZnNldEFuZFR5cGVbZV0gPj4gZ3QgOiB2dDtcbiAgfVxuICBsb29rdXBUeXBlTm9uU0MoZSkge1xuICAgIGZvciAobGV0IG4gPSB0aGlzLnRva2VuSW5kZXg7IG4gPCB0aGlzLnRva2VuQ291bnQ7IG4rKykge1xuICAgICAgY29uc3QgcyA9IHRoaXMub2Zmc2V0QW5kVHlwZVtuXSA+PiBndDtcbiAgICAgIGlmIChzICE9PSBXICYmIHMgIT09IFkgJiYgZS0tID09PSAwKVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmV0dXJuIHZ0O1xuICB9XG4gIGxvb2t1cE9mZnNldChlKSB7XG4gICAgcmV0dXJuIGUgKz0gdGhpcy50b2tlbkluZGV4LCBlIDwgdGhpcy50b2tlbkNvdW50ID8gdGhpcy5vZmZzZXRBbmRUeXBlW2UgLSAxXSAmIGR0IDogdGhpcy5zb3VyY2UubGVuZ3RoO1xuICB9XG4gIGxvb2t1cE9mZnNldE5vblNDKGUpIHtcbiAgICBmb3IgKGxldCBuID0gdGhpcy50b2tlbkluZGV4OyBuIDwgdGhpcy50b2tlbkNvdW50OyBuKyspIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLm9mZnNldEFuZFR5cGVbbl0gPj4gZ3Q7XG4gICAgICBpZiAocyAhPT0gVyAmJiBzICE9PSBZICYmIGUtLSA9PT0gMClcbiAgICAgICAgcmV0dXJuIG4gLSB0aGlzLnRva2VuSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB2dDtcbiAgfVxuICBsb29rdXBWYWx1ZShlLCBuKSB7XG4gICAgcmV0dXJuIGUgKz0gdGhpcy50b2tlbkluZGV4LCBlIDwgdGhpcy50b2tlbkNvdW50ID8gJGUoXG4gICAgICB0aGlzLnNvdXJjZSxcbiAgICAgIHRoaXMub2Zmc2V0QW5kVHlwZVtlIC0gMV0gJiBkdCxcbiAgICAgIHRoaXMub2Zmc2V0QW5kVHlwZVtlXSAmIGR0LFxuICAgICAgblxuICAgICkgOiAhMTtcbiAgfVxuICBnZXRUb2tlblN0YXJ0KGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdGhpcy50b2tlbkluZGV4ID8gdGhpcy50b2tlblN0YXJ0IDogZSA+IDAgPyBlIDwgdGhpcy50b2tlbkNvdW50ID8gdGhpcy5vZmZzZXRBbmRUeXBlW2UgLSAxXSAmIGR0IDogdGhpcy5vZmZzZXRBbmRUeXBlW3RoaXMudG9rZW5Db3VudF0gJiBkdCA6IHRoaXMuZmlyc3RDaGFyT2Zmc2V0O1xuICB9XG4gIHN1YnN0clRvQ3Vyc29yKGUpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic3RyaW5nKGUsIHRoaXMudG9rZW5TdGFydCk7XG4gIH1cbiAgaXNCYWxhbmNlRWRnZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFsYW5jZVt0aGlzLnRva2VuSW5kZXhdIDwgZTtcbiAgfVxuICBpc0RlbGltKGUsIG4pIHtcbiAgICByZXR1cm4gbiA/IHRoaXMubG9va3VwVHlwZShuKSA9PT0gTCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMubG9va3VwT2Zmc2V0KG4pKSA9PT0gZSA6IHRoaXMudG9rZW5UeXBlID09PSBMICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy50b2tlblN0YXJ0KSA9PT0gZTtcbiAgfVxuICBza2lwKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMudG9rZW5JbmRleCArIGU7XG4gICAgbiA8IHRoaXMudG9rZW5Db3VudCA/ICh0aGlzLnRva2VuSW5kZXggPSBuLCB0aGlzLnRva2VuU3RhcnQgPSB0aGlzLm9mZnNldEFuZFR5cGVbbiAtIDFdICYgZHQsIG4gPSB0aGlzLm9mZnNldEFuZFR5cGVbbl0sIHRoaXMudG9rZW5UeXBlID0gbiA+PiBndCwgdGhpcy50b2tlbkVuZCA9IG4gJiBkdCkgOiAodGhpcy50b2tlbkluZGV4ID0gdGhpcy50b2tlbkNvdW50LCB0aGlzLm5leHQoKSk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBsZXQgZSA9IHRoaXMudG9rZW5JbmRleCArIDE7XG4gICAgZSA8IHRoaXMudG9rZW5Db3VudCA/ICh0aGlzLnRva2VuSW5kZXggPSBlLCB0aGlzLnRva2VuU3RhcnQgPSB0aGlzLnRva2VuRW5kLCBlID0gdGhpcy5vZmZzZXRBbmRUeXBlW2VdLCB0aGlzLnRva2VuVHlwZSA9IGUgPj4gZ3QsIHRoaXMudG9rZW5FbmQgPSBlICYgZHQpIDogKHRoaXMuZW9mID0gITAsIHRoaXMudG9rZW5JbmRleCA9IHRoaXMudG9rZW5Db3VudCwgdGhpcy50b2tlblR5cGUgPSB2dCwgdGhpcy50b2tlblN0YXJ0ID0gdGhpcy50b2tlbkVuZCA9IHRoaXMuc291cmNlLmxlbmd0aCk7XG4gIH1cbiAgc2tpcFNDKCkge1xuICAgIGZvciAoOyB0aGlzLnRva2VuVHlwZSA9PT0gVyB8fCB0aGlzLnRva2VuVHlwZSA9PT0gWTsgKVxuICAgICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgc2tpcFVudGlsQmFsYW5jZWQoZSwgbikge1xuICAgIGxldCBzID0gZSwgciA9IDAsIG8gPSAwO1xuICAgIHQ6XG4gICAgICBmb3IgKDsgcyA8IHRoaXMudG9rZW5Db3VudDsgcysrKSB7XG4gICAgICAgIGlmIChyID0gdGhpcy5iYWxhbmNlW3NdLCByIDwgZSlcbiAgICAgICAgICBicmVhayB0O1xuICAgICAgICBzd2l0Y2ggKG8gPSBzID4gMCA/IHRoaXMub2Zmc2V0QW5kVHlwZVtzIC0gMV0gJiBkdCA6IHRoaXMuZmlyc3RDaGFyT2Zmc2V0LCBuKHRoaXMuc291cmNlLmNoYXJDb2RlQXQobykpKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYnJlYWsgdDtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzKys7XG4gICAgICAgICAgICBicmVhayB0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBCbih0aGlzLm9mZnNldEFuZFR5cGVbc10gPj4gZ3QpICYmIChzID0gcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB0aGlzLnNraXAocyAtIHRoaXMudG9rZW5JbmRleCk7XG4gIH1cbiAgZm9yRWFjaFRva2VuKGUpIHtcbiAgICBmb3IgKGxldCBuID0gMCwgcyA9IHRoaXMuZmlyc3RDaGFyT2Zmc2V0OyBuIDwgdGhpcy50b2tlbkNvdW50OyBuKyspIHtcbiAgICAgIGNvbnN0IHIgPSBzLCBvID0gdGhpcy5vZmZzZXRBbmRUeXBlW25dLCBhID0gbyAmIGR0LCBsID0gbyA+PiBndDtcbiAgICAgIHMgPSBhLCBlKGwsIHIsIGEsIG4pO1xuICAgIH1cbiAgfVxuICBkdW1wKCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkodGhpcy50b2tlbkNvdW50KTtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoVG9rZW4oKG4sIHMsIHIsIG8pID0+IHtcbiAgICAgIGVbb10gPSB7XG4gICAgICAgIGlkeDogbyxcbiAgICAgICAgdHlwZTogUXNbbl0sXG4gICAgICAgIGNodW5rOiB0aGlzLnNvdXJjZS5zdWJzdHJpbmcocywgciksXG4gICAgICAgIGJhbGFuY2U6IHRoaXMuYmFsYW5jZVtvXVxuICAgICAgfTtcbiAgICB9KSwgZTtcbiAgfVxufVxuZnVuY3Rpb24gWXModCwgZSkge1xuICBmdW5jdGlvbiBuKGgpIHtcbiAgICByZXR1cm4gaCA8IGwgPyB0LmNoYXJDb2RlQXQoaCkgOiAwO1xuICB9XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgaWYgKGkgPSBxcyh0LCBpKSwgTWUobihpKSwgbihpICsgMSksIG4oaSArIDIpKSkge1xuICAgICAgYyA9IEUsIGkgPSBnZSh0LCBpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG4oaSkgPT09IDM3KSB7XG4gICAgICBjID0gRiwgaSsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjID0gYjtcbiAgfVxuICBmdW5jdGlvbiByKCkge1xuICAgIGNvbnN0IGggPSBpO1xuICAgIGlmIChpID0gZ2UodCwgaSksICRlKHQsIGgsIGksIFwidXJsXCIpICYmIG4oaSkgPT09IDQwKSB7XG4gICAgICBpZiAoaSA9IGRlKHQsIGkgKyAxKSwgbihpKSA9PT0gMzQgfHwgbihpKSA9PT0gMzkpIHtcbiAgICAgICAgYyA9IFQsIGkgPSBoICsgNDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobihpKSA9PT0gNDApIHtcbiAgICAgIGMgPSBULCBpKys7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGMgPSBnO1xuICB9XG4gIGZ1bmN0aW9uIG8oaCkge1xuICAgIGZvciAoaCB8fCAoaCA9IG4oaSsrKSksIGMgPSBUdDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGYgPSB0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBzd2l0Y2ggKEJlKGYpKSB7XG4gICAgICAgIC8vIGVuZGluZyBjb2RlIHBvaW50XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgLy8gY2FzZSBFb2ZDYXRlZ29yeTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBhcnNlIGVycm9yLiBSZXR1cm4gdGhlIDxzdHJpbmctdG9rZW4+LlxuICAgICAgICAvLyByZXR1cm47XG4gICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgY2FzZSB5ZTpcbiAgICAgICAgICBpZiAoRWUoZikpIHtcbiAgICAgICAgICAgIGkgKz0gYW4odCwgaSwgZiksIGMgPSB0YTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFUrMDA1QyBSRVZFUlNFIFNPTElEVVMgKFxcKVxuICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgIGlmIChpID09PSB0Lmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBwID0gbihpICsgMSk7XG4gICAgICAgICAgRWUocCkgPyBpICs9IGFuKHQsIGkgKyAxLCBwKSA6IGt0KGYsIHApICYmIChpID0gSnQodCwgaSkgLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYSgpIHtcbiAgICBmb3IgKGMgPSBRLCBpID0gZGUodCwgaSk7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoID0gdC5jaGFyQ29kZUF0KGkpO1xuICAgICAgc3dpdGNoIChCZShoKSkge1xuICAgICAgICAvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG4gICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gRU9GXG4gICAgICAgIC8vIGNhc2UgRW9mQ2F0ZWdvcnk6XG4gICAgICAgIC8vIFRoaXMgaXMgYSBwYXJzZSBlcnJvci4gUmV0dXJuIHRoZSA8dXJsLXRva2VuPi5cbiAgICAgICAgLy8gcmV0dXJuO1xuICAgICAgICAvLyB3aGl0ZXNwYWNlXG4gICAgICAgIGNhc2UgeWU6XG4gICAgICAgICAgaWYgKGkgPSBkZSh0LCBpKSwgbihpKSA9PT0gNDEgfHwgaSA+PSB0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaSA8IHQubGVuZ3RoICYmIGkrKztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSA9IFVlKHQsIGkpLCBjID0gYXQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBVKzAwMjIgUVVPVEFUSU9OIE1BUksgKFwiKVxuICAgICAgICAvLyBVKzAwMjcgQVBPU1RST1BIRSAoJylcbiAgICAgICAgLy8gVSswMDI4IExFRlQgUEFSRU5USEVTSVMgKCgpXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUgY29kZSBwb2ludFxuICAgICAgICBjYXNlIDM0OlxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICBjYXNlIEhzOlxuICAgICAgICAgIGkgPSBVZSh0LCBpKSwgYyA9IGF0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVSswMDVDIFJFVkVSU0UgU09MSURVUyAoXFwpXG4gICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgaWYgKGt0KGgsIG4oaSArIDEpKSkge1xuICAgICAgICAgICAgaSA9IEp0KHQsIGkpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gVWUodCwgaSksIGMgPSBhdDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHQgPSBTdHJpbmcodCB8fCBcIlwiKTtcbiAgY29uc3QgbCA9IHQubGVuZ3RoO1xuICBsZXQgdSA9IHpzKG4oMCkpLCBpID0gdSwgYztcbiAgZm9yICg7IGkgPCBsOyApIHtcbiAgICBjb25zdCBoID0gdC5jaGFyQ29kZUF0KGkpO1xuICAgIHN3aXRjaCAoQmUoaCkpIHtcbiAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgIGNhc2UgeWU6XG4gICAgICAgIGMgPSBXLCBpID0gZGUodCwgaSArIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyMiBRVU9UQVRJT04gTUFSSyAoXCIpXG4gICAgICBjYXNlIDM0OlxuICAgICAgICBvKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gVSswMDIzIE5VTUJFUiBTSUdOICgjKVxuICAgICAgY2FzZSAzNTpcbiAgICAgICAgVXMobihpICsgMSkpIHx8IGt0KG4oaSArIDEpLCBuKGkgKyAyKSkgPyAoYyA9IEksIGkgPSBnZSh0LCBpICsgMSkpIDogKGMgPSBMLCBpKyspO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyNyBBUE9TVFJPUEhFICgnKVxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgbygpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyOCBMRUZUIFBBUkVOVEhFU0lTICgoKVxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgYyA9IF8sIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG4gICAgICBjYXNlIDQxOlxuICAgICAgICBjID0gUywgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyQiBQTFVTIFNJR04gKCspXG4gICAgICBjYXNlIDQzOlxuICAgICAgICBqZShoLCBuKGkgKyAxKSwgbihpICsgMikpID8gcygpIDogKGMgPSBMLCBpKyspO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyQyBDT01NQSAoLClcbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgIGMgPSBmdCwgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyRCBIWVBIRU4tTUlOVVMgKC0pXG4gICAgICBjYXNlIDQ1OlxuICAgICAgICBqZShoLCBuKGkgKyAxKSwgbihpICsgMikpID8gcygpIDogbihpICsgMSkgPT09IDQ1ICYmIG4oaSArIDIpID09PSA2MiA/IChjID0gbnQsIGkgPSBpICsgMykgOiBNZShoLCBuKGkgKyAxKSwgbihpICsgMikpID8gcigpIDogKGMgPSBMLCBpKyspO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyRSBGVUxMIFNUT1AgKC4pXG4gICAgICBjYXNlIDQ2OlxuICAgICAgICBqZShoLCBuKGkgKyAxKSwgbihpICsgMikpID8gcygpIDogKGMgPSBMLCBpKyspO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAyRiBTT0xJRFVTICgvKVxuICAgICAgY2FzZSA0NzpcbiAgICAgICAgbihpICsgMSkgPT09IDQyID8gKGMgPSBZLCBpID0gdC5pbmRleE9mKFwiKi9cIiwgaSArIDIpLCBpID0gaSA9PT0gLTEgPyB0Lmxlbmd0aCA6IGkgKyAyKSA6IChjID0gTCwgaSsrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwM0EgQ09MT04gKDopXG4gICAgICBjYXNlIDU4OlxuICAgICAgICBjID0gWCwgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDAzQiBTRU1JQ09MT04gKDspXG4gICAgICBjYXNlIDU5OlxuICAgICAgICBjID0gdHQsIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwM0MgTEVTUy1USEFOIFNJR04gKDwpXG4gICAgICBjYXNlIDYwOlxuICAgICAgICBuKGkgKyAxKSA9PT0gMzMgJiYgbihpICsgMikgPT09IDQ1ICYmIG4oaSArIDMpID09PSA0NSA/IChjID0gRGUsIGkgPSBpICsgNCkgOiAoYyA9IEwsIGkrKyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gVSswMDQwIENPTU1FUkNJQUwgQVQgKEApXG4gICAgICBjYXNlIDY0OlxuICAgICAgICBNZShuKGkgKyAxKSwgbihpICsgMiksIG4oaSArIDMpKSA/IChjID0geiwgaSA9IGdlKHQsIGkgKyAxKSkgOiAoYyA9IEwsIGkrKyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gVSswMDVCIExFRlQgU1FVQVJFIEJSQUNLRVQgKFspXG4gICAgICBjYXNlIDkxOlxuICAgICAgICBjID0gZWUsIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwNUMgUkVWRVJTRSBTT0xJRFVTIChcXClcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIGt0KGgsIG4oaSArIDEpKSA/IHIoKSA6IChjID0gTCwgaSsrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwNUQgUklHSFQgU1FVQVJFIEJSQUNLRVQgKF0pXG4gICAgICBjYXNlIDkzOlxuICAgICAgICBjID0gY2UsIGkrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVKzAwN0IgTEVGVCBDVVJMWSBCUkFDS0VUICh7KVxuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGMgPSBodCwgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFUrMDA3RCBSSUdIVCBDVVJMWSBCUkFDS0VUICh9KVxuICAgICAgY2FzZSAxMjU6XG4gICAgICAgIGMgPSBZdCwgaSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGRpZ2l0XG4gICAgICBjYXNlIFZzOlxuICAgICAgICBzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbmFtZS1zdGFydCBjb2RlIHBvaW50XG4gICAgICBjYXNlIENuOlxuICAgICAgICByKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRU9GXG4gICAgICAvLyBjYXNlIEVvZkNhdGVnb3J5OlxuICAgICAgLy8gUmV0dXJuIGFuIDxFT0YtdG9rZW4+LlxuICAgICAgLy8gYnJlYWs7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjID0gTCwgaSsrO1xuICAgIH1cbiAgICBlKGMsIHUsIHUgPSBpKTtcbiAgfVxufVxuY29uc3QgbXQgPSA0Mywgc3QgPSA0NSwgYmUgPSAxMTAsIF90ID0gITAsIGZhID0gITE7XG5mdW5jdGlvbiB4ZSh0LCBlKSB7XG4gIGxldCBuID0gdGhpcy50b2tlblN0YXJ0ICsgdDtcbiAgY29uc3QgcyA9IHRoaXMuY2hhckNvZGVBdChuKTtcbiAgZm9yICgocyA9PT0gbXQgfHwgcyA9PT0gc3QpICYmIChlICYmIHRoaXMuZXJyb3IoXCJOdW1iZXIgc2lnbiBpcyBub3QgYWxsb3dlZFwiKSwgbisrKTsgbiA8IHRoaXMudG9rZW5FbmQ7IG4rKylcbiAgICBydCh0aGlzLmNoYXJDb2RlQXQobikpIHx8IHRoaXMuZXJyb3IoXCJJbnRlZ2VyIGlzIGV4cGVjdGVkXCIsIG4pO1xufVxuZnVuY3Rpb24gVnQodCkge1xuICByZXR1cm4geGUuY2FsbCh0aGlzLCAwLCB0KTtcbn1cbmZ1bmN0aW9uIEF0KHQsIGUpIHtcbiAgaWYgKCF0aGlzLmNtcENoYXIodGhpcy50b2tlblN0YXJ0ICsgdCwgZSkpIHtcbiAgICBsZXQgbiA9IFwiXCI7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIGJlOlxuICAgICAgICBuID0gXCJOIGlzIGV4cGVjdGVkXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzdDpcbiAgICAgICAgbiA9IFwiSHlwaGVuTWludXMgaXMgZXhwZWN0ZWRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZXJyb3IobiwgdGhpcy50b2tlblN0YXJ0ICsgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHplKCkge1xuICBsZXQgdCA9IDAsIGUgPSAwLCBuID0gdGhpcy50b2tlblR5cGU7XG4gIGZvciAoOyBuID09PSBXIHx8IG4gPT09IFk7IClcbiAgICBuID0gdGhpcy5sb29rdXBUeXBlKCsrdCk7XG4gIGlmIChuICE9PSBiKVxuICAgIGlmICh0aGlzLmlzRGVsaW0obXQsIHQpIHx8IHRoaXMuaXNEZWxpbShzdCwgdCkpIHtcbiAgICAgIGUgPSB0aGlzLmlzRGVsaW0obXQsIHQpID8gbXQgOiBzdDtcbiAgICAgIGRvXG4gICAgICAgIG4gPSB0aGlzLmxvb2t1cFR5cGUoKyt0KTtcbiAgICAgIHdoaWxlIChuID09PSBXIHx8IG4gPT09IFkpO1xuICAgICAgbiAhPT0gYiAmJiAodGhpcy5za2lwKHQpLCBWdC5jYWxsKHRoaXMsIF90KSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHQgPiAwICYmIHRoaXMuc2tpcCh0KSwgZSA9PT0gMCAmJiAobiA9IHRoaXMuY2hhckNvZGVBdCh0aGlzLnRva2VuU3RhcnQpLCBuICE9PSBtdCAmJiBuICE9PSBzdCAmJiB0aGlzLmVycm9yKFwiTnVtYmVyIHNpZ24gaXMgZXhwZWN0ZWRcIikpLCBWdC5jYWxsKHRoaXMsIGUgIT09IDApLCBlID09PSBzdCA/IFwiLVwiICsgdGhpcy5jb25zdW1lKGIpIDogdGhpcy5jb25zdW1lKGIpO1xufVxuY29uc3QgcGEgPSBcIkFuUGx1c0JcIiwgZGEgPSB7XG4gIGE6IFtTdHJpbmcsIG51bGxdLFxuICBiOiBbU3RyaW5nLCBudWxsXVxufTtcbmZ1bmN0aW9uIFhzKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZSA9IG51bGwsIG4gPSBudWxsO1xuICBpZiAodGhpcy50b2tlblR5cGUgPT09IGIpXG4gICAgVnQuY2FsbCh0aGlzLCBmYSksIG4gPSB0aGlzLmNvbnN1bWUoYik7XG4gIGVsc2UgaWYgKHRoaXMudG9rZW5UeXBlID09PSBnICYmIHRoaXMuY21wQ2hhcih0aGlzLnRva2VuU3RhcnQsIHN0KSlcbiAgICBzd2l0Y2ggKGUgPSBcIi0xXCIsIEF0LmNhbGwodGhpcywgMSwgYmUpLCB0aGlzLnRva2VuRW5kIC0gdGhpcy50b2tlblN0YXJ0KSB7XG4gICAgICAvLyAtblxuICAgICAgLy8gLW4gPHNpZ25lZC1pbnRlZ2VyPlxuICAgICAgLy8gLW4gWycrJyB8ICctJ10gPHNpZ25sZXNzLWludGVnZXI+XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMubmV4dCgpLCBuID0gemUuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyAtbi0gPHNpZ25sZXNzLWludGVnZXI+XG4gICAgICBjYXNlIDM6XG4gICAgICAgIEF0LmNhbGwodGhpcywgMiwgc3QpLCB0aGlzLm5leHQoKSwgdGhpcy5za2lwU0MoKSwgVnQuY2FsbCh0aGlzLCBfdCksIG4gPSBcIi1cIiArIHRoaXMuY29uc3VtZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyA8ZGFzaG5kYXNoZGlnaXQtaWRlbnQ+XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBBdC5jYWxsKHRoaXMsIDIsIHN0KSwgeGUuY2FsbCh0aGlzLCAzLCBfdCksIHRoaXMubmV4dCgpLCBuID0gdGhpcy5zdWJzdHJUb0N1cnNvcih0ICsgMik7XG4gICAgfVxuICBlbHNlIGlmICh0aGlzLnRva2VuVHlwZSA9PT0gZyB8fCB0aGlzLmlzRGVsaW0obXQpICYmIHRoaXMubG9va3VwVHlwZSgxKSA9PT0gZykge1xuICAgIGxldCBzID0gMDtcbiAgICBzd2l0Y2ggKGUgPSBcIjFcIiwgdGhpcy5pc0RlbGltKG10KSAmJiAocyA9IDEsIHRoaXMubmV4dCgpKSwgQXQuY2FsbCh0aGlzLCAwLCBiZSksIHRoaXMudG9rZW5FbmQgLSB0aGlzLnRva2VuU3RhcnQpIHtcbiAgICAgIC8vICcrJz8gblxuICAgICAgLy8gJysnPyBuIDxzaWduZWQtaW50ZWdlcj5cbiAgICAgIC8vICcrJz8gbiBbJysnIHwgJy0nXSA8c2lnbmxlc3MtaW50ZWdlcj5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5uZXh0KCksIG4gPSB6ZS5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vICcrJz8gbi0gPHNpZ25sZXNzLWludGVnZXI+XG4gICAgICBjYXNlIDI6XG4gICAgICAgIEF0LmNhbGwodGhpcywgMSwgc3QpLCB0aGlzLm5leHQoKSwgdGhpcy5za2lwU0MoKSwgVnQuY2FsbCh0aGlzLCBfdCksIG4gPSBcIi1cIiArIHRoaXMuY29uc3VtZShiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyAnKyc/IDxuZGFzaGRpZ2l0LWlkZW50PlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgQXQuY2FsbCh0aGlzLCAxLCBzdCksIHhlLmNhbGwodGhpcywgMiwgX3QpLCB0aGlzLm5leHQoKSwgbiA9IHRoaXMuc3Vic3RyVG9DdXJzb3IodCArIHMgKyAxKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy50b2tlblR5cGUgPT09IEUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5jaGFyQ29kZUF0KHRoaXMudG9rZW5TdGFydCksIHIgPSBzID09PSBtdCB8fCBzID09PSBzdDtcbiAgICBsZXQgbyA9IHRoaXMudG9rZW5TdGFydCArIHI7XG4gICAgZm9yICg7IG8gPCB0aGlzLnRva2VuRW5kICYmIHJ0KHRoaXMuY2hhckNvZGVBdChvKSk7IG8rKylcbiAgICAgIDtcbiAgICBvID09PSB0aGlzLnRva2VuU3RhcnQgKyByICYmIHRoaXMuZXJyb3IoXCJJbnRlZ2VyIGlzIGV4cGVjdGVkXCIsIHRoaXMudG9rZW5TdGFydCArIHIpLCBBdC5jYWxsKHRoaXMsIG8gLSB0aGlzLnRva2VuU3RhcnQsIGJlKSwgZSA9IHRoaXMuc3Vic3RyaW5nKHQsIG8pLCBvICsgMSA9PT0gdGhpcy50b2tlbkVuZCA/ICh0aGlzLm5leHQoKSwgbiA9IHplLmNhbGwodGhpcykpIDogKEF0LmNhbGwodGhpcywgbyAtIHRoaXMudG9rZW5TdGFydCArIDEsIHN0KSwgbyArIDIgPT09IHRoaXMudG9rZW5FbmQgPyAodGhpcy5uZXh0KCksIHRoaXMuc2tpcFNDKCksIFZ0LmNhbGwodGhpcywgX3QpLCBuID0gXCItXCIgKyB0aGlzLmNvbnN1bWUoYikpIDogKHhlLmNhbGwodGhpcywgbyAtIHRoaXMudG9rZW5TdGFydCArIDIsIF90KSwgdGhpcy5uZXh0KCksIG4gPSB0aGlzLnN1YnN0clRvQ3Vyc29yKG8gKyAxKSkpO1xuICB9IGVsc2VcbiAgICB0aGlzLmVycm9yKCk7XG4gIHJldHVybiBlICE9PSBudWxsICYmIGUuY2hhckNvZGVBdCgwKSA9PT0gbXQgJiYgKGUgPSBlLnN1YnN0cigxKSksIG4gIT09IG51bGwgJiYgbi5jaGFyQ29kZUF0KDApID09PSBtdCAmJiAobiA9IG4uc3Vic3RyKDEpKSwge1xuICAgIHR5cGU6IFwiQW5QbHVzQlwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGE6IGUsXG4gICAgYjogblxuICB9O1xufVxuZnVuY3Rpb24gSnModCkge1xuICBpZiAodC5hKSB7XG4gICAgY29uc3QgZSA9IHQuYSA9PT0gXCIrMVwiICYmIFwiblwiIHx8IHQuYSA9PT0gXCIxXCIgJiYgXCJuXCIgfHwgdC5hID09PSBcIi0xXCIgJiYgXCItblwiIHx8IHQuYSArIFwiblwiO1xuICAgIGlmICh0LmIpIHtcbiAgICAgIGNvbnN0IG4gPSB0LmJbMF0gPT09IFwiLVwiIHx8IHQuYlswXSA9PT0gXCIrXCIgPyB0LmIgOiBcIitcIiArIHQuYjtcbiAgICAgIHRoaXMudG9rZW5pemUoZSArIG4pO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy50b2tlbml6ZShlKTtcbiAgfSBlbHNlXG4gICAgdGhpcy50b2tlbml6ZSh0LmIpO1xufVxuY29uc3QgZ2EgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogSnMsXG4gIG5hbWU6IHBhLFxuICBwYXJzZTogWHMsXG4gIHN0cnVjdHVyZTogZGFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBXbigpIHtcbiAgcmV0dXJuIHRoaXMuUmF3KHRoaXMuY29uc3VtZVVudGlsTGVmdEN1cmx5QnJhY2tldE9yU2VtaWNvbG9uLCAhMCk7XG59XG5mdW5jdGlvbiBtYSgpIHtcbiAgZm9yIChsZXQgdCA9IDEsIGU7IGUgPSB0aGlzLmxvb2t1cFR5cGUodCk7IHQrKykge1xuICAgIGlmIChlID09PSBZdClcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoZSA9PT0gaHQgfHwgZSA9PT0geilcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITE7XG59XG5jb25zdCBrYSA9IFwiQXRydWxlXCIsIFNhID0gXCJhdHJ1bGVcIiwgeWEgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgcHJlbHVkZTogW1wiQXRydWxlUHJlbHVkZVwiLCBcIlJhd1wiLCBudWxsXSxcbiAgYmxvY2s6IFtcIkJsb2NrXCIsIG51bGxdXG59O1xuZnVuY3Rpb24gWnModCA9ICExKSB7XG4gIGNvbnN0IGUgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIGxldCBuLCBzLCByID0gbnVsbCwgbyA9IG51bGw7XG4gIHN3aXRjaCAodGhpcy5lYXQoeiksIG4gPSB0aGlzLnN1YnN0clRvQ3Vyc29yKGUgKyAxKSwgcyA9IG4udG9Mb3dlckNhc2UoKSwgdGhpcy5za2lwU0MoKSwgdGhpcy5lb2YgPT09ICExICYmIHRoaXMudG9rZW5UeXBlICE9PSBodCAmJiB0aGlzLnRva2VuVHlwZSAhPT0gdHQgJiYgKHRoaXMucGFyc2VBdHJ1bGVQcmVsdWRlID8gciA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5BdHJ1bGVQcmVsdWRlLmJpbmQodGhpcywgbiwgdCksIFduKSA6IHIgPSBXbi5jYWxsKHRoaXMsIHRoaXMudG9rZW5JbmRleCksIHRoaXMuc2tpcFNDKCkpLCB0aGlzLnRva2VuVHlwZSkge1xuICAgIGNhc2UgdHQ6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaHQ6XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXRydWxlLCBzKSAmJiB0eXBlb2YgdGhpcy5hdHJ1bGVbc10uYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gbyA9IHRoaXMuYXRydWxlW3NdLmJsb2NrLmNhbGwodGhpcywgdCkgOiBvID0gdGhpcy5CbG9jayhtYS5jYWxsKHRoaXMpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJBdHJ1bGVcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oZSwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBuYW1lOiBuLFxuICAgIHByZWx1ZGU6IHIsXG4gICAgYmxvY2s6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyKHQpIHtcbiAgdGhpcy50b2tlbih6LCBcIkBcIiArIHQubmFtZSksIHQucHJlbHVkZSAhPT0gbnVsbCAmJiB0aGlzLm5vZGUodC5wcmVsdWRlKSwgdC5ibG9jayA/IHRoaXMubm9kZSh0LmJsb2NrKSA6IHRoaXMudG9rZW4odHQsIFwiO1wiKTtcbn1cbmNvbnN0IGJhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHRyLFxuICBuYW1lOiBrYSxcbiAgcGFyc2U6IFpzLFxuICBzdHJ1Y3R1cmU6IHlhLFxuICB3YWxrQ29udGV4dDogU2Fcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHhhID0gXCJBdHJ1bGVQcmVsdWRlXCIsIENhID0gXCJhdHJ1bGVQcmVsdWRlXCIsIHdhID0ge1xuICBjaGlsZHJlbjogW1tdXVxufTtcbmZ1bmN0aW9uIGVyKHQpIHtcbiAgbGV0IGUgPSBudWxsO1xuICByZXR1cm4gdCAhPT0gbnVsbCAmJiAodCA9IHQudG9Mb3dlckNhc2UoKSksIHRoaXMuc2tpcFNDKCksIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHJ1bGUsIHQpICYmIHR5cGVvZiB0aGlzLmF0cnVsZVt0XS5wcmVsdWRlID09IFwiZnVuY3Rpb25cIiA/IGUgPSB0aGlzLmF0cnVsZVt0XS5wcmVsdWRlLmNhbGwodGhpcykgOiBlID0gdGhpcy5yZWFkU2VxdWVuY2UodGhpcy5zY29wZS5BdHJ1bGVQcmVsdWRlKSwgdGhpcy5za2lwU0MoKSwgdGhpcy5lb2YgIT09ICEwICYmIHRoaXMudG9rZW5UeXBlICE9PSBodCAmJiB0aGlzLnRva2VuVHlwZSAhPT0gdHQgJiYgdGhpcy5lcnJvcihcIlNlbWljb2xvbiBvciBibG9jayBpcyBleHBlY3RlZFwiKSwge1xuICAgIHR5cGU6IFwiQXRydWxlUHJlbHVkZVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KGUpLFxuICAgIGNoaWxkcmVuOiBlXG4gIH07XG59XG5mdW5jdGlvbiBucih0KSB7XG4gIHRoaXMuY2hpbGRyZW4odCk7XG59XG5jb25zdCBUYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBucixcbiAgbmFtZTogeGEsXG4gIHBhcnNlOiBlcixcbiAgc3RydWN0dXJlOiB3YSxcbiAgd2Fsa0NvbnRleHQ6IENhXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBBYSA9IDM2LCBzciA9IDQyLCBDZSA9IDYxLCB2YSA9IDk0LCBsbiA9IDEyNCwgRWEgPSAxMjY7XG5mdW5jdGlvbiAkYSgpIHtcbiAgdGhpcy5lb2YgJiYgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZSA9ICExO1xuICByZXR1cm4gdGhpcy5pc0RlbGltKHNyKSA/IChlID0gITAsIHRoaXMubmV4dCgpKSA6IHRoaXMuaXNEZWxpbShsbikgfHwgdGhpcy5lYXQoZyksIHRoaXMuaXNEZWxpbShsbikgPyB0aGlzLmNoYXJDb2RlQXQodGhpcy50b2tlblN0YXJ0ICsgMSkgIT09IENlID8gKHRoaXMubmV4dCgpLCB0aGlzLmVhdChnKSkgOiBlICYmIHRoaXMuZXJyb3IoXCJJZGVudGlmaWVyIGlzIGV4cGVjdGVkXCIsIHRoaXMudG9rZW5FbmQpIDogZSAmJiB0aGlzLmVycm9yKFwiVmVydGljYWwgbGluZSBpcyBleHBlY3RlZFwiKSwge1xuICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIG5hbWU6IHRoaXMuc3Vic3RyVG9DdXJzb3IodClcbiAgfTtcbn1cbmZ1bmN0aW9uIExhKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0LCBlID0gdGhpcy5jaGFyQ29kZUF0KHQpO1xuICByZXR1cm4gZSAhPT0gQ2UgJiYgLy8gPVxuICBlICE9PSBFYSAmJiAvLyB+PVxuICBlICE9PSB2YSAmJiAvLyBePVxuICBlICE9PSBBYSAmJiAvLyAkPVxuICBlICE9PSBzciAmJiAvLyAqPVxuICBlICE9PSBsbiAmJiB0aGlzLmVycm9yKFwiQXR0cmlidXRlIHNlbGVjdG9yICg9LCB+PSwgXj0sICQ9LCAqPSwgfD0pIGlzIGV4cGVjdGVkXCIpLCB0aGlzLm5leHQoKSwgZSAhPT0gQ2UgJiYgKHRoaXMuaXNEZWxpbShDZSkgfHwgdGhpcy5lcnJvcihcIkVxdWFsIHNpZ24gaXMgZXhwZWN0ZWRcIiksIHRoaXMubmV4dCgpKSwgdGhpcy5zdWJzdHJUb0N1cnNvcih0KTtcbn1cbmNvbnN0IFBhID0gXCJBdHRyaWJ1dGVTZWxlY3RvclwiLCBPYSA9IHtcbiAgbmFtZTogXCJJZGVudGlmaWVyXCIsXG4gIG1hdGNoZXI6IFtTdHJpbmcsIG51bGxdLFxuICB2YWx1ZTogW1wiU3RyaW5nXCIsIFwiSWRlbnRpZmllclwiLCBudWxsXSxcbiAgZmxhZ3M6IFtTdHJpbmcsIG51bGxdXG59O1xuZnVuY3Rpb24gcnIoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIGxldCBlLCBuID0gbnVsbCwgcyA9IG51bGwsIHIgPSBudWxsO1xuICByZXR1cm4gdGhpcy5lYXQoZWUpLCB0aGlzLnNraXBTQygpLCBlID0gJGEuY2FsbCh0aGlzKSwgdGhpcy5za2lwU0MoKSwgdGhpcy50b2tlblR5cGUgIT09IGNlICYmICh0aGlzLnRva2VuVHlwZSAhPT0gZyAmJiAobiA9IExhLmNhbGwodGhpcyksIHRoaXMuc2tpcFNDKCksIHMgPSB0aGlzLnRva2VuVHlwZSA9PT0gVHQgPyB0aGlzLlN0cmluZygpIDogdGhpcy5JZGVudGlmaWVyKCksIHRoaXMuc2tpcFNDKCkpLCB0aGlzLnRva2VuVHlwZSA9PT0gZyAmJiAociA9IHRoaXMuY29uc3VtZShnKSwgdGhpcy5za2lwU0MoKSkpLCB0aGlzLmVhdChjZSksIHtcbiAgICB0eXBlOiBcIkF0dHJpYnV0ZVNlbGVjdG9yXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgbmFtZTogZSxcbiAgICBtYXRjaGVyOiBuLFxuICAgIHZhbHVlOiBzLFxuICAgIGZsYWdzOiByXG4gIH07XG59XG5mdW5jdGlvbiBpcih0KSB7XG4gIHRoaXMudG9rZW4oTCwgXCJbXCIpLCB0aGlzLm5vZGUodC5uYW1lKSwgdC5tYXRjaGVyICE9PSBudWxsICYmICh0aGlzLnRva2VuaXplKHQubWF0Y2hlciksIHRoaXMubm9kZSh0LnZhbHVlKSksIHQuZmxhZ3MgIT09IG51bGwgJiYgdGhpcy50b2tlbihnLCB0LmZsYWdzKSwgdGhpcy50b2tlbihMLCBcIl1cIik7XG59XG5jb25zdCBSYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBpcixcbiAgbmFtZTogUGEsXG4gIHBhcnNlOiBycixcbiAgc3RydWN0dXJlOiBPYVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgX2EgPSAzODtcbmZ1bmN0aW9uIG9yKCkge1xuICByZXR1cm4gdGhpcy5SYXcobnVsbCwgITApO1xufVxuZnVuY3Rpb24gVW4oKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlV2l0aEZhbGxiYWNrKHRoaXMuUnVsZSwgb3IpO1xufVxuZnVuY3Rpb24gem4oKSB7XG4gIHJldHVybiB0aGlzLlJhdyh0aGlzLmNvbnN1bWVVbnRpbFNlbWljb2xvbkluY2x1ZGVkLCAhMCk7XG59XG5mdW5jdGlvbiBJYSgpIHtcbiAgaWYgKHRoaXMudG9rZW5UeXBlID09PSB0dClcbiAgICByZXR1cm4gem4uY2FsbCh0aGlzLCB0aGlzLnRva2VuSW5kZXgpO1xuICBjb25zdCB0ID0gdGhpcy5wYXJzZVdpdGhGYWxsYmFjayh0aGlzLkRlY2xhcmF0aW9uLCB6bik7XG4gIHJldHVybiB0aGlzLnRva2VuVHlwZSA9PT0gdHQgJiYgdGhpcy5uZXh0KCksIHQ7XG59XG5jb25zdCBOYSA9IFwiQmxvY2tcIiwgRGEgPSBcImJsb2NrXCIsIEZhID0ge1xuICBjaGlsZHJlbjogW1tcbiAgICBcIkF0cnVsZVwiLFxuICAgIFwiUnVsZVwiLFxuICAgIFwiRGVjbGFyYXRpb25cIlxuICBdXVxufTtcbmZ1bmN0aW9uIGFyKHQpIHtcbiAgY29uc3QgZSA9IHQgPyBJYSA6IFVuLCBuID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgcyA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICB0aGlzLmVhdChodCk7XG4gIHQ6XG4gICAgZm9yICg7ICF0aGlzLmVvZjsgKVxuICAgICAgc3dpdGNoICh0aGlzLnRva2VuVHlwZSkge1xuICAgICAgICBjYXNlIFl0OlxuICAgICAgICAgIGJyZWFrIHQ7XG4gICAgICAgIGNhc2UgVzpcbiAgICAgICAgY2FzZSBZOlxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgcy5wdXNoKHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5BdHJ1bGUuYmluZCh0aGlzLCB0KSwgb3IpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0ICYmIHRoaXMuaXNEZWxpbShfYSkgPyBzLnB1c2goVW4uY2FsbCh0aGlzKSkgOiBzLnB1c2goZS5jYWxsKHRoaXMpKTtcbiAgICAgIH1cbiAgcmV0dXJuIHRoaXMuZW9mIHx8IHRoaXMuZWF0KFl0KSwge1xuICAgIHR5cGU6IFwiQmxvY2tcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24obiwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBjaGlsZHJlbjogc1xuICB9O1xufVxuZnVuY3Rpb24gbHIodCkge1xuICB0aGlzLnRva2VuKGh0LCBcIntcIiksIHRoaXMuY2hpbGRyZW4odCwgKGUpID0+IHtcbiAgICBlLnR5cGUgPT09IFwiRGVjbGFyYXRpb25cIiAmJiB0aGlzLnRva2VuKHR0LCBcIjtcIik7XG4gIH0pLCB0aGlzLnRva2VuKFl0LCBcIn1cIik7XG59XG5jb25zdCBNYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBscixcbiAgbmFtZTogTmEsXG4gIHBhcnNlOiBhcixcbiAgc3RydWN0dXJlOiBGYSxcbiAgd2Fsa0NvbnRleHQ6IERhXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBqYSA9IFwiQnJhY2tldHNcIiwgQmEgPSB7XG4gIGNoaWxkcmVuOiBbW11dXG59O1xuZnVuY3Rpb24gY3IodCwgZSkge1xuICBjb25zdCBuID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgcyA9IG51bGw7XG4gIHJldHVybiB0aGlzLmVhdChlZSksIHMgPSB0LmNhbGwodGhpcywgZSksIHRoaXMuZW9mIHx8IHRoaXMuZWF0KGNlKSwge1xuICAgIHR5cGU6IFwiQnJhY2tldHNcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24obiwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBjaGlsZHJlbjogc1xuICB9O1xufVxuZnVuY3Rpb24gdXIodCkge1xuICB0aGlzLnRva2VuKEwsIFwiW1wiKSwgdGhpcy5jaGlsZHJlbih0KSwgdGhpcy50b2tlbihMLCBcIl1cIik7XG59XG5jb25zdCBXYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiB1cixcbiAgbmFtZTogamEsXG4gIHBhcnNlOiBjcixcbiAgc3RydWN0dXJlOiBCYVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgVWEgPSBcIkNEQ1wiLCB6YSA9IFtdO1xuZnVuY3Rpb24gaHIoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLmVhdChudCksIHtcbiAgICB0eXBlOiBcIkNEQ1wiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpXG4gIH07XG59XG5mdW5jdGlvbiBmcigpIHtcbiAgdGhpcy50b2tlbihudCwgXCItLT5cIik7XG59XG5jb25zdCBWYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBmcixcbiAgbmFtZTogVWEsXG4gIHBhcnNlOiBocixcbiAgc3RydWN0dXJlOiB6YVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgSGEgPSBcIkNET1wiLCBHYSA9IFtdO1xuZnVuY3Rpb24gcHIoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLmVhdChEZSksIHtcbiAgICB0eXBlOiBcIkNET1wiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpXG4gIH07XG59XG5mdW5jdGlvbiBkcigpIHtcbiAgdGhpcy50b2tlbihEZSwgXCI8IS0tXCIpO1xufVxuY29uc3QgcWEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogZHIsXG4gIG5hbWU6IEhhLFxuICBwYXJzZTogcHIsXG4gIHN0cnVjdHVyZTogR2Fcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEthID0gNDYsIFFhID0gXCJDbGFzc1NlbGVjdG9yXCIsIFlhID0ge1xuICBuYW1lOiBTdHJpbmdcbn07XG5mdW5jdGlvbiBncigpIHtcbiAgcmV0dXJuIHRoaXMuZWF0RGVsaW0oS2EpLCB7XG4gICAgdHlwZTogXCJDbGFzc1NlbGVjdG9yXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHRoaXMudG9rZW5TdGFydCAtIDEsIHRoaXMudG9rZW5FbmQpLFxuICAgIG5hbWU6IHRoaXMuY29uc3VtZShnKVxuICB9O1xufVxuZnVuY3Rpb24gbXIodCkge1xuICB0aGlzLnRva2VuKEwsIFwiLlwiKSwgdGhpcy50b2tlbihnLCB0Lm5hbWUpO1xufVxuY29uc3QgWGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogbXIsXG4gIG5hbWU6IFFhLFxuICBwYXJzZTogZ3IsXG4gIHN0cnVjdHVyZTogWWFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEphID0gNDMsIFZuID0gNDcsIFphID0gNjIsIHRsID0gMTI2LCBlbCA9IFwiQ29tYmluYXRvclwiLCBubCA9IHtcbiAgbmFtZTogU3RyaW5nXG59O1xuZnVuY3Rpb24ga3IoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIGxldCBlO1xuICBzd2l0Y2ggKHRoaXMudG9rZW5UeXBlKSB7XG4gICAgY2FzZSBXOlxuICAgICAgZSA9IFwiIFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMOlxuICAgICAgc3dpdGNoICh0aGlzLmNoYXJDb2RlQXQodGhpcy50b2tlblN0YXJ0KSkge1xuICAgICAgICBjYXNlIFphOlxuICAgICAgICBjYXNlIEphOlxuICAgICAgICBjYXNlIHRsOlxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZuOlxuICAgICAgICAgIHRoaXMubmV4dCgpLCB0aGlzLmVhdElkZW50KFwiZGVlcFwiKSwgdGhpcy5lYXREZWxpbShWbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5lcnJvcihcIkNvbWJpbmF0b3IgaXMgZXhwZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICBlID0gdGhpcy5zdWJzdHJUb0N1cnNvcih0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJDb21iaW5hdG9yXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgbmFtZTogZVxuICB9O1xufVxuZnVuY3Rpb24gU3IodCkge1xuICB0aGlzLnRva2VuaXplKHQubmFtZSk7XG59XG5jb25zdCBzbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBTcixcbiAgbmFtZTogZWwsXG4gIHBhcnNlOiBrcixcbiAgc3RydWN0dXJlOiBubFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgcmwgPSA0MiwgaWwgPSA0Nywgb2wgPSBcIkNvbW1lbnRcIiwgYWwgPSB7XG4gIHZhbHVlOiBTdHJpbmdcbn07XG5mdW5jdGlvbiB5cigpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydDtcbiAgbGV0IGUgPSB0aGlzLnRva2VuRW5kO1xuICByZXR1cm4gdGhpcy5lYXQoWSksIGUgLSB0ICsgMiA+PSAyICYmIHRoaXMuY2hhckNvZGVBdChlIC0gMikgPT09IHJsICYmIHRoaXMuY2hhckNvZGVBdChlIC0gMSkgPT09IGlsICYmIChlIC09IDIpLCB7XG4gICAgdHlwZTogXCJDb21tZW50XCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgdmFsdWU6IHRoaXMuc3Vic3RyaW5nKHQgKyAyLCBlKVxuICB9O1xufVxuZnVuY3Rpb24gYnIodCkge1xuICB0aGlzLnRva2VuKFksIFwiLypcIiArIHQudmFsdWUgKyBcIiovXCIpO1xufVxuY29uc3QgbGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogYnIsXG4gIG5hbWU6IG9sLFxuICBwYXJzZTogeXIsXG4gIHN0cnVjdHVyZTogYWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGNsID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1gsIFMsIHZ0XSksIHVsID0gXCJDb25kaXRpb25cIiwgaGwgPSB7XG4gIGtpbmQ6IFN0cmluZyxcbiAgY2hpbGRyZW46IFtbXG4gICAgXCJJZGVudGlmaWVyXCIsXG4gICAgXCJGZWF0dXJlXCIsXG4gICAgXCJGZWF0dXJlRnVuY3Rpb25cIixcbiAgICBcIkZlYXR1cmVSYW5nZVwiLFxuICAgIFwiU3VwcG9ydHNEZWNsYXJhdGlvblwiXG4gIF1dXG59O1xuZnVuY3Rpb24gSG4odCkge1xuICByZXR1cm4gdGhpcy5sb29rdXBUeXBlTm9uU0MoMSkgPT09IGcgJiYgY2wuaGFzKHRoaXMubG9va3VwVHlwZU5vblNDKDIpKSA/IHRoaXMuRmVhdHVyZSh0KSA6IHRoaXMuRmVhdHVyZVJhbmdlKHQpO1xufVxuY29uc3QgZmwgPSB7XG4gIG1lZGlhOiBIbixcbiAgY29udGFpbmVyOiBIbixcbiAgc3VwcG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuU3VwcG9ydHNEZWNsYXJhdGlvbigpO1xuICB9XG59O1xuZnVuY3Rpb24geHIodCA9IFwibWVkaWFcIikge1xuICBjb25zdCBlID0gdGhpcy5jcmVhdGVMaXN0KCk7XG4gIHQ6IGZvciAoOyAhdGhpcy5lb2Y7IClcbiAgICBzd2l0Y2ggKHRoaXMudG9rZW5UeXBlKSB7XG4gICAgICBjYXNlIFk6XG4gICAgICBjYXNlIFc6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgZS5wdXNoKHRoaXMuSWRlbnRpZmllcigpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF86IHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLnBhcnNlV2l0aEZhbGxiYWNrKFxuICAgICAgICAgICgpID0+IGZsW3RdLmNhbGwodGhpcywgdCksXG4gICAgICAgICAgKCkgPT4gbnVsbFxuICAgICAgICApO1xuICAgICAgICBuIHx8IChuID0gdGhpcy5wYXJzZVdpdGhGYWxsYmFjayhcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVhdChfKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLkNvbmRpdGlvbih0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhdChTKSwgcztcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHRoaXMuR2VuZXJhbEVuY2xvc2VkKHQpXG4gICAgICAgICkpLCBlLnB1c2gobik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUOiB7XG4gICAgICAgIGxldCBuID0gdGhpcy5wYXJzZVdpdGhGYWxsYmFjayhcbiAgICAgICAgICAoKSA9PiB0aGlzLkZlYXR1cmVGdW5jdGlvbih0KSxcbiAgICAgICAgICAoKSA9PiBudWxsXG4gICAgICAgICk7XG4gICAgICAgIG4gfHwgKG4gPSB0aGlzLkdlbmVyYWxFbmNsb3NlZCh0KSksIGUucHVzaChuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhayB0O1xuICAgIH1cbiAgcmV0dXJuIGUuaXNFbXB0eSAmJiB0aGlzLmVycm9yKFwiQ29uZGl0aW9uIGlzIGV4cGVjdGVkXCIpLCB7XG4gICAgdHlwZTogXCJDb25kaXRpb25cIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb25Gcm9tTGlzdChlKSxcbiAgICBraW5kOiB0LFxuICAgIGNoaWxkcmVuOiBlXG4gIH07XG59XG5mdW5jdGlvbiBDcih0KSB7XG4gIHQuY2hpbGRyZW4uZm9yRWFjaCgoZSkgPT4ge1xuICAgIGUudHlwZSA9PT0gXCJDb25kaXRpb25cIiA/ICh0aGlzLnRva2VuKF8sIFwiKFwiKSwgdGhpcy5ub2RlKGUpLCB0aGlzLnRva2VuKFMsIFwiKVwiKSkgOiB0aGlzLm5vZGUoZSk7XG4gIH0pO1xufVxuY29uc3QgcGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogQ3IsXG4gIG5hbWU6IHVsLFxuICBwYXJzZTogeHIsXG4gIHN0cnVjdHVyZTogaGxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEduID0gNDU7XG5mdW5jdGlvbiBkbCh0LCBlKSB7XG4gIHJldHVybiBlID0gZSB8fCAwLCB0Lmxlbmd0aCAtIGUgPj0gMiAmJiB0LmNoYXJDb2RlQXQoZSkgPT09IEduICYmIHQuY2hhckNvZGVBdChlICsgMSkgPT09IEduO1xufVxuY29uc3Qgd3IgPSAzMywgZ2wgPSAzNSwgbWwgPSAzNiwga2wgPSAzOCwgU2wgPSA0MiwgeWwgPSA0MywgcW4gPSA0NztcbmZ1bmN0aW9uIGJsKCkge1xuICByZXR1cm4gdGhpcy5SYXcodGhpcy5jb25zdW1lVW50aWxFeGNsYW1hdGlvbk1hcmtPclNlbWljb2xvbiwgITApO1xufVxuZnVuY3Rpb24geGwoKSB7XG4gIHJldHVybiB0aGlzLlJhdyh0aGlzLmNvbnN1bWVVbnRpbEV4Y2xhbWF0aW9uTWFya09yU2VtaWNvbG9uLCAhMSk7XG59XG5mdW5jdGlvbiBDbCgpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5JbmRleCwgZSA9IHRoaXMuVmFsdWUoKTtcbiAgcmV0dXJuIGUudHlwZSAhPT0gXCJSYXdcIiAmJiB0aGlzLmVvZiA9PT0gITEgJiYgdGhpcy50b2tlblR5cGUgIT09IHR0ICYmIHRoaXMuaXNEZWxpbSh3cikgPT09ICExICYmIHRoaXMuaXNCYWxhbmNlRWRnZSh0KSA9PT0gITEgJiYgdGhpcy5lcnJvcigpLCBlO1xufVxuY29uc3Qgd2wgPSBcIkRlY2xhcmF0aW9uXCIsIFRsID0gXCJkZWNsYXJhdGlvblwiLCBBbCA9IHtcbiAgaW1wb3J0YW50OiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgcHJvcGVydHk6IFN0cmluZyxcbiAgdmFsdWU6IFtcIlZhbHVlXCIsIFwiUmF3XCJdXG59O1xuZnVuY3Rpb24gVHIoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQsIGUgPSB0aGlzLnRva2VuSW5kZXgsIG4gPSB2bC5jYWxsKHRoaXMpLCBzID0gZGwobiksIHIgPSBzID8gdGhpcy5wYXJzZUN1c3RvbVByb3BlcnR5IDogdGhpcy5wYXJzZVZhbHVlLCBvID0gcyA/IHhsIDogYmw7XG4gIGxldCBhID0gITEsIGw7XG4gIHRoaXMuc2tpcFNDKCksIHRoaXMuZWF0KFgpO1xuICBjb25zdCB1ID0gdGhpcy50b2tlbkluZGV4O1xuICBpZiAocyB8fCB0aGlzLnNraXBTQygpLCByID8gbCA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2soQ2wsIG8pIDogbCA9IG8uY2FsbCh0aGlzLCB0aGlzLnRva2VuSW5kZXgpLCBzICYmIGwudHlwZSA9PT0gXCJWYWx1ZVwiICYmIGwuY2hpbGRyZW4uaXNFbXB0eSkge1xuICAgIGZvciAobGV0IGkgPSB1IC0gdGhpcy50b2tlbkluZGV4OyBpIDw9IDA7IGkrKylcbiAgICAgIGlmICh0aGlzLmxvb2t1cFR5cGUoaSkgPT09IFcpIHtcbiAgICAgICAgbC5jaGlsZHJlbi5hcHBlbmREYXRhKHtcbiAgICAgICAgICB0eXBlOiBcIldoaXRlU3BhY2VcIixcbiAgICAgICAgICBsb2M6IG51bGwsXG4gICAgICAgICAgdmFsdWU6IFwiIFwiXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5pc0RlbGltKHdyKSAmJiAoYSA9IEVsLmNhbGwodGhpcyksIHRoaXMuc2tpcFNDKCkpLCB0aGlzLmVvZiA9PT0gITEgJiYgdGhpcy50b2tlblR5cGUgIT09IHR0ICYmIHRoaXMuaXNCYWxhbmNlRWRnZShlKSA9PT0gITEgJiYgdGhpcy5lcnJvcigpLCB7XG4gICAgdHlwZTogXCJEZWNsYXJhdGlvblwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGltcG9ydGFudDogYSxcbiAgICBwcm9wZXJ0eTogbixcbiAgICB2YWx1ZTogbFxuICB9O1xufVxuZnVuY3Rpb24gQXIodCkge1xuICB0aGlzLnRva2VuKGcsIHQucHJvcGVydHkpLCB0aGlzLnRva2VuKFgsIFwiOlwiKSwgdGhpcy5ub2RlKHQudmFsdWUpLCB0LmltcG9ydGFudCAmJiAodGhpcy50b2tlbihMLCBcIiFcIiksIHRoaXMudG9rZW4oZywgdC5pbXBvcnRhbnQgPT09ICEwID8gXCJpbXBvcnRhbnRcIiA6IHQuaW1wb3J0YW50KSk7XG59XG5mdW5jdGlvbiB2bCgpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydDtcbiAgaWYgKHRoaXMudG9rZW5UeXBlID09PSBMKVxuICAgIHN3aXRjaCAodGhpcy5jaGFyQ29kZUF0KHRoaXMudG9rZW5TdGFydCkpIHtcbiAgICAgIGNhc2UgU2w6XG4gICAgICBjYXNlIG1sOlxuICAgICAgY2FzZSB5bDpcbiAgICAgIGNhc2UgZ2w6XG4gICAgICBjYXNlIGtsOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBUT0RPOiBub3Qgc3VyZSB3ZSBzaG91bGQgc3VwcG9ydCB0aGlzIGhhY2tcbiAgICAgIGNhc2UgcW46XG4gICAgICAgIHRoaXMubmV4dCgpLCB0aGlzLmlzRGVsaW0ocW4pICYmIHRoaXMubmV4dCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiB0aGlzLnRva2VuVHlwZSA9PT0gSSA/IHRoaXMuZWF0KEkpIDogdGhpcy5lYXQoZyksIHRoaXMuc3Vic3RyVG9DdXJzb3IodCk7XG59XG5mdW5jdGlvbiBFbCgpIHtcbiAgdGhpcy5lYXQoTCksIHRoaXMuc2tpcFNDKCk7XG4gIGNvbnN0IHQgPSB0aGlzLmNvbnN1bWUoZyk7XG4gIHJldHVybiB0ID09PSBcImltcG9ydGFudFwiID8gITAgOiB0O1xufVxuY29uc3QgJGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogQXIsXG4gIG5hbWU6IHdsLFxuICBwYXJzZTogVHIsXG4gIHN0cnVjdHVyZTogQWwsXG4gIHdhbGtDb250ZXh0OiBUbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgTGwgPSAzODtcbmZ1bmN0aW9uIFZlKCkge1xuICByZXR1cm4gdGhpcy5SYXcodGhpcy5jb25zdW1lVW50aWxTZW1pY29sb25JbmNsdWRlZCwgITApO1xufVxuY29uc3QgUGwgPSBcIkRlY2xhcmF0aW9uTGlzdFwiLCBPbCA9IHtcbiAgY2hpbGRyZW46IFtbXG4gICAgXCJEZWNsYXJhdGlvblwiLFxuICAgIFwiQXRydWxlXCIsXG4gICAgXCJSdWxlXCJcbiAgXV1cbn07XG5mdW5jdGlvbiB2cigpIHtcbiAgY29uc3QgdCA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICBmb3IgKDsgIXRoaXMuZW9mOyApXG4gICAgc3dpdGNoICh0aGlzLnRva2VuVHlwZSkge1xuICAgICAgY2FzZSBXOlxuICAgICAgY2FzZSBZOlxuICAgICAgY2FzZSB0dDpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0LnB1c2godGhpcy5wYXJzZVdpdGhGYWxsYmFjayh0aGlzLkF0cnVsZS5iaW5kKHRoaXMsICEwKSwgVmUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmlzRGVsaW0oTGwpID8gdC5wdXNoKHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5SdWxlLCBWZSkpIDogdC5wdXNoKHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5EZWNsYXJhdGlvbiwgVmUpKTtcbiAgICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJEZWNsYXJhdGlvbkxpc3RcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb25Gcm9tTGlzdCh0KSxcbiAgICBjaGlsZHJlbjogdFxuICB9O1xufVxuZnVuY3Rpb24gRXIodCkge1xuICB0aGlzLmNoaWxkcmVuKHQsIChlKSA9PiB7XG4gICAgZS50eXBlID09PSBcIkRlY2xhcmF0aW9uXCIgJiYgdGhpcy50b2tlbih0dCwgXCI7XCIpO1xuICB9KTtcbn1cbmNvbnN0IFJsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IEVyLFxuICBuYW1lOiBQbCxcbiAgcGFyc2U6IHZyLFxuICBzdHJ1Y3R1cmU6IE9sXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBfbCA9IFwiRGltZW5zaW9uXCIsIElsID0ge1xuICB2YWx1ZTogU3RyaW5nLFxuICB1bml0OiBTdHJpbmdcbn07XG5mdW5jdGlvbiAkcigpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydCwgZSA9IHRoaXMuY29uc3VtZU51bWJlcihFKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkRpbWVuc2lvblwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIHZhbHVlOiBlLFxuICAgIHVuaXQ6IHRoaXMuc3Vic3RyaW5nKHQgKyBlLmxlbmd0aCwgdGhpcy50b2tlblN0YXJ0KVxuICB9O1xufVxuZnVuY3Rpb24gTHIodCkge1xuICB0aGlzLnRva2VuKEUsIHQudmFsdWUgKyB0LnVuaXQpO1xufVxuY29uc3QgTmwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogTHIsXG4gIG5hbWU6IF9sLFxuICBwYXJzZTogJHIsXG4gIHN0cnVjdHVyZTogSWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIERsID0gNDcsIEZsID0gXCJGZWF0dXJlXCIsIE1sID0ge1xuICBraW5kOiBTdHJpbmcsXG4gIG5hbWU6IFN0cmluZyxcbiAgdmFsdWU6IFtcIklkZW50aWZpZXJcIiwgXCJOdW1iZXJcIiwgXCJEaW1lbnNpb25cIiwgXCJSYXRpb1wiLCBcIkZ1bmN0aW9uXCIsIG51bGxdXG59O1xuZnVuY3Rpb24gUHIodCkge1xuICBjb25zdCBlID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgbiwgcyA9IG51bGw7XG4gIGlmICh0aGlzLmVhdChfKSwgdGhpcy5za2lwU0MoKSwgbiA9IHRoaXMuY29uc3VtZShnKSwgdGhpcy5za2lwU0MoKSwgdGhpcy50b2tlblR5cGUgIT09IFMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZWF0KFgpLCB0aGlzLnNraXBTQygpLCB0aGlzLnRva2VuVHlwZSkge1xuICAgICAgY2FzZSBiOlxuICAgICAgICB0aGlzLmxvb2t1cE5vbldTVHlwZSgxKSA9PT0gTCA/IHMgPSB0aGlzLlJhdGlvKCkgOiBzID0gdGhpcy5OdW1iZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEU6XG4gICAgICAgIHMgPSB0aGlzLkRpbWVuc2lvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgcyA9IHRoaXMuSWRlbnRpZmllcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVDpcbiAgICAgICAgcyA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2soXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuRnVuY3Rpb24odGhpcy5yZWFkU2VxdWVuY2UsIHRoaXMuc2NvcGUuVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tpcFNDKCksIHRoaXMuaXNEZWxpbShEbCkgJiYgdGhpcy5lcnJvcigpLCByO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5SYXRpbygpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5lcnJvcihcIk51bWJlciwgZGltZW5zaW9uLCByYXRpbyBvciBpZGVudGlmaWVyIGlzIGV4cGVjdGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLnNraXBTQygpO1xuICB9XG4gIHJldHVybiB0aGlzLmVvZiB8fCB0aGlzLmVhdChTKSwge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihlLCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGtpbmQ6IHQsXG4gICAgbmFtZTogbixcbiAgICB2YWx1ZTogc1xuICB9O1xufVxuZnVuY3Rpb24gT3IodCkge1xuICB0aGlzLnRva2VuKF8sIFwiKFwiKSwgdGhpcy50b2tlbihnLCB0Lm5hbWUpLCB0LnZhbHVlICE9PSBudWxsICYmICh0aGlzLnRva2VuKFgsIFwiOlwiKSwgdGhpcy5ub2RlKHQudmFsdWUpKSwgdGhpcy50b2tlbihTLCBcIilcIik7XG59XG5jb25zdCBqbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBPcixcbiAgbmFtZTogRmwsXG4gIHBhcnNlOiBQcixcbiAgc3RydWN0dXJlOiBNbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgQmwgPSBcIkZlYXR1cmVGdW5jdGlvblwiLCBXbCA9IHtcbiAga2luZDogU3RyaW5nLFxuICBmZWF0dXJlOiBTdHJpbmcsXG4gIHZhbHVlOiBbXCJEZWNsYXJhdGlvblwiLCBcIlNlbGVjdG9yXCJdXG59O1xuZnVuY3Rpb24gVWwodCwgZSkge1xuICBjb25zdCBzID0gKHRoaXMuZmVhdHVyZXNbdF0gfHwge30pW2VdO1xuICByZXR1cm4gdHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHRoaXMuZXJyb3IoYFVua25vd24gZmVhdHVyZSAke2V9KClgKSwgcztcbn1cbmZ1bmN0aW9uIFJyKHQgPSBcInVua25vd25cIikge1xuICBjb25zdCBlID0gdGhpcy50b2tlblN0YXJ0LCBuID0gdGhpcy5jb25zdW1lRnVuY3Rpb25OYW1lKCksIHMgPSBVbC5jYWxsKHRoaXMsIHQsIG4udG9Mb3dlckNhc2UoKSk7XG4gIHRoaXMuc2tpcFNDKCk7XG4gIGNvbnN0IHIgPSB0aGlzLnBhcnNlV2l0aEZhbGxiYWNrKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnRva2VuSW5kZXgsIGEgPSBzLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5lb2YgPT09ICExICYmIHRoaXMuaXNCYWxhbmNlRWRnZShvKSA9PT0gITEgJiYgdGhpcy5lcnJvcigpLCBhO1xuICAgIH0sXG4gICAgKCkgPT4gdGhpcy5SYXcobnVsbCwgITEpXG4gICk7XG4gIHJldHVybiB0aGlzLmVvZiB8fCB0aGlzLmVhdChTKSwge1xuICAgIHR5cGU6IFwiRmVhdHVyZUZ1bmN0aW9uXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKGUsIHRoaXMudG9rZW5TdGFydCksXG4gICAga2luZDogdCxcbiAgICBmZWF0dXJlOiBuLFxuICAgIHZhbHVlOiByXG4gIH07XG59XG5mdW5jdGlvbiBfcih0KSB7XG4gIHRoaXMudG9rZW4oVCwgdC5mZWF0dXJlICsgXCIoXCIpLCB0aGlzLm5vZGUodC52YWx1ZSksIHRoaXMudG9rZW4oUywgXCIpXCIpO1xufVxuY29uc3QgemwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogX3IsXG4gIG5hbWU6IEJsLFxuICBwYXJzZTogUnIsXG4gIHN0cnVjdHVyZTogV2xcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEtuID0gNDcsIFZsID0gNjAsIFFuID0gNjEsIEhsID0gNjIsIEdsID0gXCJGZWF0dXJlUmFuZ2VcIiwgcWwgPSB7XG4gIGtpbmQ6IFN0cmluZyxcbiAgbGVmdDogW1wiSWRlbnRpZmllclwiLCBcIk51bWJlclwiLCBcIkRpbWVuc2lvblwiLCBcIlJhdGlvXCIsIFwiRnVuY3Rpb25cIl0sXG4gIGxlZnRDb21wYXJpc29uOiBTdHJpbmcsXG4gIG1pZGRsZTogW1wiSWRlbnRpZmllclwiLCBcIk51bWJlclwiLCBcIkRpbWVuc2lvblwiLCBcIlJhdGlvXCIsIFwiRnVuY3Rpb25cIl0sXG4gIHJpZ2h0Q29tcGFyaXNvbjogW1N0cmluZywgbnVsbF0sXG4gIHJpZ2h0OiBbXCJJZGVudGlmaWVyXCIsIFwiTnVtYmVyXCIsIFwiRGltZW5zaW9uXCIsIFwiUmF0aW9cIiwgXCJGdW5jdGlvblwiLCBudWxsXVxufTtcbmZ1bmN0aW9uIEhlKCkge1xuICBzd2l0Y2ggKHRoaXMuc2tpcFNDKCksIHRoaXMudG9rZW5UeXBlKSB7XG4gICAgY2FzZSBiOlxuICAgICAgcmV0dXJuIHRoaXMuaXNEZWxpbShLbiwgdGhpcy5sb29rdXBPZmZzZXROb25TQygxKSkgPyB0aGlzLlJhdGlvKCkgOiB0aGlzLk51bWJlcigpO1xuICAgIGNhc2UgRTpcbiAgICAgIHJldHVybiB0aGlzLkRpbWVuc2lvbigpO1xuICAgIGNhc2UgZzpcbiAgICAgIHJldHVybiB0aGlzLklkZW50aWZpZXIoKTtcbiAgICBjYXNlIFQ6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVdpdGhGYWxsYmFjayhcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLkZ1bmN0aW9uKHRoaXMucmVhZFNlcXVlbmNlLCB0aGlzLnNjb3BlLlZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5za2lwU0MoKSwgdGhpcy5pc0RlbGltKEtuKSAmJiB0aGlzLmVycm9yKCksIHQ7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHRoaXMuUmF0aW8oKVxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5lcnJvcihcIk51bWJlciwgZGltZW5zaW9uLCByYXRpbyBvciBpZGVudGlmaWVyIGlzIGV4cGVjdGVkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBZbih0KSB7XG4gIGlmICh0aGlzLnNraXBTQygpLCB0aGlzLmlzRGVsaW0oVmwpIHx8IHRoaXMuaXNEZWxpbShIbCkpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zb3VyY2VbdGhpcy50b2tlblN0YXJ0XTtcbiAgICByZXR1cm4gdGhpcy5uZXh0KCksIHRoaXMuaXNEZWxpbShRbikgPyAodGhpcy5uZXh0KCksIGUgKyBcIj1cIikgOiBlO1xuICB9XG4gIGlmICh0aGlzLmlzRGVsaW0oUW4pKVxuICAgIHJldHVybiBcIj1cIjtcbiAgdGhpcy5lcnJvcihgRXhwZWN0ZWQgJHt0ID8gJ1wiOlwiLCAnIDogXCJcIn1cIjxcIiwgXCI+XCIsIFwiPVwiIG9yIFwiKVwiYCk7XG59XG5mdW5jdGlvbiBJcih0ID0gXCJ1bmtub3duXCIpIHtcbiAgY29uc3QgZSA9IHRoaXMudG9rZW5TdGFydDtcbiAgdGhpcy5za2lwU0MoKSwgdGhpcy5lYXQoXyk7XG4gIGNvbnN0IG4gPSBIZS5jYWxsKHRoaXMpLCBzID0gWW4uY2FsbCh0aGlzLCBuLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSwgciA9IEhlLmNhbGwodGhpcyk7XG4gIGxldCBvID0gbnVsbCwgYSA9IG51bGw7XG4gIHJldHVybiB0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSAhPT0gUyAmJiAobyA9IFluLmNhbGwodGhpcyksIGEgPSBIZS5jYWxsKHRoaXMpKSwgdGhpcy5za2lwU0MoKSwgdGhpcy5lYXQoUyksIHtcbiAgICB0eXBlOiBcIkZlYXR1cmVSYW5nZVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihlLCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGtpbmQ6IHQsXG4gICAgbGVmdDogbixcbiAgICBsZWZ0Q29tcGFyaXNvbjogcyxcbiAgICBtaWRkbGU6IHIsXG4gICAgcmlnaHRDb21wYXJpc29uOiBvLFxuICAgIHJpZ2h0OiBhXG4gIH07XG59XG5mdW5jdGlvbiBOcih0KSB7XG4gIHRoaXMudG9rZW4oXywgXCIoXCIpLCB0aGlzLm5vZGUodC5sZWZ0KSwgdGhpcy50b2tlbml6ZSh0LmxlZnRDb21wYXJpc29uKSwgdGhpcy5ub2RlKHQubWlkZGxlKSwgdC5yaWdodCAmJiAodGhpcy50b2tlbml6ZSh0LnJpZ2h0Q29tcGFyaXNvbiksIHRoaXMubm9kZSh0LnJpZ2h0KSksIHRoaXMudG9rZW4oUywgXCIpXCIpO1xufVxuY29uc3QgS2wgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogTnIsXG4gIG5hbWU6IEdsLFxuICBwYXJzZTogSXIsXG4gIHN0cnVjdHVyZTogcWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFFsID0gXCJGdW5jdGlvblwiLCBZbCA9IFwiZnVuY3Rpb25cIiwgWGwgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgY2hpbGRyZW46IFtbXV1cbn07XG5mdW5jdGlvbiBEcih0LCBlKSB7XG4gIGNvbnN0IG4gPSB0aGlzLnRva2VuU3RhcnQsIHMgPSB0aGlzLmNvbnN1bWVGdW5jdGlvbk5hbWUoKSwgciA9IHMudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG87XG4gIHJldHVybiBvID0gZS5oYXNPd25Qcm9wZXJ0eShyKSA/IGVbcl0uY2FsbCh0aGlzLCBlKSA6IHQuY2FsbCh0aGlzLCBlKSwgdGhpcy5lb2YgfHwgdGhpcy5lYXQoUyksIHtcbiAgICB0eXBlOiBcIkZ1bmN0aW9uXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKG4sIHRoaXMudG9rZW5TdGFydCksXG4gICAgbmFtZTogcyxcbiAgICBjaGlsZHJlbjogb1xuICB9O1xufVxuZnVuY3Rpb24gRnIodCkge1xuICB0aGlzLnRva2VuKFQsIHQubmFtZSArIFwiKFwiKSwgdGhpcy5jaGlsZHJlbih0KSwgdGhpcy50b2tlbihTLCBcIilcIik7XG59XG5jb25zdCBKbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBGcixcbiAgbmFtZTogUWwsXG4gIHBhcnNlOiBEcixcbiAgc3RydWN0dXJlOiBYbCxcbiAgd2Fsa0NvbnRleHQ6IFlsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBabCA9IFwiR2VuZXJhbEVuY2xvc2VkXCIsIHRjID0ge1xuICBraW5kOiBTdHJpbmcsXG4gIGZ1bmN0aW9uOiBbU3RyaW5nLCBudWxsXSxcbiAgY2hpbGRyZW46IFtbXV1cbn07XG5mdW5jdGlvbiBNcih0KSB7XG4gIGNvbnN0IGUgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIGxldCBuID0gbnVsbDtcbiAgdGhpcy50b2tlblR5cGUgPT09IFQgPyBuID0gdGhpcy5jb25zdW1lRnVuY3Rpb25OYW1lKCkgOiB0aGlzLmVhdChfKTtcbiAgY29uc3QgcyA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2soXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgciA9IHRoaXMudG9rZW5JbmRleCwgbyA9IHRoaXMucmVhZFNlcXVlbmNlKHRoaXMuc2NvcGUuVmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZW9mID09PSAhMSAmJiB0aGlzLmlzQmFsYW5jZUVkZ2UocikgPT09ICExICYmIHRoaXMuZXJyb3IoKSwgbztcbiAgICB9LFxuICAgICgpID0+IHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICB0aGlzLlJhdyhudWxsLCAhMSlcbiAgICApXG4gICk7XG4gIHJldHVybiB0aGlzLmVvZiB8fCB0aGlzLmVhdChTKSwge1xuICAgIHR5cGU6IFwiR2VuZXJhbEVuY2xvc2VkXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKGUsIHRoaXMudG9rZW5TdGFydCksXG4gICAga2luZDogdCxcbiAgICBmdW5jdGlvbjogbixcbiAgICBjaGlsZHJlbjogc1xuICB9O1xufVxuZnVuY3Rpb24ganIodCkge1xuICB0LmZ1bmN0aW9uID8gdGhpcy50b2tlbihULCB0LmZ1bmN0aW9uICsgXCIoXCIpIDogdGhpcy50b2tlbihfLCBcIihcIiksIHRoaXMuY2hpbGRyZW4odCksIHRoaXMudG9rZW4oUywgXCIpXCIpO1xufVxuY29uc3QgZWMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZToganIsXG4gIG5hbWU6IFpsLFxuICBwYXJzZTogTXIsXG4gIHN0cnVjdHVyZTogdGNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIG5jID0gXCJYWFhcIiwgc2MgPSBcIkhhc2hcIiwgcmMgPSB7XG4gIHZhbHVlOiBTdHJpbmdcbn07XG5mdW5jdGlvbiBCcigpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydDtcbiAgcmV0dXJuIHRoaXMuZWF0KEkpLCB7XG4gICAgdHlwZTogXCJIYXNoXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgdmFsdWU6IHRoaXMuc3Vic3RyVG9DdXJzb3IodCArIDEpXG4gIH07XG59XG5mdW5jdGlvbiBXcih0KSB7XG4gIHRoaXMudG9rZW4oSSwgXCIjXCIgKyB0LnZhbHVlKTtcbn1cbmNvbnN0IGljID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IFdyLFxuICBuYW1lOiBzYyxcbiAgcGFyc2U6IEJyLFxuICBzdHJ1Y3R1cmU6IHJjLFxuICB4eHg6IG5jXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBvYyA9IFwiSWRlbnRpZmllclwiLCBhYyA9IHtcbiAgbmFtZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gVXIoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHRoaXMudG9rZW5TdGFydCwgdGhpcy50b2tlbkVuZCksXG4gICAgbmFtZTogdGhpcy5jb25zdW1lKGcpXG4gIH07XG59XG5mdW5jdGlvbiB6cih0KSB7XG4gIHRoaXMudG9rZW4oZywgdC5uYW1lKTtcbn1cbmNvbnN0IGxjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHpyLFxuICBuYW1lOiBvYyxcbiAgcGFyc2U6IFVyLFxuICBzdHJ1Y3R1cmU6IGFjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBjYyA9IFwiSWRTZWxlY3RvclwiLCB1YyA9IHtcbiAgbmFtZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gVnIoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLmVhdChJKSwge1xuICAgIHR5cGU6IFwiSWRTZWxlY3RvclwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIG5hbWU6IHRoaXMuc3Vic3RyVG9DdXJzb3IodCArIDEpXG4gIH07XG59XG5mdW5jdGlvbiBIcih0KSB7XG4gIHRoaXMudG9rZW4oTCwgXCIjXCIgKyB0Lm5hbWUpO1xufVxuY29uc3QgaGMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogSHIsXG4gIG5hbWU6IGNjLFxuICBwYXJzZTogVnIsXG4gIHN0cnVjdHVyZTogdWNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGZjID0gNDYsIHBjID0gXCJMYXllclwiLCBkYyA9IHtcbiAgbmFtZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gR3IoKSB7XG4gIGxldCB0ID0gdGhpcy50b2tlblN0YXJ0LCBlID0gdGhpcy5jb25zdW1lKGcpO1xuICBmb3IgKDsgdGhpcy5pc0RlbGltKGZjKTsgKVxuICAgIHRoaXMuZWF0KEwpLCBlICs9IFwiLlwiICsgdGhpcy5jb25zdW1lKGcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTGF5ZXJcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odCwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBuYW1lOiBlXG4gIH07XG59XG5mdW5jdGlvbiBxcih0KSB7XG4gIHRoaXMudG9rZW5pemUodC5uYW1lKTtcbn1cbmNvbnN0IGdjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHFyLFxuICBuYW1lOiBwYyxcbiAgcGFyc2U6IEdyLFxuICBzdHJ1Y3R1cmU6IGRjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBtYyA9IFwiTGF5ZXJMaXN0XCIsIGtjID0ge1xuICBjaGlsZHJlbjogW1tcbiAgICBcIkxheWVyXCJcbiAgXV1cbn07XG5mdW5jdGlvbiBLcigpIHtcbiAgY29uc3QgdCA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICBmb3IgKHRoaXMuc2tpcFNDKCk7ICF0aGlzLmVvZiAmJiAodC5wdXNoKHRoaXMuTGF5ZXIoKSksIHRoaXMubG9va3VwVHlwZU5vblNDKDApID09PSBmdCk7IClcbiAgICB0aGlzLnNraXBTQygpLCB0aGlzLm5leHQoKSwgdGhpcy5za2lwU0MoKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkxheWVyTGlzdFwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KHQpLFxuICAgIGNoaWxkcmVuOiB0XG4gIH07XG59XG5mdW5jdGlvbiBRcih0KSB7XG4gIHRoaXMuY2hpbGRyZW4odCwgKCkgPT4gdGhpcy50b2tlbihmdCwgXCIsXCIpKTtcbn1cbmNvbnN0IFNjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IFFyLFxuICBuYW1lOiBtYyxcbiAgcGFyc2U6IEtyLFxuICBzdHJ1Y3R1cmU6IGtjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCB5YyA9IFwiTWVkaWFRdWVyeVwiLCBiYyA9IHtcbiAgbW9kaWZpZXI6IFtTdHJpbmcsIG51bGxdLFxuICBtZWRpYVR5cGU6IFtTdHJpbmcsIG51bGxdLFxuICBjb25kaXRpb246IFtcIkNvbmRpdGlvblwiLCBudWxsXVxufTtcbmZ1bmN0aW9uIFlyKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZSA9IG51bGwsIG4gPSBudWxsLCBzID0gbnVsbDtcbiAgaWYgKHRoaXMuc2tpcFNDKCksIHRoaXMudG9rZW5UeXBlID09PSBnICYmIHRoaXMubG9va3VwVHlwZU5vblNDKDEpICE9PSBfKSB7XG4gICAgY29uc3QgciA9IHRoaXMuY29uc3VtZShnKSwgbyA9IHIudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKG8gPT09IFwibm90XCIgfHwgbyA9PT0gXCJvbmx5XCIgPyAodGhpcy5za2lwU0MoKSwgZSA9IG8sIG4gPSB0aGlzLmNvbnN1bWUoZykpIDogbiA9IHIsIHRoaXMubG9va3VwVHlwZU5vblNDKDApKSB7XG4gICAgICBjYXNlIGc6IHtcbiAgICAgICAgdGhpcy5za2lwU0MoKSwgdGhpcy5lYXRJZGVudChcImFuZFwiKSwgcyA9IHRoaXMuQ29uZGl0aW9uKFwibWVkaWFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBodDpcbiAgICAgIGNhc2UgdHQ6XG4gICAgICBjYXNlIGZ0OlxuICAgICAgY2FzZSB2dDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVycm9yKFwiSWRlbnRpZmllciBvciBwYXJlbnRoZXNpcyBpcyBleHBlY3RlZFwiKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIHN3aXRjaCAodGhpcy50b2tlblR5cGUpIHtcbiAgICAgIGNhc2UgZzpcbiAgICAgIGNhc2UgXzpcbiAgICAgIGNhc2UgVDoge1xuICAgICAgICBzID0gdGhpcy5Db25kaXRpb24oXCJtZWRpYVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIGh0OlxuICAgICAgY2FzZSB0dDpcbiAgICAgIGNhc2UgdnQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5lcnJvcihcIklkZW50aWZpZXIgb3IgcGFyZW50aGVzaXMgaXMgZXhwZWN0ZWRcIik7XG4gICAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTWVkaWFRdWVyeVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIG1vZGlmaWVyOiBlLFxuICAgIG1lZGlhVHlwZTogbixcbiAgICBjb25kaXRpb246IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIFhyKHQpIHtcbiAgdC5tZWRpYVR5cGUgPyAodC5tb2RpZmllciAmJiB0aGlzLnRva2VuKGcsIHQubW9kaWZpZXIpLCB0aGlzLnRva2VuKGcsIHQubWVkaWFUeXBlKSwgdC5jb25kaXRpb24gJiYgKHRoaXMudG9rZW4oZywgXCJhbmRcIiksIHRoaXMubm9kZSh0LmNvbmRpdGlvbikpKSA6IHQuY29uZGl0aW9uICYmIHRoaXMubm9kZSh0LmNvbmRpdGlvbik7XG59XG5jb25zdCB4YyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBYcixcbiAgbmFtZTogeWMsXG4gIHBhcnNlOiBZcixcbiAgc3RydWN0dXJlOiBiY1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgQ2MgPSBcIk1lZGlhUXVlcnlMaXN0XCIsIHdjID0ge1xuICBjaGlsZHJlbjogW1tcbiAgICBcIk1lZGlhUXVlcnlcIlxuICBdXVxufTtcbmZ1bmN0aW9uIEpyKCkge1xuICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCk7XG4gIGZvciAodGhpcy5za2lwU0MoKTsgIXRoaXMuZW9mICYmICh0LnB1c2godGhpcy5NZWRpYVF1ZXJ5KCkpLCB0aGlzLnRva2VuVHlwZSA9PT0gZnQpOyApXG4gICAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNZWRpYVF1ZXJ5TGlzdFwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KHQpLFxuICAgIGNoaWxkcmVuOiB0XG4gIH07XG59XG5mdW5jdGlvbiBacih0KSB7XG4gIHRoaXMuY2hpbGRyZW4odCwgKCkgPT4gdGhpcy50b2tlbihmdCwgXCIsXCIpKTtcbn1cbmNvbnN0IFRjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IFpyLFxuICBuYW1lOiBDYyxcbiAgcGFyc2U6IEpyLFxuICBzdHJ1Y3R1cmU6IHdjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBBYyA9IDM4LCB2YyA9IFwiTmVzdGluZ1NlbGVjdG9yXCIsIEVjID0ge307XG5mdW5jdGlvbiB0aSgpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydDtcbiAgcmV0dXJuIHRoaXMuZWF0RGVsaW0oQWMpLCB7XG4gICAgdHlwZTogXCJOZXN0aW5nU2VsZWN0b3JcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odCwgdGhpcy50b2tlblN0YXJ0KVxuICB9O1xufVxuZnVuY3Rpb24gZWkoKSB7XG4gIHRoaXMudG9rZW4oTCwgXCImXCIpO1xufVxuY29uc3QgJGMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogZWksXG4gIG5hbWU6IHZjLFxuICBwYXJzZTogdGksXG4gIHN0cnVjdHVyZTogRWNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIExjID0gXCJOdGhcIiwgUGMgPSB7XG4gIG50aDogW1wiQW5QbHVzQlwiLCBcIklkZW50aWZpZXJcIl0sXG4gIHNlbGVjdG9yOiBbXCJTZWxlY3Rvckxpc3RcIiwgbnVsbF1cbn07XG5mdW5jdGlvbiBuaSgpIHtcbiAgdGhpcy5za2lwU0MoKTtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydDtcbiAgbGV0IGUgPSB0LCBuID0gbnVsbCwgcztcbiAgcmV0dXJuIHRoaXMubG9va3VwVmFsdWUoMCwgXCJvZGRcIikgfHwgdGhpcy5sb29rdXBWYWx1ZSgwLCBcImV2ZW5cIikgPyBzID0gdGhpcy5JZGVudGlmaWVyKCkgOiBzID0gdGhpcy5BblBsdXNCKCksIGUgPSB0aGlzLnRva2VuU3RhcnQsIHRoaXMuc2tpcFNDKCksIHRoaXMubG9va3VwVmFsdWUoMCwgXCJvZlwiKSAmJiAodGhpcy5uZXh0KCksIG4gPSB0aGlzLlNlbGVjdG9yTGlzdCgpLCBlID0gdGhpcy50b2tlblN0YXJ0KSwge1xuICAgIHR5cGU6IFwiTnRoXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIGUpLFxuICAgIG50aDogcyxcbiAgICBzZWxlY3RvcjogblxuICB9O1xufVxuZnVuY3Rpb24gc2kodCkge1xuICB0aGlzLm5vZGUodC5udGgpLCB0LnNlbGVjdG9yICE9PSBudWxsICYmICh0aGlzLnRva2VuKGcsIFwib2ZcIiksIHRoaXMubm9kZSh0LnNlbGVjdG9yKSk7XG59XG5jb25zdCBPYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBzaSxcbiAgbmFtZTogTGMsXG4gIHBhcnNlOiBuaSxcbiAgc3RydWN0dXJlOiBQY1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgUmMgPSBcIk51bWJlclwiLCBfYyA9IHtcbiAgdmFsdWU6IFN0cmluZ1xufTtcbmZ1bmN0aW9uIHJpKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTnVtYmVyXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHRoaXMudG9rZW5TdGFydCwgdGhpcy50b2tlbkVuZCksXG4gICAgdmFsdWU6IHRoaXMuY29uc3VtZShiKVxuICB9O1xufVxuZnVuY3Rpb24gaWkodCkge1xuICB0aGlzLnRva2VuKGIsIHQudmFsdWUpO1xufVxuY29uc3QgSWMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogaWksXG4gIG5hbWU6IFJjLFxuICBwYXJzZTogcmksXG4gIHN0cnVjdHVyZTogX2Ncbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIE5jID0gXCJPcGVyYXRvclwiLCBEYyA9IHtcbiAgdmFsdWU6IFN0cmluZ1xufTtcbmZ1bmN0aW9uIG9pKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICByZXR1cm4gdGhpcy5uZXh0KCksIHtcbiAgICB0eXBlOiBcIk9wZXJhdG9yXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgdmFsdWU6IHRoaXMuc3Vic3RyVG9DdXJzb3IodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGFpKHQpIHtcbiAgdGhpcy50b2tlbml6ZSh0LnZhbHVlKTtcbn1cbmNvbnN0IEZjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IGFpLFxuICBuYW1lOiBOYyxcbiAgcGFyc2U6IG9pLFxuICBzdHJ1Y3R1cmU6IERjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBNYyA9IFwiUGFyZW50aGVzZXNcIiwgamMgPSB7XG4gIGNoaWxkcmVuOiBbW11dXG59O1xuZnVuY3Rpb24gbGkodCwgZSkge1xuICBjb25zdCBuID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgcyA9IG51bGw7XG4gIHJldHVybiB0aGlzLmVhdChfKSwgcyA9IHQuY2FsbCh0aGlzLCBlKSwgdGhpcy5lb2YgfHwgdGhpcy5lYXQoUyksIHtcbiAgICB0eXBlOiBcIlBhcmVudGhlc2VzXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKG4sIHRoaXMudG9rZW5TdGFydCksXG4gICAgY2hpbGRyZW46IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNpKHQpIHtcbiAgdGhpcy50b2tlbihfLCBcIihcIiksIHRoaXMuY2hpbGRyZW4odCksIHRoaXMudG9rZW4oUywgXCIpXCIpO1xufVxuY29uc3QgQmMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogY2ksXG4gIG5hbWU6IE1jLFxuICBwYXJzZTogbGksXG4gIHN0cnVjdHVyZTogamNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIFdjID0gXCJQZXJjZW50YWdlXCIsIFVjID0ge1xuICB2YWx1ZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gdWkoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJQZXJjZW50YWdlXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHRoaXMudG9rZW5TdGFydCwgdGhpcy50b2tlbkVuZCksXG4gICAgdmFsdWU6IHRoaXMuY29uc3VtZU51bWJlcihGKVxuICB9O1xufVxuZnVuY3Rpb24gaGkodCkge1xuICB0aGlzLnRva2VuKEYsIHQudmFsdWUgKyBcIiVcIik7XG59XG5jb25zdCB6YyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBoaSxcbiAgbmFtZTogV2MsXG4gIHBhcnNlOiB1aSxcbiAgc3RydWN0dXJlOiBVY1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgVmMgPSBcIlBzZXVkb0NsYXNzU2VsZWN0b3JcIiwgSGMgPSBcImZ1bmN0aW9uXCIsIEdjID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGNoaWxkcmVuOiBbW1wiUmF3XCJdLCBudWxsXVxufTtcbmZ1bmN0aW9uIGZpKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZSA9IG51bGwsIG4sIHM7XG4gIHJldHVybiB0aGlzLmVhdChYKSwgdGhpcy50b2tlblR5cGUgPT09IFQgPyAobiA9IHRoaXMuY29uc3VtZUZ1bmN0aW9uTmFtZSgpLCBzID0gbi50b0xvd2VyQ2FzZSgpLCB0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSA9PSBTID8gZSA9IHRoaXMuY3JlYXRlTGlzdCgpIDogaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnBzZXVkbywgcykgPyAodGhpcy5za2lwU0MoKSwgZSA9IHRoaXMucHNldWRvW3NdLmNhbGwodGhpcyksIHRoaXMuc2tpcFNDKCkpIDogKGUgPSB0aGlzLmNyZWF0ZUxpc3QoKSwgZS5wdXNoKFxuICAgIHRoaXMuUmF3KG51bGwsICExKVxuICApKSwgdGhpcy5lYXQoUykpIDogbiA9IHRoaXMuY29uc3VtZShnKSwge1xuICAgIHR5cGU6IFwiUHNldWRvQ2xhc3NTZWxlY3RvclwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIG5hbWU6IG4sXG4gICAgY2hpbGRyZW46IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpKHQpIHtcbiAgdGhpcy50b2tlbihYLCBcIjpcIiksIHQuY2hpbGRyZW4gPT09IG51bGwgPyB0aGlzLnRva2VuKGcsIHQubmFtZSkgOiAodGhpcy50b2tlbihULCB0Lm5hbWUgKyBcIihcIiksIHRoaXMuY2hpbGRyZW4odCksIHRoaXMudG9rZW4oUywgXCIpXCIpKTtcbn1cbmNvbnN0IHFjID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHBpLFxuICBuYW1lOiBWYyxcbiAgcGFyc2U6IGZpLFxuICBzdHJ1Y3R1cmU6IEdjLFxuICB3YWxrQ29udGV4dDogSGNcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEtjID0gXCJQc2V1ZG9FbGVtZW50U2VsZWN0b3JcIiwgUWMgPSBcImZ1bmN0aW9uXCIsIFljID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGNoaWxkcmVuOiBbW1wiUmF3XCJdLCBudWxsXVxufTtcbmZ1bmN0aW9uIGRpKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZSA9IG51bGwsIG4sIHM7XG4gIHJldHVybiB0aGlzLmVhdChYKSwgdGhpcy5lYXQoWCksIHRoaXMudG9rZW5UeXBlID09PSBUID8gKG4gPSB0aGlzLmNvbnN1bWVGdW5jdGlvbk5hbWUoKSwgcyA9IG4udG9Mb3dlckNhc2UoKSwgdGhpcy5sb29rdXBOb25XU1R5cGUoMCkgPT0gUyA/IGUgPSB0aGlzLmNyZWF0ZUxpc3QoKSA6IGhhc093blByb3BlcnR5LmNhbGwodGhpcy5wc2V1ZG8sIHMpID8gKHRoaXMuc2tpcFNDKCksIGUgPSB0aGlzLnBzZXVkb1tzXS5jYWxsKHRoaXMpLCB0aGlzLnNraXBTQygpKSA6IChlID0gdGhpcy5jcmVhdGVMaXN0KCksIGUucHVzaChcbiAgICB0aGlzLlJhdyhudWxsLCAhMSlcbiAgKSksIHRoaXMuZWF0KFMpKSA6IG4gPSB0aGlzLmNvbnN1bWUoZyksIHtcbiAgICB0eXBlOiBcIlBzZXVkb0VsZW1lbnRTZWxlY3RvclwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIG5hbWU6IG4sXG4gICAgY2hpbGRyZW46IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdpKHQpIHtcbiAgdGhpcy50b2tlbihYLCBcIjpcIiksIHRoaXMudG9rZW4oWCwgXCI6XCIpLCB0LmNoaWxkcmVuID09PSBudWxsID8gdGhpcy50b2tlbihnLCB0Lm5hbWUpIDogKHRoaXMudG9rZW4oVCwgdC5uYW1lICsgXCIoXCIpLCB0aGlzLmNoaWxkcmVuKHQpLCB0aGlzLnRva2VuKFMsIFwiKVwiKSk7XG59XG5jb25zdCBYYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBnaSxcbiAgbmFtZTogS2MsXG4gIHBhcnNlOiBkaSxcbiAgc3RydWN0dXJlOiBZYyxcbiAgd2Fsa0NvbnRleHQ6IFFjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBYbiA9IDQ3O1xuZnVuY3Rpb24gSm4oKSB7XG4gIHN3aXRjaCAodGhpcy5za2lwU0MoKSwgdGhpcy50b2tlblR5cGUpIHtcbiAgICBjYXNlIGI6XG4gICAgICByZXR1cm4gdGhpcy5OdW1iZXIoKTtcbiAgICBjYXNlIFQ6XG4gICAgICByZXR1cm4gdGhpcy5GdW5jdGlvbih0aGlzLnJlYWRTZXF1ZW5jZSwgdGhpcy5zY29wZS5WYWx1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuZXJyb3IoXCJOdW1iZXIgb2YgZnVuY3Rpb24gaXMgZXhwZWN0ZWRcIik7XG4gIH1cbn1cbmNvbnN0IEpjID0gXCJSYXRpb1wiLCBaYyA9IHtcbiAgbGVmdDogW1wiTnVtYmVyXCIsIFwiRnVuY3Rpb25cIl0sXG4gIHJpZ2h0OiBbXCJOdW1iZXJcIiwgXCJGdW5jdGlvblwiLCBudWxsXVxufTtcbmZ1bmN0aW9uIG1pKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0LCBlID0gSm4uY2FsbCh0aGlzKTtcbiAgbGV0IG4gPSBudWxsO1xuICByZXR1cm4gdGhpcy5za2lwU0MoKSwgdGhpcy5pc0RlbGltKFhuKSAmJiAodGhpcy5lYXREZWxpbShYbiksIG4gPSBKbi5jYWxsKHRoaXMpKSwge1xuICAgIHR5cGU6IFwiUmF0aW9cIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odCwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBsZWZ0OiBlLFxuICAgIHJpZ2h0OiBuXG4gIH07XG59XG5mdW5jdGlvbiBraSh0KSB7XG4gIHRoaXMubm9kZSh0LmxlZnQpLCB0aGlzLnRva2VuKEwsIFwiL1wiKSwgdC5yaWdodCA/IHRoaXMubm9kZSh0LnJpZ2h0KSA6IHRoaXMubm9kZShiLCAxKTtcbn1cbmNvbnN0IHR1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IGtpLFxuICBuYW1lOiBKYyxcbiAgcGFyc2U6IG1pLFxuICBzdHJ1Y3R1cmU6IFpjXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gZXUoKSB7XG4gIHJldHVybiB0aGlzLnRva2VuSW5kZXggPiAwICYmIHRoaXMubG9va3VwVHlwZSgtMSkgPT09IFcgPyB0aGlzLnRva2VuSW5kZXggPiAxID8gdGhpcy5nZXRUb2tlblN0YXJ0KHRoaXMudG9rZW5JbmRleCAtIDEpIDogdGhpcy5maXJzdENoYXJPZmZzZXQgOiB0aGlzLnRva2VuU3RhcnQ7XG59XG5jb25zdCBudSA9IFwiUmF3XCIsIHN1ID0ge1xuICB2YWx1ZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gU2kodCwgZSkge1xuICBjb25zdCBuID0gdGhpcy5nZXRUb2tlblN0YXJ0KHRoaXMudG9rZW5JbmRleCk7XG4gIGxldCBzO1xuICByZXR1cm4gdGhpcy5za2lwVW50aWxCYWxhbmNlZCh0aGlzLnRva2VuSW5kZXgsIHQgfHwgdGhpcy5jb25zdW1lVW50aWxCYWxhbmNlRW5kKSwgZSAmJiB0aGlzLnRva2VuU3RhcnQgPiBuID8gcyA9IGV1LmNhbGwodGhpcykgOiBzID0gdGhpcy50b2tlblN0YXJ0LCB7XG4gICAgdHlwZTogXCJSYXdcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24obiwgcyksXG4gICAgdmFsdWU6IHRoaXMuc3Vic3RyaW5nKG4sIHMpXG4gIH07XG59XG5mdW5jdGlvbiB5aSh0KSB7XG4gIHRoaXMudG9rZW5pemUodC52YWx1ZSk7XG59XG5jb25zdCBydSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiB5aSxcbiAgbmFtZTogbnUsXG4gIHBhcnNlOiBTaSxcbiAgc3RydWN0dXJlOiBzdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIFpuKCkge1xuICByZXR1cm4gdGhpcy5SYXcodGhpcy5jb25zdW1lVW50aWxMZWZ0Q3VybHlCcmFja2V0LCAhMCk7XG59XG5mdW5jdGlvbiBpdSgpIHtcbiAgY29uc3QgdCA9IHRoaXMuU2VsZWN0b3JMaXN0KCk7XG4gIHJldHVybiB0LnR5cGUgIT09IFwiUmF3XCIgJiYgdGhpcy5lb2YgPT09ICExICYmIHRoaXMudG9rZW5UeXBlICE9PSBodCAmJiB0aGlzLmVycm9yKCksIHQ7XG59XG5jb25zdCBvdSA9IFwiUnVsZVwiLCBhdSA9IFwicnVsZVwiLCBsdSA9IHtcbiAgcHJlbHVkZTogW1wiU2VsZWN0b3JMaXN0XCIsIFwiUmF3XCJdLFxuICBibG9jazogW1wiQmxvY2tcIl1cbn07XG5mdW5jdGlvbiBiaSgpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5JbmRleCwgZSA9IHRoaXMudG9rZW5TdGFydDtcbiAgbGV0IG4sIHM7XG4gIHJldHVybiB0aGlzLnBhcnNlUnVsZVByZWx1ZGUgPyBuID0gdGhpcy5wYXJzZVdpdGhGYWxsYmFjayhpdSwgWm4pIDogbiA9IFpuLmNhbGwodGhpcywgdCksIHMgPSB0aGlzLkJsb2NrKCEwKSwge1xuICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihlLCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIHByZWx1ZGU6IG4sXG4gICAgYmxvY2s6IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHhpKHQpIHtcbiAgdGhpcy5ub2RlKHQucHJlbHVkZSksIHRoaXMubm9kZSh0LmJsb2NrKTtcbn1cbmNvbnN0IGN1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHhpLFxuICBuYW1lOiBvdSxcbiAgcGFyc2U6IGJpLFxuICBzdHJ1Y3R1cmU6IGx1LFxuICB3YWxrQ29udGV4dDogYXVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHV1ID0gXCJTY29wZVwiLCBodSA9IHtcbiAgcm9vdDogW1wiU2VsZWN0b3JMaXN0XCIsIFwiUmF3XCIsIG51bGxdLFxuICBsaW1pdDogW1wiU2VsZWN0b3JMaXN0XCIsIFwiUmF3XCIsIG51bGxdXG59O1xuZnVuY3Rpb24gQ2koKSB7XG4gIGxldCB0ID0gbnVsbCwgZSA9IG51bGw7XG4gIHRoaXMuc2tpcFNDKCk7XG4gIGNvbnN0IG4gPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLnRva2VuVHlwZSA9PT0gXyAmJiAodGhpcy5uZXh0KCksIHRoaXMuc2tpcFNDKCksIHQgPSB0aGlzLnBhcnNlV2l0aEZhbGxiYWNrKFxuICAgIHRoaXMuU2VsZWN0b3JMaXN0LFxuICAgICgpID0+IHRoaXMuUmF3KCExLCAhMClcbiAgKSwgdGhpcy5za2lwU0MoKSwgdGhpcy5lYXQoUykpLCB0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSA9PT0gZyAmJiAodGhpcy5za2lwU0MoKSwgdGhpcy5lYXRJZGVudChcInRvXCIpLCB0aGlzLnNraXBTQygpLCB0aGlzLmVhdChfKSwgdGhpcy5za2lwU0MoKSwgZSA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2soXG4gICAgdGhpcy5TZWxlY3Rvckxpc3QsXG4gICAgKCkgPT4gdGhpcy5SYXcoITEsICEwKVxuICApLCB0aGlzLnNraXBTQygpLCB0aGlzLmVhdChTKSksIHtcbiAgICB0eXBlOiBcIlNjb3BlXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKG4sIHRoaXMudG9rZW5TdGFydCksXG4gICAgcm9vdDogdCxcbiAgICBsaW1pdDogZVxuICB9O1xufVxuZnVuY3Rpb24gd2kodCkge1xuICB0LnJvb3QgJiYgKHRoaXMudG9rZW4oXywgXCIoXCIpLCB0aGlzLm5vZGUodC5yb290KSwgdGhpcy50b2tlbihTLCBcIilcIikpLCB0LmxpbWl0ICYmICh0aGlzLnRva2VuKGcsIFwidG9cIiksIHRoaXMudG9rZW4oXywgXCIoXCIpLCB0aGlzLm5vZGUodC5saW1pdCksIHRoaXMudG9rZW4oUywgXCIpXCIpKTtcbn1cbmNvbnN0IGZ1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IHdpLFxuICBuYW1lOiB1dSxcbiAgcGFyc2U6IENpLFxuICBzdHJ1Y3R1cmU6IGh1XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBwdSA9IFwiU2VsZWN0b3JcIiwgZHUgPSB7XG4gIGNoaWxkcmVuOiBbW1xuICAgIFwiVHlwZVNlbGVjdG9yXCIsXG4gICAgXCJJZFNlbGVjdG9yXCIsXG4gICAgXCJDbGFzc1NlbGVjdG9yXCIsXG4gICAgXCJBdHRyaWJ1dGVTZWxlY3RvclwiLFxuICAgIFwiUHNldWRvQ2xhc3NTZWxlY3RvclwiLFxuICAgIFwiUHNldWRvRWxlbWVudFNlbGVjdG9yXCIsXG4gICAgXCJDb21iaW5hdG9yXCJcbiAgXV1cbn07XG5mdW5jdGlvbiBUaSgpIHtcbiAgY29uc3QgdCA9IHRoaXMucmVhZFNlcXVlbmNlKHRoaXMuc2NvcGUuU2VsZWN0b3IpO1xuICByZXR1cm4gdGhpcy5nZXRGaXJzdExpc3ROb2RlKHQpID09PSBudWxsICYmIHRoaXMuZXJyb3IoXCJTZWxlY3RvciBpcyBleHBlY3RlZFwiKSwge1xuICAgIHR5cGU6IFwiU2VsZWN0b3JcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb25Gcm9tTGlzdCh0KSxcbiAgICBjaGlsZHJlbjogdFxuICB9O1xufVxuZnVuY3Rpb24gQWkodCkge1xuICB0aGlzLmNoaWxkcmVuKHQpO1xufVxuY29uc3QgZ3UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogQWksXG4gIG5hbWU6IHB1LFxuICBwYXJzZTogVGksXG4gIHN0cnVjdHVyZTogZHVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIG11ID0gXCJTZWxlY3Rvckxpc3RcIiwga3UgPSBcInNlbGVjdG9yXCIsIFN1ID0ge1xuICBjaGlsZHJlbjogW1tcbiAgICBcIlNlbGVjdG9yXCIsXG4gICAgXCJSYXdcIlxuICBdXVxufTtcbmZ1bmN0aW9uIHZpKCkge1xuICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCk7XG4gIGZvciAoOyAhdGhpcy5lb2Y7ICkge1xuICAgIGlmICh0LnB1c2godGhpcy5TZWxlY3RvcigpKSwgdGhpcy50b2tlblR5cGUgPT09IGZ0KSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiU2VsZWN0b3JMaXN0XCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uRnJvbUxpc3QodCksXG4gICAgY2hpbGRyZW46IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIEVpKHQpIHtcbiAgdGhpcy5jaGlsZHJlbih0LCAoKSA9PiB0aGlzLnRva2VuKGZ0LCBcIixcIikpO1xufVxuY29uc3QgeXUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZW5lcmF0ZTogRWksXG4gIG5hbWU6IG11LFxuICBwYXJzZTogdmksXG4gIHN0cnVjdHVyZTogU3UsXG4gIHdhbGtDb250ZXh0OiBrdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgY24gPSA5MiwgJGkgPSAzNCwgYnUgPSAzOTtcbmZ1bmN0aW9uIExpKHQpIHtcbiAgY29uc3QgZSA9IHQubGVuZ3RoLCBuID0gdC5jaGFyQ29kZUF0KDApLCBzID0gbiA9PT0gJGkgfHwgbiA9PT0gYnUgPyAxIDogMCwgciA9IHMgPT09IDEgJiYgZSA+IDEgJiYgdC5jaGFyQ29kZUF0KGUgLSAxKSA9PT0gbiA/IGUgLSAyIDogZSAtIDE7XG4gIGxldCBvID0gXCJcIjtcbiAgZm9yIChsZXQgYSA9IHM7IGEgPD0gcjsgYSsrKSB7XG4gICAgbGV0IGwgPSB0LmNoYXJDb2RlQXQoYSk7XG4gICAgaWYgKGwgPT09IGNuKSB7XG4gICAgICBpZiAoYSA9PT0gcikge1xuICAgICAgICBhICE9PSBlIC0gMSAmJiAobyA9IHQuc3Vic3RyKGEgKyAxKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGwgPSB0LmNoYXJDb2RlQXQoKythKSwga3QoY24sIGwpKSB7XG4gICAgICAgIGNvbnN0IHUgPSBhIC0gMSwgaSA9IEp0KHQsIHUpO1xuICAgICAgICBhID0gaSAtIDEsIG8gKz0gS3ModC5zdWJzdHJpbmcodSArIDEsIGkpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBsID09PSAxMyAmJiB0LmNoYXJDb2RlQXQoYSArIDEpID09PSAxMCAmJiBhKys7XG4gICAgfSBlbHNlXG4gICAgICBvICs9IHRbYV07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiB4dSh0LCBlKSB7XG4gIGNvbnN0IHMgPSAkaTtcbiAgbGV0IHIgPSBcIlwiLCBvID0gITE7XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgIGNvbnN0IGwgPSB0LmNoYXJDb2RlQXQoYSk7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHIgKz0gXCLvv71cIjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobCA8PSAzMSB8fCBsID09PSAxMjcpIHtcbiAgICAgIHIgKz0gXCJcXFxcXCIgKyBsLnRvU3RyaW5nKDE2KSwgbyA9ICEwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGwgPT09IHMgfHwgbCA9PT0gY24gPyAociArPSBcIlxcXFxcIiArIHQuY2hhckF0KGEpLCBvID0gITEpIDogKG8gJiYgKFh0KGwpIHx8IEZ0KGwpKSAmJiAociArPSBcIiBcIiksIHIgKz0gdC5jaGFyQXQoYSksIG8gPSAhMSk7XG4gIH1cbiAgcmV0dXJuICdcIicgKyByICsgJ1wiJztcbn1cbmNvbnN0IEN1ID0gXCJTdHJpbmdcIiwgd3UgPSB7XG4gIHZhbHVlOiBTdHJpbmdcbn07XG5mdW5jdGlvbiBQaSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlN0cmluZ1wiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQpLFxuICAgIHZhbHVlOiBMaSh0aGlzLmNvbnN1bWUoVHQpKVxuICB9O1xufVxuZnVuY3Rpb24gT2kodCkge1xuICB0aGlzLnRva2VuKFR0LCB4dSh0LnZhbHVlKSk7XG59XG5jb25zdCBUdSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBPaSxcbiAgbmFtZTogQ3UsXG4gIHBhcnNlOiBQaSxcbiAgc3RydWN0dXJlOiB3dVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgQXUgPSAzMztcbmZ1bmN0aW9uIHRzKCkge1xuICByZXR1cm4gdGhpcy5SYXcobnVsbCwgITEpO1xufVxuY29uc3QgdnUgPSBcIlN0eWxlU2hlZXRcIiwgRXUgPSBcInN0eWxlc2hlZXRcIiwgJHUgPSB7XG4gIGNoaWxkcmVuOiBbW1xuICAgIFwiQ29tbWVudFwiLFxuICAgIFwiQ0RPXCIsXG4gICAgXCJDRENcIixcbiAgICBcIkF0cnVsZVwiLFxuICAgIFwiUnVsZVwiLFxuICAgIFwiUmF3XCJcbiAgXV1cbn07XG5mdW5jdGlvbiBSaSgpIHtcbiAgY29uc3QgdCA9IHRoaXMudG9rZW5TdGFydCwgZSA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICBsZXQgbjtcbiAgZm9yICg7ICF0aGlzLmVvZjsgKSB7XG4gICAgc3dpdGNoICh0aGlzLnRva2VuVHlwZSkge1xuICAgICAgY2FzZSBXOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIFk6XG4gICAgICAgIGlmICh0aGlzLmNoYXJDb2RlQXQodGhpcy50b2tlblN0YXJ0ICsgMikgIT09IEF1KSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHRoaXMuQ29tbWVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGU6XG4gICAgICAgIG4gPSB0aGlzLkNETygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbnQ6XG4gICAgICAgIG4gPSB0aGlzLkNEQygpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIENTUyBTeW50YXggTW9kdWxlIExldmVsIDNcbiAgICAgIC8vIMKnMi4yIEVycm9yIGhhbmRsaW5nXG4gICAgICAvLyBBdCB0aGUgXCJ0b3AgbGV2ZWxcIiBvZiBhIHN0eWxlc2hlZXQsIGFuIDxhdC1rZXl3b3JkLXRva2VuPiBzdGFydHMgYW4gYXQtcnVsZS5cbiAgICAgIGNhc2UgejpcbiAgICAgICAgbiA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5BdHJ1bGUsIHRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBBbnl0aGluZyBlbHNlIHN0YXJ0cyBhIHF1YWxpZmllZCBydWxlIC4uLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbiA9IHRoaXMucGFyc2VXaXRoRmFsbGJhY2sodGhpcy5SdWxlLCB0cyk7XG4gICAgfVxuICAgIGUucHVzaChuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiU3R5bGVTaGVldFwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGNoaWxkcmVuOiBlXG4gIH07XG59XG5mdW5jdGlvbiBfaSh0KSB7XG4gIHRoaXMuY2hpbGRyZW4odCk7XG59XG5jb25zdCBMdSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBfaSxcbiAgbmFtZTogdnUsXG4gIHBhcnNlOiBSaSxcbiAgc3RydWN0dXJlOiAkdSxcbiAgd2Fsa0NvbnRleHQ6IEV1XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBQdSA9IFwiU3VwcG9ydHNEZWNsYXJhdGlvblwiLCBPdSA9IHtcbiAgZGVjbGFyYXRpb246IFwiRGVjbGFyYXRpb25cIlxufTtcbmZ1bmN0aW9uIElpKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICB0aGlzLmVhdChfKSwgdGhpcy5za2lwU0MoKTtcbiAgY29uc3QgZSA9IHRoaXMuRGVjbGFyYXRpb24oKTtcbiAgcmV0dXJuIHRoaXMuZW9mIHx8IHRoaXMuZWF0KFMpLCB7XG4gICAgdHlwZTogXCJTdXBwb3J0c0RlY2xhcmF0aW9uXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgZGVjbGFyYXRpb246IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIE5pKHQpIHtcbiAgdGhpcy50b2tlbihfLCBcIihcIiksIHRoaXMubm9kZSh0LmRlY2xhcmF0aW9uKSwgdGhpcy50b2tlbihTLCBcIilcIik7XG59XG5jb25zdCBSdSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBOaSxcbiAgbmFtZTogUHUsXG4gIHBhcnNlOiBJaSxcbiAgc3RydWN0dXJlOiBPdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgX3UgPSA0MiwgZXMgPSAxMjQ7XG5mdW5jdGlvbiBHZSgpIHtcbiAgdGhpcy50b2tlblR5cGUgIT09IGcgJiYgdGhpcy5pc0RlbGltKF91KSA9PT0gITEgJiYgdGhpcy5lcnJvcihcIklkZW50aWZpZXIgb3IgYXN0ZXJpc2sgaXMgZXhwZWN0ZWRcIiksIHRoaXMubmV4dCgpO1xufVxuY29uc3QgSXUgPSBcIlR5cGVTZWxlY3RvclwiLCBOdSA9IHtcbiAgbmFtZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gRGkoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLmlzRGVsaW0oZXMpID8gKHRoaXMubmV4dCgpLCBHZS5jYWxsKHRoaXMpKSA6IChHZS5jYWxsKHRoaXMpLCB0aGlzLmlzRGVsaW0oZXMpICYmICh0aGlzLm5leHQoKSwgR2UuY2FsbCh0aGlzKSkpLCB7XG4gICAgdHlwZTogXCJUeXBlU2VsZWN0b3JcIixcbiAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odCwgdGhpcy50b2tlblN0YXJ0KSxcbiAgICBuYW1lOiB0aGlzLnN1YnN0clRvQ3Vyc29yKHQpXG4gIH07XG59XG5mdW5jdGlvbiBGaSh0KSB7XG4gIHRoaXMudG9rZW5pemUodC5uYW1lKTtcbn1cbmNvbnN0IER1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IEZpLFxuICBuYW1lOiBJdSxcbiAgcGFyc2U6IERpLFxuICBzdHJ1Y3R1cmU6IE51XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBNaSA9IDQzLCBqaSA9IDQ1LCB1biA9IDYzO1xuZnVuY3Rpb24gc2UodCwgZSkge1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IHMgPSB0aGlzLnRva2VuU3RhcnQgKyB0OyBzIDwgdGhpcy50b2tlbkVuZDsgcysrKSB7XG4gICAgY29uc3QgciA9IHRoaXMuY2hhckNvZGVBdChzKTtcbiAgICBpZiAociA9PT0gamkgJiYgZSAmJiBuICE9PSAwKVxuICAgICAgcmV0dXJuIHNlLmNhbGwodGhpcywgdCArIG4gKyAxLCAhMSksIC0xO1xuICAgIFh0KHIpIHx8IHRoaXMuZXJyb3IoXG4gICAgICBlICYmIG4gIT09IDAgPyBcIkh5cGhlbiBtaW51c1wiICsgKG4gPCA2ID8gXCIgb3IgaGV4IGRpZ2l0XCIgOiBcIlwiKSArIFwiIGlzIGV4cGVjdGVkXCIgOiBuIDwgNiA/IFwiSGV4IGRpZ2l0IGlzIGV4cGVjdGVkXCIgOiBcIlVuZXhwZWN0ZWQgaW5wdXRcIixcbiAgICAgIHNcbiAgICApLCArK24gPiA2ICYmIHRoaXMuZXJyb3IoXCJUb28gbWFueSBoZXggZGlnaXRzXCIsIHMpO1xuICB9XG4gIHJldHVybiB0aGlzLm5leHQoKSwgbjtcbn1cbmZ1bmN0aW9uIG1lKHQpIHtcbiAgbGV0IGUgPSAwO1xuICBmb3IgKDsgdGhpcy5pc0RlbGltKHVuKTsgKVxuICAgICsrZSA+IHQgJiYgdGhpcy5lcnJvcihcIlRvbyBtYW55IHF1ZXN0aW9uIG1hcmtzXCIpLCB0aGlzLm5leHQoKTtcbn1cbmZ1bmN0aW9uIEZ1KHQpIHtcbiAgdGhpcy5jaGFyQ29kZUF0KHRoaXMudG9rZW5TdGFydCkgIT09IHQgJiYgdGhpcy5lcnJvcigodCA9PT0gTWkgPyBcIlBsdXMgc2lnblwiIDogXCJIeXBoZW4gbWludXNcIikgKyBcIiBpcyBleHBlY3RlZFwiKTtcbn1cbmZ1bmN0aW9uIE11KCkge1xuICBsZXQgdCA9IDA7XG4gIHN3aXRjaCAodGhpcy50b2tlblR5cGUpIHtcbiAgICBjYXNlIGI6XG4gICAgICBpZiAodCA9IHNlLmNhbGwodGhpcywgMSwgITApLCB0aGlzLmlzRGVsaW0odW4pKSB7XG4gICAgICAgIG1lLmNhbGwodGhpcywgNiAtIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2VuVHlwZSA9PT0gRSB8fCB0aGlzLnRva2VuVHlwZSA9PT0gYikge1xuICAgICAgICBGdS5jYWxsKHRoaXMsIGppKSwgc2UuY2FsbCh0aGlzLCAxLCAhMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBFOlxuICAgICAgdCA9IHNlLmNhbGwodGhpcywgMSwgITApLCB0ID4gMCAmJiBtZS5jYWxsKHRoaXMsIDYgLSB0KTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5lYXREZWxpbShNaSksIHRoaXMudG9rZW5UeXBlID09PSBnKSB7XG4gICAgICAgIHQgPSBzZS5jYWxsKHRoaXMsIDAsICEwKSwgdCA+IDAgJiYgbWUuY2FsbCh0aGlzLCA2IC0gdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEZWxpbSh1bikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCksIG1lLmNhbGwodGhpcywgNSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lcnJvcihcIkhleCBkaWdpdCBvciBxdWVzdGlvbiBtYXJrIGlzIGV4cGVjdGVkXCIpO1xuICB9XG59XG5jb25zdCBqdSA9IFwiVW5pY29kZVJhbmdlXCIsIEJ1ID0ge1xuICB2YWx1ZTogU3RyaW5nXG59O1xuZnVuY3Rpb24gQmkoKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnRva2VuU3RhcnQ7XG4gIHJldHVybiB0aGlzLmVhdElkZW50KFwidVwiKSwgTXUuY2FsbCh0aGlzKSwge1xuICAgIHR5cGU6IFwiVW5pY29kZVJhbmdlXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgdmFsdWU6IHRoaXMuc3Vic3RyVG9DdXJzb3IodClcbiAgfTtcbn1cbmZ1bmN0aW9uIFdpKHQpIHtcbiAgdGhpcy50b2tlbml6ZSh0LnZhbHVlKTtcbn1cbmNvbnN0IFd1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IFdpLFxuICBuYW1lOiBqdSxcbiAgcGFyc2U6IEJpLFxuICBzdHJ1Y3R1cmU6IEJ1XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBVdSA9IDMyLCBobiA9IDkyLCB6dSA9IDM0LCBWdSA9IDM5LCBIdSA9IDQwLCBVaSA9IDQxO1xuZnVuY3Rpb24gR3UodCkge1xuICBjb25zdCBlID0gdC5sZW5ndGg7XG4gIGxldCBuID0gNCwgcyA9IHQuY2hhckNvZGVBdChlIC0gMSkgPT09IFVpID8gZSAtIDIgOiBlIC0gMSwgciA9IFwiXCI7XG4gIGZvciAoOyBuIDwgcyAmJiBGdCh0LmNoYXJDb2RlQXQobikpOyApXG4gICAgbisrO1xuICBmb3IgKDsgbiA8IHMgJiYgRnQodC5jaGFyQ29kZUF0KHMpKTsgKVxuICAgIHMtLTtcbiAgZm9yIChsZXQgbyA9IG47IG8gPD0gczsgbysrKSB7XG4gICAgbGV0IGEgPSB0LmNoYXJDb2RlQXQobyk7XG4gICAgaWYgKGEgPT09IGhuKSB7XG4gICAgICBpZiAobyA9PT0gcykge1xuICAgICAgICBvICE9PSBlIC0gMSAmJiAociA9IHQuc3Vic3RyKG8gKyAxKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGEgPSB0LmNoYXJDb2RlQXQoKytvKSwga3QoaG4sIGEpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBvIC0gMSwgdSA9IEp0KHQsIGwpO1xuICAgICAgICBvID0gdSAtIDEsIHIgKz0gS3ModC5zdWJzdHJpbmcobCArIDEsIHUpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBhID09PSAxMyAmJiB0LmNoYXJDb2RlQXQobyArIDEpID09PSAxMCAmJiBvKys7XG4gICAgfSBlbHNlXG4gICAgICByICs9IHRbb107XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBxdSh0KSB7XG4gIGxldCBlID0gXCJcIiwgbiA9ICExO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIHtcbiAgICBjb25zdCByID0gdC5jaGFyQ29kZUF0KHMpO1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICBlICs9IFwi77+9XCI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHIgPD0gMzEgfHwgciA9PT0gMTI3KSB7XG4gICAgICBlICs9IFwiXFxcXFwiICsgci50b1N0cmluZygxNiksIG4gPSAhMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByID09PSBVdSB8fCByID09PSBobiB8fCByID09PSB6dSB8fCByID09PSBWdSB8fCByID09PSBIdSB8fCByID09PSBVaSA/IChlICs9IFwiXFxcXFwiICsgdC5jaGFyQXQocyksIG4gPSAhMSkgOiAobiAmJiBYdChyKSAmJiAoZSArPSBcIiBcIiksIGUgKz0gdC5jaGFyQXQocyksIG4gPSAhMSk7XG4gIH1cbiAgcmV0dXJuIFwidXJsKFwiICsgZSArIFwiKVwiO1xufVxuY29uc3QgS3UgPSBcIlVybFwiLCBRdSA9IHtcbiAgdmFsdWU6IFN0cmluZ1xufTtcbmZ1bmN0aW9uIHppKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0O1xuICBsZXQgZTtcbiAgc3dpdGNoICh0aGlzLnRva2VuVHlwZSkge1xuICAgIGNhc2UgUTpcbiAgICAgIGUgPSBHdSh0aGlzLmNvbnN1bWUoUSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBUOlxuICAgICAgdGhpcy5jbXBTdHIodGhpcy50b2tlblN0YXJ0LCB0aGlzLnRva2VuRW5kLCBcInVybChcIikgfHwgdGhpcy5lcnJvcihcIkZ1bmN0aW9uIG5hbWUgbXVzdCBiZSBgdXJsYFwiKSwgdGhpcy5lYXQoVCksIHRoaXMuc2tpcFNDKCksIGUgPSBMaSh0aGlzLmNvbnN1bWUoVHQpKSwgdGhpcy5za2lwU0MoKSwgdGhpcy5lb2YgfHwgdGhpcy5lYXQoUyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5lcnJvcihcIlVybCBvciBGdW5jdGlvbiBpcyBleHBlY3RlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVXJsXCIsXG4gICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHQsIHRoaXMudG9rZW5TdGFydCksXG4gICAgdmFsdWU6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIFZpKHQpIHtcbiAgdGhpcy50b2tlbihRLCBxdSh0LnZhbHVlKSk7XG59XG5jb25zdCBZdSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBWaSxcbiAgbmFtZTogS3UsXG4gIHBhcnNlOiB6aSxcbiAgc3RydWN0dXJlOiBRdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgWHUgPSBcIlZhbHVlXCIsIEp1ID0ge1xuICBjaGlsZHJlbjogW1tdXVxufTtcbmZ1bmN0aW9uIEhpKCkge1xuICBjb25zdCB0ID0gdGhpcy50b2tlblN0YXJ0LCBlID0gdGhpcy5yZWFkU2VxdWVuY2UodGhpcy5zY29wZS5WYWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0LCB0aGlzLnRva2VuU3RhcnQpLFxuICAgIGNoaWxkcmVuOiBlXG4gIH07XG59XG5mdW5jdGlvbiBHaSh0KSB7XG4gIHRoaXMuY2hpbGRyZW4odCk7XG59XG5jb25zdCBadSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdlbmVyYXRlOiBHaSxcbiAgbmFtZTogWHUsXG4gIHBhcnNlOiBIaSxcbiAgc3RydWN0dXJlOiBKdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgdGggPSBPYmplY3QuZnJlZXplKHtcbiAgdHlwZTogXCJXaGl0ZVNwYWNlXCIsXG4gIGxvYzogbnVsbCxcbiAgdmFsdWU6IFwiIFwiXG59KSwgZWggPSBcIldoaXRlU3BhY2VcIiwgbmggPSB7XG4gIHZhbHVlOiBTdHJpbmdcbn07XG5mdW5jdGlvbiBxaSgpIHtcbiAgcmV0dXJuIHRoaXMuZWF0KFcpLCB0aDtcbn1cbmZ1bmN0aW9uIEtpKHQpIHtcbiAgdGhpcy50b2tlbihXLCB0LnZhbHVlKTtcbn1cbmNvbnN0IHNoID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VuZXJhdGU6IEtpLFxuICBuYW1lOiBlaCxcbiAgcGFyc2U6IHFpLFxuICBzdHJ1Y3R1cmU6IG5oXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCByaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFuUGx1c0I6IGdhLFxuICBBdHJ1bGU6IGJhLFxuICBBdHJ1bGVQcmVsdWRlOiBUYSxcbiAgQXR0cmlidXRlU2VsZWN0b3I6IFJhLFxuICBCbG9jazogTWEsXG4gIEJyYWNrZXRzOiBXYSxcbiAgQ0RDOiBWYSxcbiAgQ0RPOiBxYSxcbiAgQ2xhc3NTZWxlY3RvcjogWGEsXG4gIENvbWJpbmF0b3I6IHNsLFxuICBDb21tZW50OiBsbCxcbiAgQ29uZGl0aW9uOiBwbCxcbiAgRGVjbGFyYXRpb246ICRsLFxuICBEZWNsYXJhdGlvbkxpc3Q6IFJsLFxuICBEaW1lbnNpb246IE5sLFxuICBGZWF0dXJlOiBqbCxcbiAgRmVhdHVyZUZ1bmN0aW9uOiB6bCxcbiAgRmVhdHVyZVJhbmdlOiBLbCxcbiAgRnVuY3Rpb246IEpsLFxuICBHZW5lcmFsRW5jbG9zZWQ6IGVjLFxuICBIYXNoOiBpYyxcbiAgSWRTZWxlY3RvcjogaGMsXG4gIElkZW50aWZpZXI6IGxjLFxuICBMYXllcjogZ2MsXG4gIExheWVyTGlzdDogU2MsXG4gIE1lZGlhUXVlcnk6IHhjLFxuICBNZWRpYVF1ZXJ5TGlzdDogVGMsXG4gIE5lc3RpbmdTZWxlY3RvcjogJGMsXG4gIE50aDogT2MsXG4gIE51bWJlcjogSWMsXG4gIE9wZXJhdG9yOiBGYyxcbiAgUGFyZW50aGVzZXM6IEJjLFxuICBQZXJjZW50YWdlOiB6YyxcbiAgUHNldWRvQ2xhc3NTZWxlY3RvcjogcWMsXG4gIFBzZXVkb0VsZW1lbnRTZWxlY3RvcjogWGMsXG4gIFJhdGlvOiB0dSxcbiAgUmF3OiBydSxcbiAgUnVsZTogY3UsXG4gIFNjb3BlOiBmdSxcbiAgU2VsZWN0b3I6IGd1LFxuICBTZWxlY3Rvckxpc3Q6IHl1LFxuICBTdHJpbmc6IFR1LFxuICBTdHlsZVNoZWV0OiBMdSxcbiAgU3VwcG9ydHNEZWNsYXJhdGlvbjogUnUsXG4gIFR5cGVTZWxlY3RvcjogRHUsXG4gIFVuaWNvZGVSYW5nZTogV3UsXG4gIFVybDogWXUsXG4gIFZhbHVlOiBadSxcbiAgV2hpdGVTcGFjZTogc2hcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGloID0ge1xuICBub2RlOiByaFxufSwgJHQgPSBabyhpaCksIHduID0gW1xuICBcImxlZnRcIixcbiAgXCJyaWdodFwiLFxuICBcInRvcFwiLFxuICBcImJvdHRvbVwiLFxuICBcImluc2V0LWJsb2NrLXN0YXJ0XCIsXG4gIFwiaW5zZXQtYmxvY2stZW5kXCIsXG4gIFwiaW5zZXQtaW5saW5lLXN0YXJ0XCIsXG4gIFwiaW5zZXQtaW5saW5lLWVuZFwiLFxuICBcImluc2V0LWJsb2NrXCIsXG4gIFwiaW5zZXQtaW5saW5lXCIsXG4gIFwiaW5zZXRcIlxuXTtcbmZ1bmN0aW9uIHVlKHQpIHtcbiAgcmV0dXJuIHduLmluY2x1ZGVzKHQpO1xufVxuY29uc3QgVG4gPSBbXG4gIFwibWFyZ2luLWJsb2NrLXN0YXJ0XCIsXG4gIFwibWFyZ2luLWJsb2NrLWVuZFwiLFxuICBcIm1hcmdpbi1ibG9ja1wiLFxuICBcIm1hcmdpbi1pbmxpbmUtc3RhcnRcIixcbiAgXCJtYXJnaW4taW5saW5lLWVuZFwiLFxuICBcIm1hcmdpbi1pbmxpbmVcIixcbiAgXCJtYXJnaW4tYm90dG9tXCIsXG4gIFwibWFyZ2luLWxlZnRcIixcbiAgXCJtYXJnaW4tcmlnaHRcIixcbiAgXCJtYXJnaW4tdG9wXCIsXG4gIFwibWFyZ2luXCJcbl07XG5mdW5jdGlvbiBvaCh0KSB7XG4gIHJldHVybiBUbi5pbmNsdWRlcyh0KTtcbn1cbmNvbnN0IEFuID0gW1xuICBcIndpZHRoXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwibWluLXdpZHRoXCIsXG4gIFwibWluLWhlaWdodFwiLFxuICBcIm1heC13aWR0aFwiLFxuICBcIm1heC1oZWlnaHRcIixcbiAgXCJibG9jay1zaXplXCIsXG4gIFwiaW5saW5lLXNpemVcIixcbiAgXCJtaW4tYmxvY2stc2l6ZVwiLFxuICBcIm1pbi1pbmxpbmUtc2l6ZVwiLFxuICBcIm1heC1ibG9jay1zaXplXCIsXG4gIFwibWF4LWlubGluZS1zaXplXCJcbl07XG5mdW5jdGlvbiBRaSh0KSB7XG4gIHJldHVybiBBbi5pbmNsdWRlcyh0KTtcbn1cbmNvbnN0IFlpID0gW1xuICBcImp1c3RpZnktc2VsZlwiLFxuICBcImFsaWduLXNlbGZcIixcbiAgXCJwbGFjZS1zZWxmXCJcbl07XG5mdW5jdGlvbiBhaCh0KSB7XG4gIHJldHVybiBZaS5pbmNsdWRlcyh0KTtcbn1cbmNvbnN0IFhpID0gW1xuICAuLi53bixcbiAgLi4uVG4sXG4gIC4uLkFuLFxuICAuLi5ZaSxcbiAgXCJwb3NpdGlvbi1hbmNob3JcIixcbiAgXCJwb3NpdGlvbi1hcmVhXCJcbl0sIGxoID0gW1xuICAuLi5BbixcbiAgLi4ud24sXG4gIC4uLlRuXG5dO1xuZnVuY3Rpb24gSmkodCkge1xuICByZXR1cm4gbGguaW5jbHVkZXMoXG4gICAgdFxuICApO1xufVxuY29uc3QgY2ggPSBbXG4gIFwidG9wXCIsXG4gIFwibGVmdFwiLFxuICBcInJpZ2h0XCIsXG4gIFwiYm90dG9tXCIsXG4gIFwic3RhcnRcIixcbiAgXCJlbmRcIixcbiAgXCJzZWxmLXN0YXJ0XCIsXG4gIFwic2VsZi1lbmRcIixcbiAgXCJjZW50ZXJcIixcbiAgXCJpbnNpZGVcIixcbiAgXCJvdXRzaWRlXCJcbl07XG5mdW5jdGlvbiBaaSh0KSB7XG4gIHJldHVybiBjaC5pbmNsdWRlcyh0KTtcbn1cbmNvbnN0IHVoID0gW1xuICBcIndpZHRoXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwiYmxvY2tcIixcbiAgXCJpbmxpbmVcIixcbiAgXCJzZWxmLWJsb2NrXCIsXG4gIFwic2VsZi1pbmxpbmVcIlxuXTtcbmZ1bmN0aW9uIGhoKHQpIHtcbiAgcmV0dXJuIHVoLmluY2x1ZGVzKHQpO1xufVxuY29uc3QgbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJBdHJ1bGVcIiwgXCJTZWxlY3RvclwiLCBcIkRlY2xhcmF0aW9uXCJdKTtcbmZ1bmN0aW9uIGZoKHQpIHtcbiAgY29uc3QgZSA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoKSwgbiA9IHtcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9LCBzID0ge1xuICAgIGxpbmU6IDAsXG4gICAgLy8gc2hvdWxkIGJlIHplcm8gdG8gYWRkIGZpcnN0IG1hcHBpbmdcbiAgICBjb2x1bW46IDBcbiAgfSwgciA9IHtcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9LCBvID0ge1xuICAgIGdlbmVyYXRlZDogclxuICB9O1xuICBsZXQgYSA9IDEsIGwgPSAwLCB1ID0gITE7XG4gIGNvbnN0IGkgPSB0Lm5vZGU7XG4gIHQubm9kZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoZi5sb2MgJiYgZi5sb2Muc3RhcnQgJiYgbnMuaGFzKGYudHlwZSkpIHtcbiAgICAgIGNvbnN0IHAgPSBmLmxvYy5zdGFydC5saW5lLCBkID0gZi5sb2Muc3RhcnQuY29sdW1uIC0gMTtcbiAgICAgIChzLmxpbmUgIT09IHAgfHwgcy5jb2x1bW4gIT09IGQpICYmIChzLmxpbmUgPSBwLCBzLmNvbHVtbiA9IGQsIG4ubGluZSA9IGEsIG4uY29sdW1uID0gbCwgdSAmJiAodSA9ICExLCAobi5saW5lICE9PSByLmxpbmUgfHwgbi5jb2x1bW4gIT09IHIuY29sdW1uKSAmJiBlLmFkZE1hcHBpbmcobykpLCB1ID0gITAsIGUuYWRkTWFwcGluZyh7XG4gICAgICAgIHNvdXJjZTogZi5sb2Muc291cmNlLFxuICAgICAgICBvcmlnaW5hbDogcyxcbiAgICAgICAgZ2VuZXJhdGVkOiBuXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGkuY2FsbCh0aGlzLCBmKSwgdSAmJiBucy5oYXMoZi50eXBlKSAmJiAoci5saW5lID0gYSwgci5jb2x1bW4gPSBsKTtcbiAgfTtcbiAgY29uc3QgYyA9IHQuZW1pdDtcbiAgdC5lbWl0ID0gZnVuY3Rpb24oZiwgcCwgZCkge1xuICAgIGZvciAobGV0IG0gPSAwOyBtIDwgZi5sZW5ndGg7IG0rKylcbiAgICAgIGYuY2hhckNvZGVBdChtKSA9PT0gMTAgPyAoYSsrLCBsID0gMCkgOiBsKys7XG4gICAgYyhmLCBwLCBkKTtcbiAgfTtcbiAgY29uc3QgaCA9IHQucmVzdWx0O1xuICByZXR1cm4gdC5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdSAmJiBlLmFkZE1hcHBpbmcobyksIHtcbiAgICAgIGNzczogaCgpLFxuICAgICAgbWFwOiBlXG4gICAgfTtcbiAgfSwgdDtcbn1cbmNvbnN0IHBoID0gNDMsIGRoID0gNDUsIHFlID0gKHQsIGUpID0+IHtcbiAgaWYgKHQgPT09IEwgJiYgKHQgPSBlKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IG4gPSB0LmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIG4gPiAxMjcgPyAzMjc2OCA6IG4gPDwgODtcbiAgfVxuICByZXR1cm4gdDtcbn0sIHRvID0gW1xuICBbZywgZ10sXG4gIFtnLCBUXSxcbiAgW2csIFFdLFxuICBbZywgYXRdLFxuICBbZywgXCItXCJdLFxuICBbZywgYl0sXG4gIFtnLCBGXSxcbiAgW2csIEVdLFxuICBbZywgbnRdLFxuICBbZywgX10sXG4gIFt6LCBnXSxcbiAgW3osIFRdLFxuICBbeiwgUV0sXG4gIFt6LCBhdF0sXG4gIFt6LCBcIi1cIl0sXG4gIFt6LCBiXSxcbiAgW3osIEZdLFxuICBbeiwgRV0sXG4gIFt6LCBudF0sXG4gIFtJLCBnXSxcbiAgW0ksIFRdLFxuICBbSSwgUV0sXG4gIFtJLCBhdF0sXG4gIFtJLCBcIi1cIl0sXG4gIFtJLCBiXSxcbiAgW0ksIEZdLFxuICBbSSwgRV0sXG4gIFtJLCBudF0sXG4gIFtFLCBnXSxcbiAgW0UsIFRdLFxuICBbRSwgUV0sXG4gIFtFLCBhdF0sXG4gIFtFLCBcIi1cIl0sXG4gIFtFLCBiXSxcbiAgW0UsIEZdLFxuICBbRSwgRV0sXG4gIFtFLCBudF0sXG4gIFtcIiNcIiwgZ10sXG4gIFtcIiNcIiwgVF0sXG4gIFtcIiNcIiwgUV0sXG4gIFtcIiNcIiwgYXRdLFxuICBbXCIjXCIsIFwiLVwiXSxcbiAgW1wiI1wiLCBiXSxcbiAgW1wiI1wiLCBGXSxcbiAgW1wiI1wiLCBFXSxcbiAgW1wiI1wiLCBudF0sXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3Nzd2ctZHJhZnRzL3B1bGwvNjg3NFxuICBbXCItXCIsIGddLFxuICBbXCItXCIsIFRdLFxuICBbXCItXCIsIFFdLFxuICBbXCItXCIsIGF0XSxcbiAgW1wiLVwiLCBcIi1cIl0sXG4gIFtcIi1cIiwgYl0sXG4gIFtcIi1cIiwgRl0sXG4gIFtcIi1cIiwgRV0sXG4gIFtcIi1cIiwgbnRdLFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL2Nzc3dnLWRyYWZ0cy9wdWxsLzY4NzRcbiAgW2IsIGddLFxuICBbYiwgVF0sXG4gIFtiLCBRXSxcbiAgW2IsIGF0XSxcbiAgW2IsIGJdLFxuICBbYiwgRl0sXG4gIFtiLCBFXSxcbiAgW2IsIFwiJVwiXSxcbiAgW2IsIG50XSxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9jc3N3Zy1kcmFmdHMvcHVsbC82ODc0XG4gIFtcIkBcIiwgZ10sXG4gIFtcIkBcIiwgVF0sXG4gIFtcIkBcIiwgUV0sXG4gIFtcIkBcIiwgYXRdLFxuICBbXCJAXCIsIFwiLVwiXSxcbiAgW1wiQFwiLCBudF0sXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvY3Nzd2ctZHJhZnRzL3B1bGwvNjg3NFxuICBbXCIuXCIsIGJdLFxuICBbXCIuXCIsIEZdLFxuICBbXCIuXCIsIEVdLFxuICBbXCIrXCIsIGJdLFxuICBbXCIrXCIsIEZdLFxuICBbXCIrXCIsIEVdLFxuICBbXCIvXCIsIFwiKlwiXVxuXSwgZ2ggPSB0by5jb25jYXQoW1xuICBbZywgSV0sXG4gIFtFLCBJXSxcbiAgW0ksIEldLFxuICBbeiwgX10sXG4gIFt6LCBUdF0sXG4gIFt6LCBYXSxcbiAgW0YsIEZdLFxuICBbRiwgRV0sXG4gIFtGLCBUXSxcbiAgW0YsIFwiLVwiXSxcbiAgW1MsIGddLFxuICBbUywgVF0sXG4gIFtTLCBGXSxcbiAgW1MsIEVdLFxuICBbUywgSV0sXG4gIFtTLCBcIi1cIl1cbl0pO1xuZnVuY3Rpb24gZW8odCkge1xuICBjb25zdCBlID0gbmV3IFNldChcbiAgICB0Lm1hcCgoW24sIHNdKSA9PiBxZShuKSA8PCAxNiB8IHFlKHMpKVxuICApO1xuICByZXR1cm4gZnVuY3Rpb24obiwgcywgcikge1xuICAgIGNvbnN0IG8gPSBxZShzLCByKSwgYSA9IHIuY2hhckNvZGVBdCgwKTtcbiAgICByZXR1cm4gKGEgPT09IGRoICYmIHMgIT09IGcgJiYgcyAhPT0gVCAmJiBzICE9PSBudCB8fCBhID09PSBwaCA/IGUuaGFzKG4gPDwgMTYgfCBhIDw8IDgpIDogZS5oYXMobiA8PCAxNiB8IG8pKSAmJiB0aGlzLmVtaXQoXCIgXCIsIFcsICEwKSwgbztcbiAgfTtcbn1cbmNvbnN0IG1oID0gZW8odG8pLCBubyA9IGVvKGdoKSwgc3MgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzYWZlOiBubyxcbiAgc3BlYzogbWhcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGtoID0gOTI7XG5mdW5jdGlvbiBTaCh0LCBlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgbiA9IG51bGw7XG4gICAgdC5jaGlsZHJlbi5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBuICE9PSBudWxsICYmIGUuY2FsbCh0aGlzLCBuKSwgdGhpcy5ub2RlKHMpLCBuID0gcztcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdC5jaGlsZHJlbi5mb3JFYWNoKHRoaXMubm9kZSwgdGhpcyk7XG59XG5mdW5jdGlvbiB5aCh0KSB7XG4gIFlzKHQsIChlLCBuLCBzKSA9PiB7XG4gICAgdGhpcy50b2tlbihlLCB0LnNsaWNlKG4sIHMpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBiaCh0KSB7XG4gIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBbbiwgc10gb2YgT2JqZWN0LmVudHJpZXModC5ub2RlKSlcbiAgICB0eXBlb2YgKHMuZ2VuZXJhdGUgfHwgcykgPT0gXCJmdW5jdGlvblwiICYmIGUuc2V0KG4sIHMuZ2VuZXJhdGUgfHwgcyk7XG4gIHJldHVybiBmdW5jdGlvbihuLCBzKSB7XG4gICAgbGV0IHIgPSBcIlwiLCBvID0gMCwgYSA9IHtcbiAgICAgIG5vZGUodSkge1xuICAgICAgICBpZiAoZS5oYXModS50eXBlKSlcbiAgICAgICAgICBlLmdldCh1LnR5cGUpLmNhbGwobCwgdSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyB1LnR5cGUpO1xuICAgICAgfSxcbiAgICAgIHRva2VuQmVmb3JlOiBubyxcbiAgICAgIHRva2VuKHUsIGkpIHtcbiAgICAgICAgbyA9IHRoaXMudG9rZW5CZWZvcmUobywgdSwgaSksIHRoaXMuZW1pdChpLCB1LCAhMSksIHUgPT09IEwgJiYgaS5jaGFyQ29kZUF0KDApID09PSBraCAmJiB0aGlzLmVtaXQoYFxuYCwgVywgITApO1xuICAgICAgfSxcbiAgICAgIGVtaXQodSkge1xuICAgICAgICByICs9IHU7XG4gICAgICB9LFxuICAgICAgcmVzdWx0KCkge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHMgJiYgKHR5cGVvZiBzLmRlY29yYXRvciA9PSBcImZ1bmN0aW9uXCIgJiYgKGEgPSBzLmRlY29yYXRvcihhKSksIHMuc291cmNlTWFwICYmIChhID0gZmgoYSkpLCBzLm1vZGUgaW4gc3MgJiYgKGEudG9rZW5CZWZvcmUgPSBzc1tzLm1vZGVdKSk7XG4gICAgY29uc3QgbCA9IHtcbiAgICAgIG5vZGU6ICh1KSA9PiBhLm5vZGUodSksXG4gICAgICBjaGlsZHJlbjogU2gsXG4gICAgICB0b2tlbjogKHUsIGkpID0+IGEudG9rZW4odSwgaSksXG4gICAgICB0b2tlbml6ZTogeWhcbiAgICB9O1xuICAgIHJldHVybiBhLm5vZGUobiksIGEucmVzdWx0KCk7XG4gIH07XG59XG5jb25zdCB4aCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFuUGx1c0I6IEpzLFxuICBBdHJ1bGU6IHRyLFxuICBBdHJ1bGVQcmVsdWRlOiBucixcbiAgQXR0cmlidXRlU2VsZWN0b3I6IGlyLFxuICBCbG9jazogbHIsXG4gIEJyYWNrZXRzOiB1cixcbiAgQ0RDOiBmcixcbiAgQ0RPOiBkcixcbiAgQ2xhc3NTZWxlY3RvcjogbXIsXG4gIENvbWJpbmF0b3I6IFNyLFxuICBDb21tZW50OiBicixcbiAgQ29uZGl0aW9uOiBDcixcbiAgRGVjbGFyYXRpb246IEFyLFxuICBEZWNsYXJhdGlvbkxpc3Q6IEVyLFxuICBEaW1lbnNpb246IExyLFxuICBGZWF0dXJlOiBPcixcbiAgRmVhdHVyZUZ1bmN0aW9uOiBfcixcbiAgRmVhdHVyZVJhbmdlOiBOcixcbiAgRnVuY3Rpb246IEZyLFxuICBHZW5lcmFsRW5jbG9zZWQ6IGpyLFxuICBIYXNoOiBXcixcbiAgSWRTZWxlY3RvcjogSHIsXG4gIElkZW50aWZpZXI6IHpyLFxuICBMYXllcjogcXIsXG4gIExheWVyTGlzdDogUXIsXG4gIE1lZGlhUXVlcnk6IFhyLFxuICBNZWRpYVF1ZXJ5TGlzdDogWnIsXG4gIE5lc3RpbmdTZWxlY3RvcjogZWksXG4gIE50aDogc2ksXG4gIE51bWJlcjogaWksXG4gIE9wZXJhdG9yOiBhaSxcbiAgUGFyZW50aGVzZXM6IGNpLFxuICBQZXJjZW50YWdlOiBoaSxcbiAgUHNldWRvQ2xhc3NTZWxlY3RvcjogcGksXG4gIFBzZXVkb0VsZW1lbnRTZWxlY3RvcjogZ2ksXG4gIFJhdGlvOiBraSxcbiAgUmF3OiB5aSxcbiAgUnVsZTogeGksXG4gIFNjb3BlOiB3aSxcbiAgU2VsZWN0b3I6IEFpLFxuICBTZWxlY3Rvckxpc3Q6IEVpLFxuICBTdHJpbmc6IE9pLFxuICBTdHlsZVNoZWV0OiBfaSxcbiAgU3VwcG9ydHNEZWNsYXJhdGlvbjogTmksXG4gIFR5cGVTZWxlY3RvcjogRmksXG4gIFVuaWNvZGVSYW5nZTogV2ksXG4gIFVybDogVmksXG4gIFZhbHVlOiBHaSxcbiAgV2hpdGVTcGFjZTogS2lcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIENoID0ge1xuICBub2RlOiB4aFxufSwgd2ggPSBiaChDaCk7XG5sZXQgenQgPSBudWxsO1xuY2xhc3MgSyB7XG4gIHN0YXRpYyBjcmVhdGVJdGVtKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJldjogbnVsbCxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBkYXRhOiBlXG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsLCB0aGlzLnRhaWwgPSBudWxsLCB0aGlzLmN1cnNvciA9IG51bGw7XG4gIH1cbiAgY3JlYXRlSXRlbShlKSB7XG4gICAgcmV0dXJuIEsuY3JlYXRlSXRlbShlKTtcbiAgfVxuICAvLyBjdXJzb3IgaGVscGVyc1xuICBhbGxvY2F0ZUN1cnNvcihlLCBuKSB7XG4gICAgbGV0IHM7XG4gICAgcmV0dXJuIHp0ICE9PSBudWxsID8gKHMgPSB6dCwgenQgPSB6dC5jdXJzb3IsIHMucHJldiA9IGUsIHMubmV4dCA9IG4sIHMuY3Vyc29yID0gdGhpcy5jdXJzb3IpIDogcyA9IHtcbiAgICAgIHByZXY6IGUsXG4gICAgICBuZXh0OiBuLFxuICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvclxuICAgIH0sIHRoaXMuY3Vyc29yID0gcywgcztcbiAgfVxuICByZWxlYXNlQ3Vyc29yKCkge1xuICAgIGNvbnN0IHsgY3Vyc29yOiBlIH0gPSB0aGlzO1xuICAgIHRoaXMuY3Vyc29yID0gZS5jdXJzb3IsIGUucHJldiA9IG51bGwsIGUubmV4dCA9IG51bGwsIGUuY3Vyc29yID0genQsIHp0ID0gZTtcbiAgfVxuICB1cGRhdGVDdXJzb3JzKGUsIG4sIHMsIHIpIHtcbiAgICBsZXQgeyBjdXJzb3I6IG8gfSA9IHRoaXM7XG4gICAgZm9yICg7IG8gIT09IG51bGw7IClcbiAgICAgIG8ucHJldiA9PT0gZSAmJiAoby5wcmV2ID0gbiksIG8ubmV4dCA9PT0gcyAmJiAoby5uZXh0ID0gciksIG8gPSBvLmN1cnNvcjtcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgZSA9IHRoaXMuaGVhZDsgZSAhPT0gbnVsbDsgZSA9IGUubmV4dClcbiAgICAgIHlpZWxkIGUuZGF0YTtcbiAgfVxuICAvLyBnZXR0ZXJzXG4gIGdldCBzaXplKCkge1xuICAgIGxldCBlID0gMDtcbiAgICBmb3IgKGxldCBuID0gdGhpcy5oZWFkOyBuICE9PSBudWxsOyBuID0gbi5uZXh0KVxuICAgICAgZSsrO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQgPT09IG51bGw7XG4gIH1cbiAgZ2V0IGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQgJiYgdGhpcy5oZWFkLmRhdGE7XG4gIH1cbiAgZ2V0IGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnRhaWwuZGF0YTtcbiAgfVxuICAvLyBjb252ZXJ0b3JzXG4gIGZyb21BcnJheShlKSB7XG4gICAgbGV0IG4gPSBudWxsO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgZm9yIChsZXQgcyBvZiBlKSB7XG4gICAgICBjb25zdCByID0gSy5jcmVhdGVJdGVtKHMpO1xuICAgICAgbiAhPT0gbnVsbCA/IG4ubmV4dCA9IHIgOiB0aGlzLmhlYWQgPSByLCByLnByZXYgPSBuLCBuID0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9IG4sIHRoaXM7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXNdO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gWy4uLnRoaXNdO1xuICB9XG4gIC8vIGFycmF5LWxpa2UgbWV0aG9kc1xuICBmb3JFYWNoKGUsIG4gPSB0aGlzKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuYWxsb2NhdGVDdXJzb3IobnVsbCwgdGhpcy5oZWFkKTtcbiAgICBmb3IgKDsgcy5uZXh0ICE9PSBudWxsOyApIHtcbiAgICAgIGNvbnN0IHIgPSBzLm5leHQ7XG4gICAgICBzLm5leHQgPSByLm5leHQsIGUuY2FsbChuLCByLmRhdGEsIHIsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnJlbGVhc2VDdXJzb3IoKTtcbiAgfVxuICBmb3JFYWNoUmlnaHQoZSwgbiA9IHRoaXMpIHtcbiAgICBjb25zdCBzID0gdGhpcy5hbGxvY2F0ZUN1cnNvcih0aGlzLnRhaWwsIG51bGwpO1xuICAgIGZvciAoOyBzLnByZXYgIT09IG51bGw7ICkge1xuICAgICAgY29uc3QgciA9IHMucHJldjtcbiAgICAgIHMucHJldiA9IHIucHJldiwgZS5jYWxsKG4sIHIuZGF0YSwgciwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucmVsZWFzZUN1cnNvcigpO1xuICB9XG4gIHJlZHVjZShlLCBuLCBzID0gdGhpcykge1xuICAgIGxldCByID0gdGhpcy5hbGxvY2F0ZUN1cnNvcihudWxsLCB0aGlzLmhlYWQpLCBvID0gbiwgYTtcbiAgICBmb3IgKDsgci5uZXh0ICE9PSBudWxsOyApXG4gICAgICBhID0gci5uZXh0LCByLm5leHQgPSBhLm5leHQsIG8gPSBlLmNhbGwocywgbywgYS5kYXRhLCBhLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWxlYXNlQ3Vyc29yKCksIG87XG4gIH1cbiAgcmVkdWNlUmlnaHQoZSwgbiwgcyA9IHRoaXMpIHtcbiAgICBsZXQgciA9IHRoaXMuYWxsb2NhdGVDdXJzb3IodGhpcy50YWlsLCBudWxsKSwgbyA9IG4sIGE7XG4gICAgZm9yICg7IHIucHJldiAhPT0gbnVsbDsgKVxuICAgICAgYSA9IHIucHJldiwgci5wcmV2ID0gYS5wcmV2LCBvID0gZS5jYWxsKHMsIG8sIGEuZGF0YSwgYSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVsZWFzZUN1cnNvcigpLCBvO1xuICB9XG4gIHNvbWUoZSwgbiA9IHRoaXMpIHtcbiAgICBmb3IgKGxldCBzID0gdGhpcy5oZWFkOyBzICE9PSBudWxsOyBzID0gcy5uZXh0KVxuICAgICAgaWYgKGUuY2FsbChuLCBzLmRhdGEsIHMsIHRoaXMpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG1hcChlLCBuID0gdGhpcykge1xuICAgIGNvbnN0IHMgPSBuZXcgSygpO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLmhlYWQ7IHIgIT09IG51bGw7IHIgPSByLm5leHQpXG4gICAgICBzLmFwcGVuZERhdGEoZS5jYWxsKG4sIHIuZGF0YSwgciwgdGhpcykpO1xuICAgIHJldHVybiBzO1xuICB9XG4gIGZpbHRlcihlLCBuID0gdGhpcykge1xuICAgIGNvbnN0IHMgPSBuZXcgSygpO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLmhlYWQ7IHIgIT09IG51bGw7IHIgPSByLm5leHQpXG4gICAgICBlLmNhbGwobiwgci5kYXRhLCByLCB0aGlzKSAmJiBzLmFwcGVuZERhdGEoci5kYXRhKTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBuZXh0VW50aWwoZSwgbiwgcyA9IHRoaXMpIHtcbiAgICBpZiAoZSA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5hbGxvY2F0ZUN1cnNvcihudWxsLCBlKTtcbiAgICBmb3IgKDsgci5uZXh0ICE9PSBudWxsOyApIHtcbiAgICAgIGNvbnN0IG8gPSByLm5leHQ7XG4gICAgICBpZiAoci5uZXh0ID0gby5uZXh0LCBuLmNhbGwocywgby5kYXRhLCBvLCB0aGlzKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMucmVsZWFzZUN1cnNvcigpO1xuICB9XG4gIHByZXZVbnRpbChlLCBuLCBzID0gdGhpcykge1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLmFsbG9jYXRlQ3Vyc29yKGUsIG51bGwpO1xuICAgIGZvciAoOyByLnByZXYgIT09IG51bGw7ICkge1xuICAgICAgY29uc3QgbyA9IHIucHJldjtcbiAgICAgIGlmIChyLnByZXYgPSBvLnByZXYsIG4uY2FsbChzLCBvLmRhdGEsIG8sIHRoaXMpKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5yZWxlYXNlQ3Vyc29yKCk7XG4gIH1cbiAgLy8gbXV0YXRpb25cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbCwgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuICBjb3B5KCkge1xuICAgIGNvbnN0IGUgPSBuZXcgSygpO1xuICAgIGZvciAobGV0IG4gb2YgdGhpcylcbiAgICAgIGUuYXBwZW5kRGF0YShuKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBwcmVwZW5kKGUpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVDdXJzb3JzKG51bGwsIGUsIHRoaXMuaGVhZCwgZSksIHRoaXMuaGVhZCAhPT0gbnVsbCA/ICh0aGlzLmhlYWQucHJldiA9IGUsIGUubmV4dCA9IHRoaXMuaGVhZCkgOiB0aGlzLnRhaWwgPSBlLCB0aGlzLmhlYWQgPSBlLCB0aGlzO1xuICB9XG4gIHByZXBlbmREYXRhKGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcmVwZW5kKEsuY3JlYXRlSXRlbShlKSk7XG4gIH1cbiAgYXBwZW5kKGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoZSk7XG4gIH1cbiAgYXBwZW5kRGF0YShlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KEsuY3JlYXRlSXRlbShlKSk7XG4gIH1cbiAgaW5zZXJ0KGUsIG4gPSBudWxsKSB7XG4gICAgaWYgKG4gIT09IG51bGwpXG4gICAgICBpZiAodGhpcy51cGRhdGVDdXJzb3JzKG4ucHJldiwgZSwgbiwgZSksIG4ucHJldiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBuKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZm9yZSBkb2Vzbid0IGJlbG9uZyB0byBsaXN0XCIpO1xuICAgICAgICB0aGlzLmhlYWQgPSBlLCBuLnByZXYgPSBlLCBlLm5leHQgPSBuLCB0aGlzLnVwZGF0ZUN1cnNvcnMobnVsbCwgZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbi5wcmV2Lm5leHQgPSBlLCBlLnByZXYgPSBuLnByZXYsIG4ucHJldiA9IGUsIGUubmV4dCA9IG47XG4gICAgZWxzZVxuICAgICAgdGhpcy51cGRhdGVDdXJzb3JzKHRoaXMudGFpbCwgZSwgbnVsbCwgZSksIHRoaXMudGFpbCAhPT0gbnVsbCA/ICh0aGlzLnRhaWwubmV4dCA9IGUsIGUucHJldiA9IHRoaXMudGFpbCkgOiB0aGlzLmhlYWQgPSBlLCB0aGlzLnRhaWwgPSBlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluc2VydERhdGEoZSwgbikge1xuICAgIHJldHVybiB0aGlzLmluc2VydChLLmNyZWF0ZUl0ZW0oZSksIG4pO1xuICB9XG4gIHJlbW92ZShlKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlQ3Vyc29ycyhlLCBlLnByZXYsIGUsIGUubmV4dCksIGUucHJldiAhPT0gbnVsbClcbiAgICAgIGUucHJldi5uZXh0ID0gZS5uZXh0O1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaGVhZCAhPT0gZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXRlbSBkb2Vzbid0IGJlbG9uZyB0byBsaXN0XCIpO1xuICAgICAgdGhpcy5oZWFkID0gZS5uZXh0O1xuICAgIH1cbiAgICBpZiAoZS5uZXh0ICE9PSBudWxsKVxuICAgICAgZS5uZXh0LnByZXYgPSBlLnByZXY7XG4gICAgZWxzZSB7XG4gICAgICBpZiAodGhpcy50YWlsICE9PSBlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpdGVtIGRvZXNuJ3QgYmVsb25nIHRvIGxpc3RcIik7XG4gICAgICB0aGlzLnRhaWwgPSBlLnByZXY7XG4gICAgfVxuICAgIHJldHVybiBlLnByZXYgPSBudWxsLCBlLm5leHQgPSBudWxsLCBlO1xuICB9XG4gIHB1c2goZSkge1xuICAgIHRoaXMuaW5zZXJ0KEsuY3JlYXRlSXRlbShlKSk7XG4gIH1cbiAgcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgIT09IG51bGwgPyB0aGlzLnJlbW92ZSh0aGlzLnRhaWwpIDogbnVsbDtcbiAgfVxuICB1bnNoaWZ0KGUpIHtcbiAgICB0aGlzLnByZXBlbmQoSy5jcmVhdGVJdGVtKGUpKTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkICE9PSBudWxsID8gdGhpcy5yZW1vdmUodGhpcy5oZWFkKSA6IG51bGw7XG4gIH1cbiAgcHJlcGVuZExpc3QoZSkge1xuICAgIHJldHVybiB0aGlzLmluc2VydExpc3QoZSwgdGhpcy5oZWFkKTtcbiAgfVxuICBhcHBlbmRMaXN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRMaXN0KGUpO1xuICB9XG4gIGluc2VydExpc3QoZSwgbikge1xuICAgIHJldHVybiBlLmhlYWQgPT09IG51bGwgPyB0aGlzIDogKG4gIT0gbnVsbCA/ICh0aGlzLnVwZGF0ZUN1cnNvcnMobi5wcmV2LCBlLnRhaWwsIG4sIGUuaGVhZCksIG4ucHJldiAhPT0gbnVsbCA/IChuLnByZXYubmV4dCA9IGUuaGVhZCwgZS5oZWFkLnByZXYgPSBuLnByZXYpIDogdGhpcy5oZWFkID0gZS5oZWFkLCBuLnByZXYgPSBlLnRhaWwsIGUudGFpbC5uZXh0ID0gbikgOiAodGhpcy51cGRhdGVDdXJzb3JzKHRoaXMudGFpbCwgZS50YWlsLCBudWxsLCBlLmhlYWQpLCB0aGlzLnRhaWwgIT09IG51bGwgPyAodGhpcy50YWlsLm5leHQgPSBlLmhlYWQsIGUuaGVhZC5wcmV2ID0gdGhpcy50YWlsKSA6IHRoaXMuaGVhZCA9IGUuaGVhZCwgdGhpcy50YWlsID0gZS50YWlsKSwgZS5oZWFkID0gbnVsbCwgZS50YWlsID0gbnVsbCwgdGhpcyk7XG4gIH1cbiAgcmVwbGFjZShlLCBuKSB7XG4gICAgXCJoZWFkXCIgaW4gbiA/IHRoaXMuaW5zZXJ0TGlzdChuLCBlKSA6IHRoaXMuaW5zZXJ0KG4sIGUpLCB0aGlzLnJlbW92ZShlKTtcbiAgfVxufVxuZnVuY3Rpb24gVGgodCwgZSkge1xuICBjb25zdCBuID0gT2JqZWN0LmNyZWF0ZShTeW50YXhFcnJvci5wcm90b3R5cGUpLCBzID0gbmV3IEVycm9yKCk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG4sIHtcbiAgICBuYW1lOiB0LFxuICAgIG1lc3NhZ2U6IGUsXG4gICAgZ2V0IHN0YWNrKCkge1xuICAgICAgcmV0dXJuIChzLnN0YWNrIHx8IFwiXCIpLnJlcGxhY2UoL14oLitcXG4pezEsM30vLCBgJHt0fTogJHtlfVxuYCk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IEtlID0gMTAwLCBycyA9IDYwLCBpcyA9IFwiICAgIFwiO1xuZnVuY3Rpb24gb3MoeyBzb3VyY2U6IHQsIGxpbmU6IGUsIGNvbHVtbjogbiwgYmFzZUxpbmU6IHMsIGJhc2VDb2x1bW46IHIgfSwgbykge1xuICBmdW5jdGlvbiBhKGQsIG0pIHtcbiAgICByZXR1cm4gaS5zbGljZShkLCBtKS5tYXAoXG4gICAgICAoaywgeSkgPT4gU3RyaW5nKGQgKyB5ICsgMSkucGFkU3RhcnQoZikgKyBcIiB8XCIgKyBrXG4gICAgKS5qb2luKGBcbmApO1xuICB9XG4gIGNvbnN0IGwgPSBgXG5gLnJlcGVhdChNYXRoLm1heChzIC0gMSwgMCkpLCB1ID0gXCIgXCIucmVwZWF0KE1hdGgubWF4KHIgLSAxLCAwKSksIGkgPSAobCArIHUgKyB0KS5zcGxpdCgvXFxyXFxuP3xcXG58XFxmLyksIGMgPSBNYXRoLm1heCgxLCBlIC0gbykgLSAxLCBoID0gTWF0aC5taW4oZSArIG8sIGkubGVuZ3RoICsgMSksIGYgPSBNYXRoLm1heCg0LCBTdHJpbmcoaCkubGVuZ3RoKSArIDE7XG4gIGxldCBwID0gMDtcbiAgbiArPSAoaXMubGVuZ3RoIC0gMSkgKiAoaVtlIC0gMV0uc3Vic3RyKDAsIG4gLSAxKS5tYXRjaCgvXFx0L2cpIHx8IFtdKS5sZW5ndGgsIG4gPiBLZSAmJiAocCA9IG4gLSBycyArIDMsIG4gPSBycyAtIDIpO1xuICBmb3IgKGxldCBkID0gYzsgZCA8PSBoOyBkKyspXG4gICAgZCA+PSAwICYmIGQgPCBpLmxlbmd0aCAmJiAoaVtkXSA9IGlbZF0ucmVwbGFjZSgvXFx0L2csIGlzKSwgaVtkXSA9IChwID4gMCAmJiBpW2RdLmxlbmd0aCA+IHAgPyBcIuKAplwiIDogXCJcIikgKyBpW2RdLnN1YnN0cihwLCBLZSAtIDIpICsgKGlbZF0ubGVuZ3RoID4gcCArIEtlIC0gMSA/IFwi4oCmXCIgOiBcIlwiKSk7XG4gIHJldHVybiBbXG4gICAgYShjLCBlKSxcbiAgICBuZXcgQXJyYXkobiArIGYgKyAyKS5qb2luKFwiLVwiKSArIFwiXlwiLFxuICAgIGEoZSwgaClcbiAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihgXG5gKS5yZXBsYWNlKC9eKFxccytcXGQrXFxzK1xcfFxcbikrLywgXCJcIikucmVwbGFjZSgvXFxuKFxccytcXGQrXFxzK1xcfCkrJC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gYXModCwgZSwgbiwgcywgciwgbyA9IDEsIGEgPSAxKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFRoKFwiU3ludGF4RXJyb3JcIiwgdCksIHtcbiAgICBzb3VyY2U6IGUsXG4gICAgb2Zmc2V0OiBuLFxuICAgIGxpbmU6IHMsXG4gICAgY29sdW1uOiByLFxuICAgIHNvdXJjZUZyYWdtZW50KHUpIHtcbiAgICAgIHJldHVybiBvcyh7IHNvdXJjZTogZSwgbGluZTogcywgY29sdW1uOiByLCBiYXNlTGluZTogbywgYmFzZUNvbHVtbjogYSB9LCBpc05hTih1KSA/IDAgOiB1KTtcbiAgICB9LFxuICAgIGdldCBmb3JtYXR0ZWRNZXNzYWdlKCkge1xuICAgICAgcmV0dXJuIGBQYXJzZSBlcnJvcjogJHt0fVxuYCArIG9zKHsgc291cmNlOiBlLCBsaW5lOiBzLCBjb2x1bW46IHIsIGJhc2VMaW5lOiBvLCBiYXNlQ29sdW1uOiBhIH0sIDIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBBaCh0KSB7XG4gIGNvbnN0IGUgPSB0aGlzLmNyZWF0ZUxpc3QoKTtcbiAgbGV0IG4gPSAhMTtcbiAgY29uc3QgcyA9IHtcbiAgICByZWNvZ25pemVyOiB0XG4gIH07XG4gIGZvciAoOyAhdGhpcy5lb2Y7ICkge1xuICAgIHN3aXRjaCAodGhpcy50b2tlblR5cGUpIHtcbiAgICAgIGNhc2UgWTpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBXOlxuICAgICAgICBuID0gITAsIHRoaXMubmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHIgPSB0LmdldE5vZGUuY2FsbCh0aGlzLCBzKTtcbiAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgYnJlYWs7XG4gICAgbiAmJiAodC5vbldoaXRlU3BhY2UgJiYgdC5vbldoaXRlU3BhY2UuY2FsbCh0aGlzLCByLCBlLCBzKSwgbiA9ICExKSwgZS5wdXNoKHIpO1xuICB9XG4gIHJldHVybiBuICYmIHQub25XaGl0ZVNwYWNlICYmIHQub25XaGl0ZVNwYWNlLmNhbGwodGhpcywgbnVsbCwgZSwgcyksIGU7XG59XG5jb25zdCBscyA9ICgpID0+IHtcbn0sIHZoID0gMzMsIEVoID0gMzUsIFFlID0gNTksIGNzID0gMTIzLCB1cyA9IDA7XG5mdW5jdGlvbiAkaCh0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0XSgpO1xuICB9O1xufVxuZnVuY3Rpb24gWWUodCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgbiBvZiBPYmplY3Qua2V5cyh0KSkge1xuICAgIGNvbnN0IHMgPSB0W25dLCByID0gcy5wYXJzZSB8fCBzO1xuICAgIHIgJiYgKGVbbl0gPSByKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIExoKHQpIHtcbiAgY29uc3QgZSA9IHtcbiAgICBjb250ZXh0OiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBmZWF0dXJlczogT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdC5mZWF0dXJlcyksXG4gICAgc2NvcGU6IE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHQuc2NvcGUpLFxuICAgIGF0cnVsZTogWWUodC5hdHJ1bGUpLFxuICAgIHBzZXVkbzogWWUodC5wc2V1ZG8pLFxuICAgIG5vZGU6IFllKHQubm9kZSlcbiAgfTtcbiAgZm9yIChjb25zdCBbbiwgc10gb2YgT2JqZWN0LmVudHJpZXModC5wYXJzZUNvbnRleHQpKVxuICAgIHN3aXRjaCAodHlwZW9mIHMpIHtcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBlLmNvbnRleHRbbl0gPSBzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgZS5jb250ZXh0W25dID0gJGgocyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFUoVSh7XG4gICAgY29uZmlnOiBlXG4gIH0sIGUpLCBlLm5vZGUpO1xufVxuZnVuY3Rpb24gUGgodCkge1xuICBsZXQgZSA9IFwiXCIsIG4gPSBcIjx1bmtub3duPlwiLCBzID0gITEsIHIgPSBscywgbyA9ICExO1xuICBjb25zdCBhID0gbmV3IHVhKCksIGwgPSBPYmplY3QuYXNzaWduKG5ldyBoYSgpLCBMaCh0IHx8IHt9KSwge1xuICAgIHBhcnNlQXRydWxlUHJlbHVkZTogITAsXG4gICAgcGFyc2VSdWxlUHJlbHVkZTogITAsXG4gICAgcGFyc2VWYWx1ZTogITAsXG4gICAgcGFyc2VDdXN0b21Qcm9wZXJ0eTogITEsXG4gICAgcmVhZFNlcXVlbmNlOiBBaCxcbiAgICBjb25zdW1lVW50aWxCYWxhbmNlRW5kOiAoKSA9PiAwLFxuICAgIGNvbnN1bWVVbnRpbExlZnRDdXJseUJyYWNrZXQoaSkge1xuICAgICAgcmV0dXJuIGkgPT09IGNzID8gMSA6IDA7XG4gICAgfSxcbiAgICBjb25zdW1lVW50aWxMZWZ0Q3VybHlCcmFja2V0T3JTZW1pY29sb24oaSkge1xuICAgICAgcmV0dXJuIGkgPT09IGNzIHx8IGkgPT09IFFlID8gMSA6IDA7XG4gICAgfSxcbiAgICBjb25zdW1lVW50aWxFeGNsYW1hdGlvbk1hcmtPclNlbWljb2xvbihpKSB7XG4gICAgICByZXR1cm4gaSA9PT0gdmggfHwgaSA9PT0gUWUgPyAxIDogMDtcbiAgICB9LFxuICAgIGNvbnN1bWVVbnRpbFNlbWljb2xvbkluY2x1ZGVkKGkpIHtcbiAgICAgIHJldHVybiBpID09PSBRZSA/IDIgOiAwO1xuICAgIH0sXG4gICAgY3JlYXRlTGlzdCgpIHtcbiAgICAgIHJldHVybiBuZXcgSygpO1xuICAgIH0sXG4gICAgY3JlYXRlU2luZ2xlTm9kZUxpc3QoaSkge1xuICAgICAgcmV0dXJuIG5ldyBLKCkuYXBwZW5kRGF0YShpKTtcbiAgICB9LFxuICAgIGdldEZpcnN0TGlzdE5vZGUoaSkge1xuICAgICAgcmV0dXJuIGkgJiYgaS5maXJzdDtcbiAgICB9LFxuICAgIGdldExhc3RMaXN0Tm9kZShpKSB7XG4gICAgICByZXR1cm4gaSAmJiBpLmxhc3Q7XG4gICAgfSxcbiAgICBwYXJzZVdpdGhGYWxsYmFjayhpLCBjKSB7XG4gICAgICBjb25zdCBoID0gdGhpcy50b2tlbkluZGV4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGkuY2FsbCh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgdGhyb3cgZjtcbiAgICAgICAgdGhpcy5za2lwKGggLSB0aGlzLnRva2VuSW5kZXgpO1xuICAgICAgICBjb25zdCBwID0gYy5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gbyA9ICEwLCByKGYsIHApLCBvID0gITEsIHA7XG4gICAgICB9XG4gICAgfSxcbiAgICBsb29rdXBOb25XU1R5cGUoaSkge1xuICAgICAgbGV0IGM7XG4gICAgICBkb1xuICAgICAgICBpZiAoYyA9IHRoaXMubG9va3VwVHlwZShpKyspLCBjICE9PSBXICYmIGMgIT09IFkpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB3aGlsZSAoYyAhPT0gdXMpO1xuICAgICAgcmV0dXJuIHVzO1xuICAgIH0sXG4gICAgY2hhckNvZGVBdChpKSB7XG4gICAgICByZXR1cm4gaSA+PSAwICYmIGkgPCBlLmxlbmd0aCA/IGUuY2hhckNvZGVBdChpKSA6IDA7XG4gICAgfSxcbiAgICBzdWJzdHJpbmcoaSwgYykge1xuICAgICAgcmV0dXJuIGUuc3Vic3RyaW5nKGksIGMpO1xuICAgIH0sXG4gICAgc3Vic3RyVG9DdXJzb3IoaSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnN0cmluZyhpLCB0aGlzLnRva2VuU3RhcnQpO1xuICAgIH0sXG4gICAgY21wQ2hhcihpLCBjKSB7XG4gICAgICByZXR1cm4gR3MoZSwgaSwgYyk7XG4gICAgfSxcbiAgICBjbXBTdHIoaSwgYywgaCkge1xuICAgICAgcmV0dXJuICRlKGUsIGksIGMsIGgpO1xuICAgIH0sXG4gICAgY29uc3VtZShpKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy50b2tlblN0YXJ0O1xuICAgICAgcmV0dXJuIHRoaXMuZWF0KGkpLCB0aGlzLnN1YnN0clRvQ3Vyc29yKGMpO1xuICAgIH0sXG4gICAgY29uc3VtZUZ1bmN0aW9uTmFtZSgpIHtcbiAgICAgIGNvbnN0IGkgPSBlLnN1YnN0cmluZyh0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQgLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLmVhdChUKSwgaTtcbiAgICB9LFxuICAgIGNvbnN1bWVOdW1iZXIoaSkge1xuICAgICAgY29uc3QgYyA9IGUuc3Vic3RyaW5nKHRoaXMudG9rZW5TdGFydCwgcXMoZSwgdGhpcy50b2tlblN0YXJ0KSk7XG4gICAgICByZXR1cm4gdGhpcy5lYXQoaSksIGM7XG4gICAgfSxcbiAgICBlYXQoaSkge1xuICAgICAgaWYgKHRoaXMudG9rZW5UeXBlICE9PSBpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBRc1tpXS5zbGljZSgwLCAtNikucmVwbGFjZSgvLS9nLCBcIiBcIikucmVwbGFjZSgvXi4vLCAocCkgPT4gcC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgbGV0IGggPSBgJHsvW1tcXF0oKXt9XS8udGVzdChjKSA/IGBcIiR7Y31cImAgOiBjfSBpcyBleHBlY3RlZGAsIGYgPSB0aGlzLnRva2VuU3RhcnQ7XG4gICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlID09PSBUIHx8IHRoaXMudG9rZW5UeXBlID09PSBRID8gKGYgPSB0aGlzLnRva2VuRW5kIC0gMSwgaCA9IFwiSWRlbnRpZmllciBpcyBleHBlY3RlZCBidXQgZnVuY3Rpb24gZm91bmRcIikgOiBoID0gXCJJZGVudGlmaWVyIGlzIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEk6XG4gICAgICAgICAgICB0aGlzLmlzRGVsaW0oRWgpICYmICh0aGlzLm5leHQoKSwgZisrLCBoID0gXCJOYW1lIGlzIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBGOlxuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPT09IGIgJiYgKGYgPSB0aGlzLnRva2VuRW5kLCBoID0gXCJQZXJjZW50IHNpZ24gaXMgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVycm9yKGgsIGYpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSxcbiAgICBlYXRJZGVudChpKSB7XG4gICAgICAodGhpcy50b2tlblR5cGUgIT09IGcgfHwgdGhpcy5sb29rdXBWYWx1ZSgwLCBpKSA9PT0gITEpICYmIHRoaXMuZXJyb3IoYElkZW50aWZpZXIgXCIke2l9XCIgaXMgZXhwZWN0ZWRgKSwgdGhpcy5uZXh0KCk7XG4gICAgfSxcbiAgICBlYXREZWxpbShpKSB7XG4gICAgICB0aGlzLmlzRGVsaW0oaSkgfHwgdGhpcy5lcnJvcihgRGVsaW0gXCIke1N0cmluZy5mcm9tQ2hhckNvZGUoaSl9XCIgaXMgZXhwZWN0ZWRgKSwgdGhpcy5uZXh0KCk7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbihpLCBjKSB7XG4gICAgICByZXR1cm4gcyA/IGEuZ2V0TG9jYXRpb25SYW5nZShcbiAgICAgICAgaSxcbiAgICAgICAgYyxcbiAgICAgICAgblxuICAgICAgKSA6IG51bGw7XG4gICAgfSxcbiAgICBnZXRMb2NhdGlvbkZyb21MaXN0KGkpIHtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldEZpcnN0TGlzdE5vZGUoaSksIGggPSB0aGlzLmdldExhc3RMaXN0Tm9kZShpKTtcbiAgICAgICAgcmV0dXJuIGEuZ2V0TG9jYXRpb25SYW5nZShcbiAgICAgICAgICBjICE9PSBudWxsID8gYy5sb2Muc3RhcnQub2Zmc2V0IC0gYS5zdGFydE9mZnNldCA6IHRoaXMudG9rZW5TdGFydCxcbiAgICAgICAgICBoICE9PSBudWxsID8gaC5sb2MuZW5kLm9mZnNldCAtIGEuc3RhcnRPZmZzZXQgOiB0aGlzLnRva2VuU3RhcnQsXG4gICAgICAgICAgblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBlcnJvcihpLCBjKSB7XG4gICAgICBjb25zdCBoID0gdHlwZW9mIGMgIT0gXCJ1bmRlZmluZWRcIiAmJiBjIDwgZS5sZW5ndGggPyBhLmdldExvY2F0aW9uKGMpIDogdGhpcy5lb2YgPyBhLmdldExvY2F0aW9uKGFhKGUsIGUubGVuZ3RoIC0gMSkpIDogYS5nZXRMb2NhdGlvbih0aGlzLnRva2VuU3RhcnQpO1xuICAgICAgdGhyb3cgbmV3IGFzKFxuICAgICAgICBpIHx8IFwiVW5leHBlY3RlZCBpbnB1dFwiLFxuICAgICAgICBlLFxuICAgICAgICBoLm9mZnNldCxcbiAgICAgICAgaC5saW5lLFxuICAgICAgICBoLmNvbHVtbixcbiAgICAgICAgYS5zdGFydExpbmUsXG4gICAgICAgIGEuc3RhcnRDb2x1bW5cbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24oaSwgYykge1xuICAgIGUgPSBpLCBjID0gYyB8fCB7fSwgbC5zZXRTb3VyY2UoZSwgWXMpLCBhLnNldFNvdXJjZShcbiAgICAgIGUsXG4gICAgICBjLm9mZnNldCxcbiAgICAgIGMubGluZSxcbiAgICAgIGMuY29sdW1uXG4gICAgKSwgbiA9IGMuZmlsZW5hbWUgfHwgXCI8dW5rbm93bj5cIiwgcyA9ICEhYy5wb3NpdGlvbnMsIHIgPSB0eXBlb2YgYy5vblBhcnNlRXJyb3IgPT0gXCJmdW5jdGlvblwiID8gYy5vblBhcnNlRXJyb3IgOiBscywgbyA9ICExLCBsLnBhcnNlQXRydWxlUHJlbHVkZSA9IFwicGFyc2VBdHJ1bGVQcmVsdWRlXCIgaW4gYyA/ICEhYy5wYXJzZUF0cnVsZVByZWx1ZGUgOiAhMCwgbC5wYXJzZVJ1bGVQcmVsdWRlID0gXCJwYXJzZVJ1bGVQcmVsdWRlXCIgaW4gYyA/ICEhYy5wYXJzZVJ1bGVQcmVsdWRlIDogITAsIGwucGFyc2VWYWx1ZSA9IFwicGFyc2VWYWx1ZVwiIGluIGMgPyAhIWMucGFyc2VWYWx1ZSA6ICEwLCBsLnBhcnNlQ3VzdG9tUHJvcGVydHkgPSBcInBhcnNlQ3VzdG9tUHJvcGVydHlcIiBpbiBjID8gISFjLnBhcnNlQ3VzdG9tUHJvcGVydHkgOiAhMTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGggPSBcImRlZmF1bHRcIiwgb25Db21tZW50OiBmIH0gPSBjO1xuICAgIGlmICghKGggaW4gbC5jb250ZXh0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29udGV4dCBgXCIgKyBoICsgXCJgXCIpO1xuICAgIHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIiAmJiBsLmZvckVhY2hUb2tlbigoZCwgbSwgaykgPT4ge1xuICAgICAgaWYgKGQgPT09IFkpIHtcbiAgICAgICAgY29uc3QgeSA9IGwuZ2V0TG9jYXRpb24obSwgayksIHggPSAkZShlLCBrIC0gMiwgaywgXCIqL1wiKSA/IGUuc2xpY2UobSArIDIsIGsgLSAyKSA6IGUuc2xpY2UobSArIDIsIGspO1xuICAgICAgICBmKHgsIHkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHAgPSBsLmNvbnRleHRbaF0uY2FsbChsLCBjKTtcbiAgICByZXR1cm4gbC5lb2YgfHwgbC5lcnJvcigpLCBwO1xuICB9LCB7XG4gICAgU3ludGF4RXJyb3I6IGFzLFxuICAgIGNvbmZpZzogbC5jb25maWdcbiAgfSk7XG59XG5jb25zdCBPaCA9IDM1LCBSaCA9IDQyLCBocyA9IDQzLCBfaCA9IDQ1LCBJaCA9IDQ3LCBOaCA9IDExNztcbmZ1bmN0aW9uIHNvKHQpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuVHlwZSkge1xuICAgIGNhc2UgSTpcbiAgICAgIHJldHVybiB0aGlzLkhhc2goKTtcbiAgICBjYXNlIGZ0OlxuICAgICAgcmV0dXJuIHRoaXMuT3BlcmF0b3IoKTtcbiAgICBjYXNlIF86XG4gICAgICByZXR1cm4gdGhpcy5QYXJlbnRoZXNlcyh0aGlzLnJlYWRTZXF1ZW5jZSwgdC5yZWNvZ25pemVyKTtcbiAgICBjYXNlIGVlOlxuICAgICAgcmV0dXJuIHRoaXMuQnJhY2tldHModGhpcy5yZWFkU2VxdWVuY2UsIHQucmVjb2duaXplcik7XG4gICAgY2FzZSBUdDpcbiAgICAgIHJldHVybiB0aGlzLlN0cmluZygpO1xuICAgIGNhc2UgRTpcbiAgICAgIHJldHVybiB0aGlzLkRpbWVuc2lvbigpO1xuICAgIGNhc2UgRjpcbiAgICAgIHJldHVybiB0aGlzLlBlcmNlbnRhZ2UoKTtcbiAgICBjYXNlIGI6XG4gICAgICByZXR1cm4gdGhpcy5OdW1iZXIoKTtcbiAgICBjYXNlIFQ6XG4gICAgICByZXR1cm4gdGhpcy5jbXBTdHIodGhpcy50b2tlblN0YXJ0LCB0aGlzLnRva2VuRW5kLCBcInVybChcIikgPyB0aGlzLlVybCgpIDogdGhpcy5GdW5jdGlvbih0aGlzLnJlYWRTZXF1ZW5jZSwgdC5yZWNvZ25pemVyKTtcbiAgICBjYXNlIFE6XG4gICAgICByZXR1cm4gdGhpcy5VcmwoKTtcbiAgICBjYXNlIGc6XG4gICAgICByZXR1cm4gdGhpcy5jbXBDaGFyKHRoaXMudG9rZW5TdGFydCwgTmgpICYmIHRoaXMuY21wQ2hhcih0aGlzLnRva2VuU3RhcnQgKyAxLCBocykgPyB0aGlzLlVuaWNvZGVSYW5nZSgpIDogdGhpcy5JZGVudGlmaWVyKCk7XG4gICAgY2FzZSBMOiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5jaGFyQ29kZUF0KHRoaXMudG9rZW5TdGFydCk7XG4gICAgICBpZiAoZSA9PT0gSWggfHwgZSA9PT0gUmggfHwgZSA9PT0gaHMgfHwgZSA9PT0gX2gpXG4gICAgICAgIHJldHVybiB0aGlzLk9wZXJhdG9yKCk7XG4gICAgICBlID09PSBPaCAmJiB0aGlzLmVycm9yKFwiSGV4IG9yIGlkZW50aWZpZXIgaXMgZXhwZWN0ZWRcIiwgdGhpcy50b2tlblN0YXJ0ICsgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmNvbnN0IERoID0ge1xuICBnZXROb2RlOiBzb1xufSwgRmggPSAzNSwgTWggPSAzOCwgamggPSA0MiwgQmggPSA0MywgV2ggPSA0NywgZnMgPSA0NiwgVWggPSA2MiwgemggPSAxMjQsIFZoID0gMTI2O1xuZnVuY3Rpb24gSGgodCwgZSkge1xuICBlLmxhc3QgIT09IG51bGwgJiYgZS5sYXN0LnR5cGUgIT09IFwiQ29tYmluYXRvclwiICYmIHQgIT09IG51bGwgJiYgdC50eXBlICE9PSBcIkNvbWJpbmF0b3JcIiAmJiBlLnB1c2goe1xuICAgIC8vIEZJWE1FOiB0aGlzLkNvbWJpbmF0b3IoKSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgdHlwZTogXCJDb21iaW5hdG9yXCIsXG4gICAgbG9jOiBudWxsLFxuICAgIG5hbWU6IFwiIFwiXG4gIH0pO1xufVxuZnVuY3Rpb24gR2goKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlblR5cGUpIHtcbiAgICBjYXNlIGVlOlxuICAgICAgcmV0dXJuIHRoaXMuQXR0cmlidXRlU2VsZWN0b3IoKTtcbiAgICBjYXNlIEk6XG4gICAgICByZXR1cm4gdGhpcy5JZFNlbGVjdG9yKCk7XG4gICAgY2FzZSBYOlxuICAgICAgcmV0dXJuIHRoaXMubG9va3VwVHlwZSgxKSA9PT0gWCA/IHRoaXMuUHNldWRvRWxlbWVudFNlbGVjdG9yKCkgOiB0aGlzLlBzZXVkb0NsYXNzU2VsZWN0b3IoKTtcbiAgICBjYXNlIGc6XG4gICAgICByZXR1cm4gdGhpcy5UeXBlU2VsZWN0b3IoKTtcbiAgICBjYXNlIGI6XG4gICAgY2FzZSBGOlxuICAgICAgcmV0dXJuIHRoaXMuUGVyY2VudGFnZSgpO1xuICAgIGNhc2UgRTpcbiAgICAgIHRoaXMuY2hhckNvZGVBdCh0aGlzLnRva2VuU3RhcnQpID09PSBmcyAmJiB0aGlzLmVycm9yKFwiSWRlbnRpZmllciBpcyBleHBlY3RlZFwiLCB0aGlzLnRva2VuU3RhcnQgKyAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTDoge1xuICAgICAgc3dpdGNoICh0aGlzLmNoYXJDb2RlQXQodGhpcy50b2tlblN0YXJ0KSkge1xuICAgICAgICBjYXNlIEJoOlxuICAgICAgICBjYXNlIFVoOlxuICAgICAgICBjYXNlIFZoOlxuICAgICAgICBjYXNlIFdoOlxuICAgICAgICAgIHJldHVybiB0aGlzLkNvbWJpbmF0b3IoKTtcbiAgICAgICAgY2FzZSBmczpcbiAgICAgICAgICByZXR1cm4gdGhpcy5DbGFzc1NlbGVjdG9yKCk7XG4gICAgICAgIGNhc2Ugamg6XG4gICAgICAgIGNhc2Ugemg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuVHlwZVNlbGVjdG9yKCk7XG4gICAgICAgIGNhc2UgRmg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuSWRTZWxlY3RvcigpO1xuICAgICAgICBjYXNlIE1oOlxuICAgICAgICAgIHJldHVybiB0aGlzLk5lc3RpbmdTZWxlY3RvcigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5jb25zdCBxaCA9IHtcbiAgb25XaGl0ZVNwYWNlOiBIaCxcbiAgZ2V0Tm9kZTogR2hcbn07XG5mdW5jdGlvbiBLaCgpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgdGhpcy5SYXcobnVsbCwgITEpXG4gICk7XG59XG5mdW5jdGlvbiBRaCgpIHtcbiAgY29uc3QgdCA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICBpZiAodGhpcy5za2lwU0MoKSwgdC5wdXNoKHRoaXMuSWRlbnRpZmllcigpKSwgdGhpcy5za2lwU0MoKSwgdGhpcy50b2tlblR5cGUgPT09IGZ0KSB7XG4gICAgdC5wdXNoKHRoaXMuT3BlcmF0b3IoKSk7XG4gICAgY29uc3QgZSA9IHRoaXMudG9rZW5JbmRleCwgbiA9IHRoaXMucGFyc2VDdXN0b21Qcm9wZXJ0eSA/IHRoaXMuVmFsdWUobnVsbCkgOiB0aGlzLlJhdyh0aGlzLmNvbnN1bWVVbnRpbEV4Y2xhbWF0aW9uTWFya09yU2VtaWNvbG9uLCAhMSk7XG4gICAgaWYgKG4udHlwZSA9PT0gXCJWYWx1ZVwiICYmIG4uY2hpbGRyZW4uaXNFbXB0eSkge1xuICAgICAgZm9yIChsZXQgcyA9IGUgLSB0aGlzLnRva2VuSW5kZXg7IHMgPD0gMDsgcysrKVxuICAgICAgICBpZiAodGhpcy5sb29rdXBUeXBlKHMpID09PSBXKSB7XG4gICAgICAgICAgbi5jaGlsZHJlbi5hcHBlbmREYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IFwiV2hpdGVTcGFjZVwiLFxuICAgICAgICAgICAgbG9jOiBudWxsLFxuICAgICAgICAgICAgdmFsdWU6IFwiIFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdC5wdXNoKG4pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gcHModCkge1xuICByZXR1cm4gdCAhPT0gbnVsbCAmJiB0LnR5cGUgPT09IFwiT3BlcmF0b3JcIiAmJiAodC52YWx1ZVt0LnZhbHVlLmxlbmd0aCAtIDFdID09PSBcIi1cIiB8fCB0LnZhbHVlW3QudmFsdWUubGVuZ3RoIC0gMV0gPT09IFwiK1wiKTtcbn1cbmNvbnN0IFloID0ge1xuICBnZXROb2RlOiBzbyxcbiAgb25XaGl0ZVNwYWNlKHQsIGUpIHtcbiAgICBwcyh0KSAmJiAodC52YWx1ZSA9IFwiIFwiICsgdC52YWx1ZSksIHBzKGUubGFzdCkgJiYgKGUubGFzdC52YWx1ZSArPSBcIiBcIik7XG4gIH0sXG4gIGV4cHJlc3Npb246IEtoLFxuICB2YXI6IFFoXG59LCBYaCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEF0cnVsZVByZWx1ZGU6IERoLFxuICBTZWxlY3RvcjogcWgsXG4gIFZhbHVlOiBZaFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgSmggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJub25lXCIsIFwiYW5kXCIsIFwibm90XCIsIFwib3JcIl0pLCBaaCA9IHtcbiAgcGFyc2U6IHtcbiAgICBwcmVsdWRlKCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuY3JlYXRlTGlzdCgpO1xuICAgICAgaWYgKHRoaXMudG9rZW5UeXBlID09PSBnKSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLnN1YnN0cmluZyh0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQpO1xuICAgICAgICBKaC5oYXMoZS50b0xvd2VyQ2FzZSgpKSB8fCB0LnB1c2godGhpcy5JZGVudGlmaWVyKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQucHVzaCh0aGlzLkNvbmRpdGlvbihcImNvbnRhaW5lclwiKSksIHQ7XG4gICAgfSxcbiAgICBibG9jayh0ID0gITEpIHtcbiAgICAgIHJldHVybiB0aGlzLkJsb2NrKHQpO1xuICAgIH1cbiAgfVxufSwgdGYgPSB7XG4gIHBhcnNlOiB7XG4gICAgcHJlbHVkZTogbnVsbCxcbiAgICBibG9jaygpIHtcbiAgICAgIHJldHVybiB0aGlzLkJsb2NrKCEwKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBYZSh0LCBlKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlV2l0aEZhbGxiYWNrKFxuICAgICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0LmNhbGwodGhpcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnNraXBTQygpLCB0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSAhPT0gUyAmJiB0aGlzLmVycm9yKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlIHx8ICgoKSA9PiB0aGlzLlJhdyhudWxsLCAhMCkpXG4gICk7XG59XG5jb25zdCBkcyA9IHtcbiAgbGF5ZXIoKSB7XG4gICAgdGhpcy5za2lwU0MoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCksIGUgPSBYZS5jYWxsKHRoaXMsIHRoaXMuTGF5ZXIpO1xuICAgIHJldHVybiAoZS50eXBlICE9PSBcIlJhd1wiIHx8IGUudmFsdWUgIT09IFwiXCIpICYmIHQucHVzaChlKSwgdDtcbiAgfSxcbiAgc3VwcG9ydHMoKSB7XG4gICAgdGhpcy5za2lwU0MoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCksIGUgPSBYZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuRGVjbGFyYXRpb24sXG4gICAgICAoKSA9PiBYZS5jYWxsKHRoaXMsICgpID0+IHRoaXMuQ29uZGl0aW9uKFwic3VwcG9ydHNcIikpXG4gICAgKTtcbiAgICByZXR1cm4gKGUudHlwZSAhPT0gXCJSYXdcIiB8fCBlLnZhbHVlICE9PSBcIlwiKSAmJiB0LnB1c2goZSksIHQ7XG4gIH1cbn0sIGVmID0ge1xuICBwYXJzZToge1xuICAgIHByZWx1ZGUoKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCk7XG4gICAgICBzd2l0Y2ggKHRoaXMudG9rZW5UeXBlKSB7XG4gICAgICAgIGNhc2UgVHQ6XG4gICAgICAgICAgdC5wdXNoKHRoaXMuU3RyaW5nKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFE6XG4gICAgICAgIGNhc2UgVDpcbiAgICAgICAgICB0LnB1c2godGhpcy5VcmwoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5lcnJvcihcIlN0cmluZyBvciB1cmwoKSBpcyBleHBlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNraXBTQygpLCB0aGlzLnRva2VuVHlwZSA9PT0gZyAmJiB0aGlzLmNtcFN0cih0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQsIFwibGF5ZXJcIikgPyB0LnB1c2godGhpcy5JZGVudGlmaWVyKCkpIDogdGhpcy50b2tlblR5cGUgPT09IFQgJiYgdGhpcy5jbXBTdHIodGhpcy50b2tlblN0YXJ0LCB0aGlzLnRva2VuRW5kLCBcImxheWVyKFwiKSAmJiB0LnB1c2godGhpcy5GdW5jdGlvbihudWxsLCBkcykpLCB0aGlzLnNraXBTQygpLCB0aGlzLnRva2VuVHlwZSA9PT0gVCAmJiB0aGlzLmNtcFN0cih0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQsIFwic3VwcG9ydHMoXCIpICYmIHQucHVzaCh0aGlzLkZ1bmN0aW9uKG51bGwsIGRzKSksICh0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSA9PT0gZyB8fCB0aGlzLmxvb2t1cE5vbldTVHlwZSgwKSA9PT0gXykgJiYgdC5wdXNoKHRoaXMuTWVkaWFRdWVyeUxpc3QoKSksIHQ7XG4gICAgfSxcbiAgICBibG9jazogbnVsbFxuICB9XG59LCBuZiA9IHtcbiAgcGFyc2U6IHtcbiAgICBwcmVsdWRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICAgIHRoaXMuTGF5ZXJMaXN0KClcbiAgICAgICk7XG4gICAgfSxcbiAgICBibG9jaygpIHtcbiAgICAgIHJldHVybiB0aGlzLkJsb2NrKCExKTtcbiAgICB9XG4gIH1cbn0sIHNmID0ge1xuICBwYXJzZToge1xuICAgIHByZWx1ZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW5nbGVOb2RlTGlzdChcbiAgICAgICAgdGhpcy5NZWRpYVF1ZXJ5TGlzdCgpXG4gICAgICApO1xuICAgIH0sXG4gICAgYmxvY2sodCA9ICExKSB7XG4gICAgICByZXR1cm4gdGhpcy5CbG9jayh0KTtcbiAgICB9XG4gIH1cbn0sIHJmID0ge1xuICBwYXJzZToge1xuICAgIHByZWx1ZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW5nbGVOb2RlTGlzdChcbiAgICAgICAgdGhpcy5TZWxlY3Rvckxpc3QoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGJsb2NrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuQmxvY2soITApO1xuICAgIH1cbiAgfVxufSwgb2YgPSB7XG4gIHBhcnNlOiB7XG4gICAgcHJlbHVkZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpbmdsZU5vZGVMaXN0KFxuICAgICAgICB0aGlzLlNlbGVjdG9yTGlzdCgpXG4gICAgICApO1xuICAgIH0sXG4gICAgYmxvY2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5CbG9jayghMCk7XG4gICAgfVxuICB9XG59LCBhZiA9IHtcbiAgcGFyc2U6IHtcbiAgICBwcmVsdWRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICAgIHRoaXMuU2NvcGUoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGJsb2NrKHQgPSAhMSkge1xuICAgICAgcmV0dXJuIHRoaXMuQmxvY2sodCk7XG4gICAgfVxuICB9XG59LCBsZiA9IHtcbiAgcGFyc2U6IHtcbiAgICBwcmVsdWRlOiBudWxsLFxuICAgIGJsb2NrKHQgPSAhMSkge1xuICAgICAgcmV0dXJuIHRoaXMuQmxvY2sodCk7XG4gICAgfVxuICB9XG59LCBjZiA9IHtcbiAgcGFyc2U6IHtcbiAgICBwcmVsdWRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICAgIHRoaXMuQ29uZGl0aW9uKFwic3VwcG9ydHNcIilcbiAgICAgICk7XG4gICAgfSxcbiAgICBibG9jayh0ID0gITEpIHtcbiAgICAgIHJldHVybiB0aGlzLkJsb2NrKHQpO1xuICAgIH1cbiAgfVxufSwgdWYgPSB7XG4gIGNvbnRhaW5lcjogWmgsXG4gIFwiZm9udC1mYWNlXCI6IHRmLFxuICBpbXBvcnQ6IGVmLFxuICBsYXllcjogbmYsXG4gIG1lZGlhOiBzZixcbiAgbmVzdDogcmYsXG4gIHBhZ2U6IG9mLFxuICBzY29wZTogYWYsXG4gIFwic3RhcnRpbmctc3R5bGVcIjogbGYsXG4gIHN1cHBvcnRzOiBjZlxufTtcbmZ1bmN0aW9uIGhmKCkge1xuICBjb25zdCB0ID0gdGhpcy5jcmVhdGVMaXN0KCk7XG4gIHRoaXMuc2tpcFNDKCk7XG4gIHQ6IGZvciAoOyAhdGhpcy5lb2Y7ICkge1xuICAgIHN3aXRjaCAodGhpcy50b2tlblR5cGUpIHtcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgdC5wdXNoKHRoaXMuSWRlbnRpZmllcigpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFR0OlxuICAgICAgICB0LnB1c2godGhpcy5TdHJpbmcoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBmdDpcbiAgICAgICAgdC5wdXNoKHRoaXMuT3BlcmF0b3IoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTOlxuICAgICAgICBicmVhayB0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5lcnJvcihcIklkZW50aWZpZXIsIHN0cmluZyBvciBjb21tYSBpcyBleHBlY3RlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5za2lwU0MoKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNvbnN0IFJ0ID0ge1xuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW5nbGVOb2RlTGlzdChcbiAgICAgIHRoaXMuU2VsZWN0b3JMaXN0KClcbiAgICApO1xuICB9XG59LCBKZSA9IHtcbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICB0aGlzLlNlbGVjdG9yKClcbiAgICApO1xuICB9XG59LCBmZiA9IHtcbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2luZ2xlTm9kZUxpc3QoXG4gICAgICB0aGlzLklkZW50aWZpZXIoKVxuICAgICk7XG4gIH1cbn0sIHBmID0ge1xuICBwYXJzZTogaGZcbn0sIGtlID0ge1xuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW5nbGVOb2RlTGlzdChcbiAgICAgIHRoaXMuTnRoKClcbiAgICApO1xuICB9XG59LCBkZiA9IHtcbiAgZGlyOiBmZixcbiAgaGFzOiBSdCxcbiAgbGFuZzogcGYsXG4gIG1hdGNoZXM6IFJ0LFxuICBpczogUnQsXG4gIFwiLW1vei1hbnlcIjogUnQsXG4gIFwiLXdlYmtpdC1hbnlcIjogUnQsXG4gIHdoZXJlOiBSdCxcbiAgbm90OiBSdCxcbiAgXCJudGgtY2hpbGRcIjoga2UsXG4gIFwibnRoLWxhc3QtY2hpbGRcIjoga2UsXG4gIFwibnRoLWxhc3Qtb2YtdHlwZVwiOiBrZSxcbiAgXCJudGgtb2YtdHlwZVwiOiBrZSxcbiAgc2xvdHRlZDogSmUsXG4gIGhvc3Q6IEplLFxuICBcImhvc3QtY29udGV4dFwiOiBKZVxufSwgZ2YgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBblBsdXNCOiBYcyxcbiAgQXRydWxlOiBacyxcbiAgQXRydWxlUHJlbHVkZTogZXIsXG4gIEF0dHJpYnV0ZVNlbGVjdG9yOiBycixcbiAgQmxvY2s6IGFyLFxuICBCcmFja2V0czogY3IsXG4gIENEQzogaHIsXG4gIENETzogcHIsXG4gIENsYXNzU2VsZWN0b3I6IGdyLFxuICBDb21iaW5hdG9yOiBrcixcbiAgQ29tbWVudDogeXIsXG4gIENvbmRpdGlvbjogeHIsXG4gIERlY2xhcmF0aW9uOiBUcixcbiAgRGVjbGFyYXRpb25MaXN0OiB2cixcbiAgRGltZW5zaW9uOiAkcixcbiAgRmVhdHVyZTogUHIsXG4gIEZlYXR1cmVGdW5jdGlvbjogUnIsXG4gIEZlYXR1cmVSYW5nZTogSXIsXG4gIEZ1bmN0aW9uOiBEcixcbiAgR2VuZXJhbEVuY2xvc2VkOiBNcixcbiAgSGFzaDogQnIsXG4gIElkU2VsZWN0b3I6IFZyLFxuICBJZGVudGlmaWVyOiBVcixcbiAgTGF5ZXI6IEdyLFxuICBMYXllckxpc3Q6IEtyLFxuICBNZWRpYVF1ZXJ5OiBZcixcbiAgTWVkaWFRdWVyeUxpc3Q6IEpyLFxuICBOZXN0aW5nU2VsZWN0b3I6IHRpLFxuICBOdGg6IG5pLFxuICBOdW1iZXI6IHJpLFxuICBPcGVyYXRvcjogb2ksXG4gIFBhcmVudGhlc2VzOiBsaSxcbiAgUGVyY2VudGFnZTogdWksXG4gIFBzZXVkb0NsYXNzU2VsZWN0b3I6IGZpLFxuICBQc2V1ZG9FbGVtZW50U2VsZWN0b3I6IGRpLFxuICBSYXRpbzogbWksXG4gIFJhdzogU2ksXG4gIFJ1bGU6IGJpLFxuICBTY29wZTogQ2ksXG4gIFNlbGVjdG9yOiBUaSxcbiAgU2VsZWN0b3JMaXN0OiB2aSxcbiAgU3RyaW5nOiBQaSxcbiAgU3R5bGVTaGVldDogUmksXG4gIFN1cHBvcnRzRGVjbGFyYXRpb246IElpLFxuICBUeXBlU2VsZWN0b3I6IERpLFxuICBVbmljb2RlUmFuZ2U6IEJpLFxuICBVcmw6IHppLFxuICBWYWx1ZTogSGksXG4gIFdoaXRlU3BhY2U6IHFpXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBtZiA9IHtcbiAgcGFyc2VDb250ZXh0OiB7XG4gICAgZGVmYXVsdDogXCJTdHlsZVNoZWV0XCIsXG4gICAgc3R5bGVzaGVldDogXCJTdHlsZVNoZWV0XCIsXG4gICAgYXRydWxlOiBcIkF0cnVsZVwiLFxuICAgIGF0cnVsZVByZWx1ZGUodCkge1xuICAgICAgcmV0dXJuIHRoaXMuQXRydWxlUHJlbHVkZSh0LmF0cnVsZSA/IFN0cmluZyh0LmF0cnVsZSkgOiBudWxsKTtcbiAgICB9LFxuICAgIG1lZGlhUXVlcnlMaXN0OiBcIk1lZGlhUXVlcnlMaXN0XCIsXG4gICAgbWVkaWFRdWVyeTogXCJNZWRpYVF1ZXJ5XCIsXG4gICAgY29uZGl0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLkNvbmRpdGlvbih0LmtpbmQpO1xuICAgIH0sXG4gICAgcnVsZTogXCJSdWxlXCIsXG4gICAgc2VsZWN0b3JMaXN0OiBcIlNlbGVjdG9yTGlzdFwiLFxuICAgIHNlbGVjdG9yOiBcIlNlbGVjdG9yXCIsXG4gICAgYmxvY2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5CbG9jayghMCk7XG4gICAgfSxcbiAgICBkZWNsYXJhdGlvbkxpc3Q6IFwiRGVjbGFyYXRpb25MaXN0XCIsXG4gICAgZGVjbGFyYXRpb246IFwiRGVjbGFyYXRpb25cIixcbiAgICB2YWx1ZTogXCJWYWx1ZVwiXG4gIH0sXG4gIGZlYXR1cmVzOiB7XG4gICAgc3VwcG9ydHM6IHtcbiAgICAgIHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5TZWxlY3RvcigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICBzdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRGVjbGFyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjb3BlOiBYaCxcbiAgYXRydWxlOiB1ZixcbiAgcHNldWRvOiBkZixcbiAgbm9kZTogZ2Zcbn0sIGtmID0gUGgobWYpO1xuZnVuY3Rpb24gUGUodCkge1xuICBjb25zdCBlID0ge307XG4gIGZvciAoY29uc3QgbiBvZiBPYmplY3Qua2V5cyh0KSkge1xuICAgIGxldCBzID0gdFtuXTtcbiAgICBzICYmIChBcnJheS5pc0FycmF5KHMpIHx8IHMgaW5zdGFuY2VvZiBLID8gcyA9IHMubWFwKFBlKSA6IHMuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiAocyA9IFBlKHMpKSksIGVbbl0gPSBzO1xuICB9XG4gIHJldHVybiBlO1xufVxubGV0IFNmID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCIsIGx0ID0gKHQgPSAyMSkgPT4ge1xuICBsZXQgZSA9IFwiXCIsIG4gPSB0IHwgMDtcbiAgZm9yICg7IG4tLTsgKVxuICAgIGUgKz0gU2ZbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIHJldHVybiBlO1xufTtcbmNvbnN0IHJvID0gbHQoKSwgcmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gT2UodCkge1xuICByZXR1cm4gISEodCAmJiB0LnR5cGUgPT09IFwiRnVuY3Rpb25cIiAmJiB0Lm5hbWUgPT09IFwiYW5jaG9yXCIpO1xufVxuZnVuY3Rpb24gTHQodCwgZSA9ICExKSB7XG4gIHJldHVybiBrZih0LCB7XG4gICAgcGFyc2VBdHJ1bGVQcmVsdWRlOiAhMSxcbiAgICBwYXJzZUN1c3RvbVByb3BlcnR5OiAhMCxcbiAgICBvblBhcnNlRXJyb3I6IChuKSA9PiB7XG4gICAgICBlICYmIHJlLmFkZChuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gWih0KSB7XG4gIHJldHVybiB3aCh0LCB7XG4gICAgLy8gRGVmYXVsdCBgc2FmZWAgYWRkcyBleHRyYSAocG90ZW50aWFsbHkgYnJlYWtpbmcpIHNwYWNlcyBmb3IgY29tcGF0aWJpbGl0eVxuICAgIC8vIHdpdGggb2xkIGJyb3dzZXJzLlxuICAgIG1vZGU6IFwic3BlY1wiXG4gIH0pO1xufVxuZnVuY3Rpb24geWYodCkge1xuICByZXR1cm4gdC50eXBlID09PSBcIkRlY2xhcmF0aW9uXCI7XG59XG5mdW5jdGlvbiBiZih0KSB7XG4gIHJldHVybiB0LnRvQXJyYXkoKS5yZWR1Y2UoXG4gICAgKGUsIG4pID0+IG4udHlwZSA9PT0gXCJPcGVyYXRvclwiICYmIG4udmFsdWUgPT09IFwiLFwiID8gKGUucHVzaChbXSksIGUpIDogKG4udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZVtlLmxlbmd0aCAtIDFdLnB1c2gobiksIGUpLFxuICAgIFtbXV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGZuKHQpIHtcbiAgcmV0dXJuIHQgPyB0LmNoaWxkcmVuLm1hcCgoZSkgPT4ge1xuICAgIHZhciByO1xuICAgIGxldCBuO1xuICAgICgociA9IGUuY2hpbGRyZW4ubGFzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIudHlwZSkgPT09IFwiUHNldWRvRWxlbWVudFNlbGVjdG9yXCIgJiYgKGUgPSBQZShlKSwgbiA9IFooZS5jaGlsZHJlbi5sYXN0KSwgZS5jaGlsZHJlbi5wb3AoKSk7XG4gICAgY29uc3QgcyA9IFooZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBzICsgKG4gIT0gbnVsbCA/IG4gOiBcIlwiKSxcbiAgICAgIGVsZW1lbnRQYXJ0OiBzLFxuICAgICAgcHNldWRvRWxlbWVudFBhcnQ6IG5cbiAgICB9O1xuICB9KS50b0FycmF5KCkgOiBbXTtcbn1cbmZ1bmN0aW9uIHhmKCkge1xuICByZS5zaXplID4gMCAmJiAoY29uc29sZS5ncm91cChcbiAgICBgVGhlIENTUyBhbmNob3IgcG9zaXRpb25pbmcgcG9seWZpbGwgd2FzIG5vdCBhcHBsaWVkIGR1ZSB0byAke3JlLnNpemUgPT09IDEgPyBcImEgQ1NTIHBhcnNlIGVycm9yXCIgOiBcIkNTUyBwYXJzZSBlcnJvcnNcIn0uYFxuICApLCByZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgY29uc29sZS53YXJuKHQuZm9ybWF0dGVkTWVzc2FnZSk7XG4gIH0pLCBjb25zb2xlLmdyb3VwRW5kKCkpO1xufVxuZnVuY3Rpb24gQ2YoKSB7XG4gIHJlLmNsZWFyKCk7XG59XG5jb25zdCBwbiA9IFtcbiAgLi4uWGksXG4gIFwiYW5jaG9yLXNjb3BlXCIsXG4gIFwiYW5jaG9yLW5hbWVcIlxuXS5yZWR1Y2UoXG4gICh0LCBlKSA9PiAodFtlXSA9IGAtLSR7ZX0tJHtyb31gLCB0KSxcbiAge31cbik7XG5mdW5jdGlvbiB3Zih0LCBlKSB7XG4gIHJldHVybiB5Zih0KSAmJiBwblt0LnByb3BlcnR5XSAmJiBlID8gKGUuY2hpbGRyZW4uYXBwZW5kRGF0YShxKFUoe30sIHQpLCB7XG4gICAgcHJvcGVydHk6IHBuW3QucHJvcGVydHldXG4gIH0pKSwgeyB1cGRhdGVkOiAhMCB9KSA6IHt9O1xufVxuZnVuY3Rpb24gVGYodCkge1xuICBmb3IgKGNvbnN0IGUgb2YgdCkge1xuICAgIGxldCBuID0gITE7XG4gICAgY29uc3QgcyA9IEx0KGUuY3NzLCAhMCk7XG4gICAgJHQocywge1xuICAgICAgdmlzaXQ6IFwiRGVjbGFyYXRpb25cIixcbiAgICAgIGVudGVyKHIpIHtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIGNvbnN0IG8gPSAobCA9IHRoaXMucnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuYmxvY2ssIHsgdXBkYXRlZDogYSB9ID0gd2Yociwgbyk7XG4gICAgICAgIGEgJiYgKG4gPSAhMCk7XG4gICAgICB9XG4gICAgfSksIG4gJiYgKGUuY3NzID0gWihzKSwgZS5jaGFuZ2VkID0gITApO1xuICB9XG4gIHJldHVybiB0LnNvbWUoKGUpID0+IGUuY2hhbmdlZCA9PT0gITApO1xufVxudmFyIGlvID0gLyogQF9fUFVSRV9fICovICgodCkgPT4gKHQuQWxsID0gXCJhbGxcIiwgdC5Ob25lID0gXCJub25lXCIsIHQpKShpbyB8fCB7fSk7XG5mdW5jdGlvbiBvdCh0LCBlKSB7XG4gIHZhciBzO1xuICByZXR1cm4gZSA9IChzID0gcG5bZV0pICE9IG51bGwgPyBzIDogZSwgKHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGdldENvbXB1dGVkU3R5bGUodCkgOiB0LmNvbXB1dGVkU3R5bGUpLmdldFByb3BlcnR5VmFsdWUoZSkudHJpbSgpO1xufVxuZnVuY3Rpb24gWnQodCwgZSwgbikge1xuICByZXR1cm4gb3QodCwgZSkgPT09IG47XG59XG5mdW5jdGlvbiBBZih0LCB7IHNlbGVjdG9yOiBlLCBwc2V1ZG9FbGVtZW50UGFydDogbiB9KSB7XG4gIGNvbnN0IHMgPSBnZXRDb21wdXRlZFN0eWxlKHQsIG4pLCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgci5pZCA9IGBmYWtlLXBzZXVkby1lbGVtZW50LSR7bHQoKX1gO1xuICBmb3IgKGNvbnN0IGwgb2YgQXJyYXkuZnJvbShzKSkge1xuICAgIGNvbnN0IHUgPSBzLmdldFByb3BlcnR5VmFsdWUobCk7XG4gICAgci5zdHlsZS5zZXRQcm9wZXJ0eShsLCB1KTtcbiAgfVxuICBvLnRleHRDb250ZW50ICs9IGAjJHtyLmlkfSR7bn0geyBjb250ZW50OiAke3MuY29udGVudH07IH1gLCBvLnRleHRDb250ZW50ICs9IGAke2V9IHsgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9YCwgZG9jdW1lbnQuaGVhZC5hcHBlbmQobyk7XG4gIGNvbnN0IGEgPSBuID09PSBcIjo6YmVmb3JlXCIgPyBcImFmdGVyYmVnaW5cIiA6IFwiYmVmb3JlZW5kXCI7XG4gIHJldHVybiB0Lmluc2VydEFkamFjZW50RWxlbWVudChhLCByKSwgeyBmYWtlUHNldWRvRWxlbWVudDogciwgc2hlZXQ6IG8sIGNvbXB1dGVkU3R5bGU6IHMgfTtcbn1cbmZ1bmN0aW9uIHZmKHQpIHtcbiAgbGV0IGUgPSB0O1xuICBmb3IgKDsgZTsgKSB7XG4gICAgaWYgKFp0KGUsIFwib3ZlcmZsb3dcIiwgXCJzY3JvbGxcIikpXG4gICAgICByZXR1cm4gZTtcbiAgICBlID0gZS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gRWYodCkge1xuICBsZXQgZSA9IHZmKHQpO1xuICByZXR1cm4gZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIChlID0gbnVsbCksIGUgIT0gbnVsbCA/IGUgOiB7IHNjcm9sbFRvcDogMCwgc2Nyb2xsTGVmdDogMCB9O1xufVxuZnVuY3Rpb24gJGYodCwgZSkge1xuICBjb25zdCB7IGVsZW1lbnRQYXJ0OiBuLCBwc2V1ZG9FbGVtZW50UGFydDogcyB9ID0gdCwgciA9IFtdO1xuICBpZiAocyAmJiAhKHMgPT09IFwiOjpiZWZvcmVcIiB8fCBzID09PSBcIjo6YWZ0ZXJcIikpIHJldHVybiByO1xuICBjb25zdCBsID0gaWUoZS5yb290cywgbik7XG4gIGlmICghcylcbiAgICByZXR1cm4gci5wdXNoKC4uLmwpLCByO1xuICBmb3IgKGNvbnN0IHUgb2YgbCkge1xuICAgIGNvbnN0IHsgZmFrZVBzZXVkb0VsZW1lbnQ6IGksIHNoZWV0OiBjLCBjb21wdXRlZFN0eWxlOiBoIH0gPSBBZihcbiAgICAgIHUsXG4gICAgICB0XG4gICAgKSwgZiA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgc2Nyb2xsWTogcCwgc2Nyb2xsWDogZCB9ID0gZ2xvYmFsVGhpcywgbSA9IEVmKHUpO1xuICAgIHIucHVzaCh7XG4gICAgICBmYWtlUHNldWRvRWxlbWVudDogaSxcbiAgICAgIGNvbXB1dGVkU3R5bGU6IGgsXG4gICAgICByZW1vdmVGYWtlUHNldWRvRWxlbWVudCgpIHtcbiAgICAgICAgaS5yZW1vdmUoKSwgYy5yZW1vdmUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBGb3IgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvdXBkYXRlI2FuY2VzdG9yc2Nyb2xsIHRvIHdvcmsgb25cbiAgICAgIC8vIGBWaXJ0dWFsRWxlbWVudGBzLlxuICAgICAgY29udGV4dEVsZW1lbnQ6IHUsXG4gICAgICAvLyBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxZOiBrLCBzY3JvbGxYOiB5IH0gPSBnbG9iYWxUaGlzLCB7IHNjcm9sbFRvcDogeCwgc2Nyb2xsTGVmdDogQSB9ID0gbTtcbiAgICAgICAgcmV0dXJuIERPTVJlY3QuZnJvbVJlY3Qoe1xuICAgICAgICAgIHk6IGYueSArIChwIC0gaykgKyAobS5zY3JvbGxUb3AgLSB4KSxcbiAgICAgICAgICB4OiBmLnggKyAoZCAtIHkpICsgKG0uc2Nyb2xsTGVmdCAtIEEpLFxuICAgICAgICAgIHdpZHRoOiBmLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogZi5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBMZih0LCBlKSB7XG4gIGNvbnN0IG4gPSBvdCh0LCBcImFuY2hvci1uYW1lXCIpO1xuICByZXR1cm4gZSA/IG4uc3BsaXQoXCIsXCIpLm1hcCgocykgPT4gcy50cmltKCkpLmluY2x1ZGVzKGUpIDogIW47XG59XG5mdW5jdGlvbiBQZih0LCBlKSB7XG4gIGNvbnN0IG4gPSBvdCh0LCBcImFuY2hvci1zY29wZVwiKTtcbiAgcmV0dXJuIG4gPT09IGUgfHwgbiA9PT0gXCJhbGxcIjtcbn1cbmNvbnN0IHZuID0gKHQpID0+IFIobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgdmFyIG4sIHMsIHI7XG4gIGxldCBlID0geWllbGQgKG4gPSBWLmdldE9mZnNldFBhcmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uY2FsbChWLCB0KTtcbiAgcmV0dXJuICh5aWVsZCAocyA9IFYuaXNFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogcy5jYWxsKFYsIGUpKSB8fCAoZSA9ICh5aWVsZCAociA9IFYuZ2V0RG9jdW1lbnRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5jYWxsKFYsIHQpKSB8fCB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSwgZTtcbn0pLCBpZSA9ICh0LCBlKSA9PiB0LmZsYXRNYXAoXG4gIChuKSA9PiBbLi4ubi5xdWVyeVNlbGVjdG9yQWxsKGUpXVxuKSwgZ3MgPSBcIkludmFsaWRNaW1lVHlwZVwiO1xuZnVuY3Rpb24gT2YodCkge1xuICByZXR1cm4gISEoKHQudHlwZSA9PT0gXCJ0ZXh0L2Nzc1wiIHx8IHQucmVsID09PSBcInN0eWxlc2hlZXRcIikgJiYgdC5ocmVmKTtcbn1cbmZ1bmN0aW9uIFJmKHQpIHtcbiAgY29uc3QgZSA9IG5ldyBVUkwodC5ocmVmLCBkb2N1bWVudC5iYXNlVVJJKTtcbiAgaWYgKE9mKHQpICYmIGUub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW4pXG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfZih0KSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuICh5aWVsZCBQcm9taXNlLmFsbChcbiAgICAgIHQubWFwKChuKSA9PiBSKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICBpZiAoIW4udXJsKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICBpZiAoKHMgPSBuLmVsKSAhPSBudWxsICYmIHMuZGlzYWJsZWQpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgciA9IHlpZWxkIGZldGNoKG4udXJsLnRvU3RyaW5nKCkpLCBvID0gci5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICBpZiAoIShvICE9IG51bGwgJiYgby5zdGFydHNXaXRoKFwidGV4dC9jc3NcIikpKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRXJyb3IgbG9hZGluZyAke24udXJsfTogZXhwZWN0ZWQgY29udGVudC10eXBlIFwidGV4dC9jc3NcIiwgZ290IFwiJHtvfVwiLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBsLm5hbWUgPSBncywgbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYSA9IHlpZWxkIHIudGV4dCgpO1xuICAgICAgICAgIHJldHVybiBxKFUoe30sIG4pLCB7IGNzczogYSB9KTtcbiAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgRXJyb3IgJiYgci5uYW1lID09PSBncylcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4ociksIG51bGw7XG4gICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKSkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKTtcbiAgfSk7XG59XG5jb25zdCBtcyA9ICdbc3R5bGUqPVwiYW5jaG9yXCJdJywga3MgPSAnW3N0eWxlKj1cInBvc2l0aW9uLWFyZWFcIl0nO1xuZnVuY3Rpb24gSWYodCkge1xuICBjb25zdCBlID0gdCA/IHQuZmlsdGVyKFxuICAgIChzKSA9PiBzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHMubWF0Y2hlcyhtcykgfHwgcy5tYXRjaGVzKGtzKSlcbiAgKSA6IEFycmF5LmZyb20oXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIFtcbiAgICAgICAgbXMsXG4gICAgICAgIGtzXG4gICAgICBdLmpvaW4oXCIsXCIpXG4gICAgKVxuICApLCBuID0gW107XG4gIHJldHVybiBlLmZpbHRlcigocykgPT4gcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KS5mb3JFYWNoKChzKSA9PiB7XG4gICAgY29uc3QgciA9IGx0KDEyKSwgbyA9IFwiZGF0YS1oYXMtaW5saW5lLXN0eWxlc1wiO1xuICAgIHMuc2V0QXR0cmlidXRlKG8sIHIpO1xuICAgIGNvbnN0IGEgPSBzLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpLCBsID0gYFske299PVwiJHtyfVwiXSB7ICR7YX0gfWA7XG4gICAgbi5wdXNoKHsgZWw6IHMsIGNzczogbCB9KTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBOZih0KSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIG8sIGE7XG4gICAgY29uc3QgZSA9IChvID0gdC5lbGVtZW50cykgIT0gbnVsbCA/IG8gOiBpZSh0LnJvb3RzLCBcImxpbmssIHN0eWxlXCIpLCBuID0gW107XG4gICAgZS5maWx0ZXIoKGwpID0+IGwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgaWYgKGwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImxpbmtcIikge1xuICAgICAgICBjb25zdCB1ID0gUmYobCk7XG4gICAgICAgIHUgJiYgbi5wdXNoKHsgZWw6IGwsIHVybDogdSB9KTtcbiAgICAgIH1cbiAgICAgIGwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN0eWxlXCIgJiYgbi5wdXNoKHsgZWw6IGwsIGNzczogbC5pbm5lckhUTUwgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcyA9IHQuZXhjbHVkZUlubGluZVN0eWxlcyA/IChhID0gdC5lbGVtZW50cykgIT0gbnVsbCA/IGEgOiBbXSA6IHZvaWQgMCwgciA9IElmKHMpO1xuICAgIHJldHVybiB5aWVsZCBfZihbLi4ubiwgLi4ucl0pO1xuICB9KTtcbn1cbmNvbnN0IERmID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG5sZXQgb28gPSAodCA9IDIxKSA9PiB7XG4gIGxldCBlID0gXCJcIiwgbiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCB8PSAwKSk7XG4gIGZvciAoOyB0LS07IClcbiAgICBlICs9IERmW25bdF0gJiA2M107XG4gIHJldHVybiBlO1xufTtcbmNvbnN0IGFvID0gXCItLXBhLWNhc2NhZGUtcHJvcGVydHlcIiwgbG8gPSBcImRhdGEtYW5jaG9yLXBvc2l0aW9uLXdyYXBwZXJcIiwgY28gPSBcImRhdGEtcGEtd3JhcHBlci1mb3ItXCIsIFNzID0gXCJQT0xZRklMTC1QT1NJVElPTi1BUkVBXCIsIEZmID0gW1xuICBcImxlZnRcIixcbiAgXCJjZW50ZXJcIixcbiAgXCJyaWdodFwiLFxuICBcInNwYW4tbGVmdFwiLFxuICBcInNwYW4tcmlnaHRcIixcbiAgXCJ4LXN0YXJ0XCIsXG4gIFwieC1lbmRcIixcbiAgXCJzcGFuLXgtc3RhcnRcIixcbiAgXCJzcGFuLXgtZW5kXCIsXG4gIFwieC1zZWxmLXN0YXJ0XCIsXG4gIFwieC1zZWxmLWVuZFwiLFxuICBcInNwYW4teC1zZWxmLXN0YXJ0XCIsXG4gIFwic3Bhbi14LXNlbGYtZW5kXCIsXG4gIFwic3Bhbi1hbGxcIixcbiAgXCJ0b3BcIixcbiAgXCJib3R0b21cIixcbiAgXCJzcGFuLXRvcFwiLFxuICBcInNwYW4tYm90dG9tXCIsXG4gIFwieS1zdGFydFwiLFxuICBcInktZW5kXCIsXG4gIFwic3Bhbi15LXN0YXJ0XCIsXG4gIFwic3Bhbi15LWVuZFwiLFxuICBcInktc2VsZi1zdGFydFwiLFxuICBcInktc2VsZi1lbmRcIixcbiAgXCJzcGFuLXktc2VsZi1zdGFydFwiLFxuICBcInNwYW4teS1zZWxmLWVuZFwiLFxuICBcImJsb2NrLXN0YXJ0XCIsXG4gIFwiYmxvY2stZW5kXCIsXG4gIFwic3Bhbi1ibG9jay1zdGFydFwiLFxuICBcInNwYW4tYmxvY2stZW5kXCIsXG4gIFwiaW5saW5lLXN0YXJ0XCIsXG4gIFwiaW5saW5lLWVuZFwiLFxuICBcInNwYW4taW5saW5lLXN0YXJ0XCIsXG4gIFwic3Bhbi1pbmxpbmUtZW5kXCIsXG4gIFwic2VsZi1ibG9jay1zdGFydFwiLFxuICBcInNlbGYtYmxvY2stZW5kXCIsXG4gIFwic3Bhbi1zZWxmLWJsb2NrLXN0YXJ0XCIsXG4gIFwic3Bhbi1zZWxmLWJsb2NrLWVuZFwiLFxuICBcInNlbGYtaW5saW5lLXN0YXJ0XCIsXG4gIFwic2VsZi1pbmxpbmUtZW5kXCIsXG4gIFwic3Bhbi1zZWxmLWlubGluZS1zdGFydFwiLFxuICBcInNwYW4tc2VsZi1pbmxpbmUtZW5kXCIsXG4gIFwic3RhcnRcIixcbiAgXCJlbmRcIixcbiAgXCJzcGFuLXN0YXJ0XCIsXG4gIFwic3Bhbi1lbmRcIixcbiAgXCJzZWxmLXN0YXJ0XCIsXG4gIFwic2VsZi1lbmRcIixcbiAgXCJzcGFuLXNlbGYtc3RhcnRcIixcbiAgXCJzcGFuLXNlbGYtZW5kXCJcbl07XG5mdW5jdGlvbiB1byh0KSB7XG4gIHJldHVybiBGZi5pbmNsdWRlcyh0KTtcbn1cbmNvbnN0IHlzID0ge1xuICBsZWZ0OiBbXG4gICAgMCxcbiAgICAxLFxuICAgIFwiSXJyZWxldmFudFwiXG4gICAgLyogSXJyZWxldmFudCAqL1xuICBdLFxuICBjZW50ZXI6IFtcbiAgICAxLFxuICAgIDIsXG4gICAgXCJJcnJlbGV2YW50XCJcbiAgICAvKiBJcnJlbGV2YW50ICovXG4gIF0sXG4gIHJpZ2h0OiBbXG4gICAgMixcbiAgICAzLFxuICAgIFwiSXJyZWxldmFudFwiXG4gICAgLyogSXJyZWxldmFudCAqL1xuICBdLFxuICBcInNwYW4tbGVmdFwiOiBbXG4gICAgMCxcbiAgICAyLFxuICAgIFwiSXJyZWxldmFudFwiXG4gICAgLyogSXJyZWxldmFudCAqL1xuICBdLFxuICBcInNwYW4tcmlnaHRcIjogW1xuICAgIDEsXG4gICAgMyxcbiAgICBcIklycmVsZXZhbnRcIlxuICAgIC8qIElycmVsZXZhbnQgKi9cbiAgXSxcbiAgXCJ4LXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDEsXG4gICAgXCJQaHlzaWNhbFwiXG4gICAgLyogUGh5c2ljYWwgKi9cbiAgXSxcbiAgXCJ4LWVuZFwiOiBbXG4gICAgMixcbiAgICAzLFxuICAgIFwiUGh5c2ljYWxcIlxuICAgIC8qIFBoeXNpY2FsICovXG4gIF0sXG4gIFwic3Bhbi14LXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDIsXG4gICAgXCJQaHlzaWNhbFwiXG4gICAgLyogUGh5c2ljYWwgKi9cbiAgXSxcbiAgXCJzcGFuLXgtZW5kXCI6IFtcbiAgICAxLFxuICAgIDMsXG4gICAgXCJQaHlzaWNhbFwiXG4gICAgLyogUGh5c2ljYWwgKi9cbiAgXSxcbiAgXCJ4LXNlbGYtc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMSxcbiAgICBcIlBoeXNpY2FsU2VsZlwiXG4gICAgLyogUGh5c2ljYWxTZWxmICovXG4gIF0sXG4gIFwieC1zZWxmLWVuZFwiOiBbXG4gICAgMixcbiAgICAzLFxuICAgIFwiUGh5c2ljYWxTZWxmXCJcbiAgICAvKiBQaHlzaWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzcGFuLXgtc2VsZi1zdGFydFwiOiBbXG4gICAgMCxcbiAgICAyLFxuICAgIFwiUGh5c2ljYWxTZWxmXCJcbiAgICAvKiBQaHlzaWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzcGFuLXgtc2VsZi1lbmRcIjogW1xuICAgIDEsXG4gICAgMyxcbiAgICBcIlBoeXNpY2FsU2VsZlwiXG4gICAgLyogUGh5c2ljYWxTZWxmICovXG4gIF0sXG4gIFwic3Bhbi1hbGxcIjogW1xuICAgIDAsXG4gICAgMyxcbiAgICBcIklycmVsZXZhbnRcIlxuICAgIC8qIElycmVsZXZhbnQgKi9cbiAgXSxcbiAgdG9wOiBbXG4gICAgMCxcbiAgICAxLFxuICAgIFwiSXJyZWxldmFudFwiXG4gICAgLyogSXJyZWxldmFudCAqL1xuICBdLFxuICBib3R0b206IFtcbiAgICAyLFxuICAgIDMsXG4gICAgXCJJcnJlbGV2YW50XCJcbiAgICAvKiBJcnJlbGV2YW50ICovXG4gIF0sXG4gIFwic3Bhbi10b3BcIjogW1xuICAgIDAsXG4gICAgMixcbiAgICBcIklycmVsZXZhbnRcIlxuICAgIC8qIElycmVsZXZhbnQgKi9cbiAgXSxcbiAgXCJzcGFuLWJvdHRvbVwiOiBbXG4gICAgMSxcbiAgICAzLFxuICAgIFwiSXJyZWxldmFudFwiXG4gICAgLyogSXJyZWxldmFudCAqL1xuICBdLFxuICBcInktc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMSxcbiAgICBcIlBoeXNpY2FsXCJcbiAgICAvKiBQaHlzaWNhbCAqL1xuICBdLFxuICBcInktZW5kXCI6IFtcbiAgICAyLFxuICAgIDMsXG4gICAgXCJQaHlzaWNhbFwiXG4gICAgLyogUGh5c2ljYWwgKi9cbiAgXSxcbiAgXCJzcGFuLXktc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMixcbiAgICBcIlBoeXNpY2FsXCJcbiAgICAvKiBQaHlzaWNhbCAqL1xuICBdLFxuICBcInNwYW4teS1lbmRcIjogW1xuICAgIDEsXG4gICAgMyxcbiAgICBcIlBoeXNpY2FsXCJcbiAgICAvKiBQaHlzaWNhbCAqL1xuICBdLFxuICBcInktc2VsZi1zdGFydFwiOiBbXG4gICAgMCxcbiAgICAxLFxuICAgIFwiUGh5c2ljYWxTZWxmXCJcbiAgICAvKiBQaHlzaWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJ5LXNlbGYtZW5kXCI6IFtcbiAgICAyLFxuICAgIDMsXG4gICAgXCJQaHlzaWNhbFNlbGZcIlxuICAgIC8qIFBoeXNpY2FsU2VsZiAqL1xuICBdLFxuICBcInNwYW4teS1zZWxmLXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDIsXG4gICAgXCJQaHlzaWNhbFNlbGZcIlxuICAgIC8qIFBoeXNpY2FsU2VsZiAqL1xuICBdLFxuICBcInNwYW4teS1zZWxmLWVuZFwiOiBbXG4gICAgMSxcbiAgICAzLFxuICAgIFwiUGh5c2ljYWxTZWxmXCJcbiAgICAvKiBQaHlzaWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJibG9jay1zdGFydFwiOiBbXG4gICAgMCxcbiAgICAxLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcImJsb2NrLWVuZFwiOiBbXG4gICAgMixcbiAgICAzLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcInNwYW4tYmxvY2stc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMixcbiAgICBcIkxvZ2ljYWxcIlxuICAgIC8qIExvZ2ljYWwgKi9cbiAgXSxcbiAgXCJzcGFuLWJsb2NrLWVuZFwiOiBbXG4gICAgMSxcbiAgICAzLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcImlubGluZS1zdGFydFwiOiBbXG4gICAgMCxcbiAgICAxLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcImlubGluZS1lbmRcIjogW1xuICAgIDIsXG4gICAgMyxcbiAgICBcIkxvZ2ljYWxcIlxuICAgIC8qIExvZ2ljYWwgKi9cbiAgXSxcbiAgXCJzcGFuLWlubGluZS1zdGFydFwiOiBbXG4gICAgMCxcbiAgICAyLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcInNwYW4taW5saW5lLWVuZFwiOiBbXG4gICAgMSxcbiAgICAzLFxuICAgIFwiTG9naWNhbFwiXG4gICAgLyogTG9naWNhbCAqL1xuICBdLFxuICBcInNlbGYtYmxvY2stc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMSxcbiAgICBcIkxvZ2ljYWxTZWxmXCJcbiAgICAvKiBMb2dpY2FsU2VsZiAqL1xuICBdLFxuICBcInNlbGYtYmxvY2stZW5kXCI6IFtcbiAgICAyLFxuICAgIDMsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzcGFuLXNlbGYtYmxvY2stc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMixcbiAgICBcIkxvZ2ljYWxTZWxmXCJcbiAgICAvKiBMb2dpY2FsU2VsZiAqL1xuICBdLFxuICBcInNwYW4tc2VsZi1ibG9jay1lbmRcIjogW1xuICAgIDEsXG4gICAgMyxcbiAgICBcIkxvZ2ljYWxTZWxmXCJcbiAgICAvKiBMb2dpY2FsU2VsZiAqL1xuICBdLFxuICBcInNlbGYtaW5saW5lLXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDEsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzZWxmLWlubGluZS1lbmRcIjogW1xuICAgIDIsXG4gICAgMyxcbiAgICBcIkxvZ2ljYWxTZWxmXCJcbiAgICAvKiBMb2dpY2FsU2VsZiAqL1xuICBdLFxuICBcInNwYW4tc2VsZi1pbmxpbmUtc3RhcnRcIjogW1xuICAgIDAsXG4gICAgMixcbiAgICBcIkxvZ2ljYWxTZWxmXCJcbiAgICAvKiBMb2dpY2FsU2VsZiAqL1xuICBdLFxuICBcInNwYW4tc2VsZi1pbmxpbmUtZW5kXCI6IFtcbiAgICAxLFxuICAgIDMsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXSxcbiAgc3RhcnQ6IFtcbiAgICAwLFxuICAgIDEsXG4gICAgXCJMb2dpY2FsXCJcbiAgICAvKiBMb2dpY2FsICovXG4gIF0sXG4gIGVuZDogW1xuICAgIDIsXG4gICAgMyxcbiAgICBcIkxvZ2ljYWxcIlxuICAgIC8qIExvZ2ljYWwgKi9cbiAgXSxcbiAgXCJzcGFuLXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDIsXG4gICAgXCJMb2dpY2FsXCJcbiAgICAvKiBMb2dpY2FsICovXG4gIF0sXG4gIFwic3Bhbi1lbmRcIjogW1xuICAgIDEsXG4gICAgMyxcbiAgICBcIkxvZ2ljYWxcIlxuICAgIC8qIExvZ2ljYWwgKi9cbiAgXSxcbiAgXCJzZWxmLXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDEsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzZWxmLWVuZFwiOiBbXG4gICAgMixcbiAgICAzLFxuICAgIFwiTG9naWNhbFNlbGZcIlxuICAgIC8qIExvZ2ljYWxTZWxmICovXG4gIF0sXG4gIFwic3Bhbi1zZWxmLXN0YXJ0XCI6IFtcbiAgICAwLFxuICAgIDIsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXSxcbiAgXCJzcGFuLXNlbGYtZW5kXCI6IFtcbiAgICAxLFxuICAgIDMsXG4gICAgXCJMb2dpY2FsU2VsZlwiXG4gICAgLyogTG9naWNhbFNlbGYgKi9cbiAgXVxufSwgTWYgPSBbXG4gIFwibGVmdFwiLFxuICBcImNlbnRlclwiLFxuICBcInJpZ2h0XCIsXG4gIFwic3Bhbi1sZWZ0XCIsXG4gIFwic3Bhbi1yaWdodFwiLFxuICBcIngtc3RhcnRcIixcbiAgXCJ4LWVuZFwiLFxuICBcInNwYW4teC1zdGFydFwiLFxuICBcInNwYW4teC1lbmRcIixcbiAgXCJ4LXNlbGYtc3RhcnRcIixcbiAgXCJ4LXNlbGYtZW5kXCIsXG4gIFwic3Bhbi14LXNlbGYtc3RhcnRcIixcbiAgXCJzcGFuLXgtc2VsZi1lbmRcIixcbiAgXCJzcGFuLWFsbFwiXG5dLCBqZiA9IFtcbiAgXCJ0b3BcIixcbiAgXCJjZW50ZXJcIixcbiAgXCJib3R0b21cIixcbiAgXCJzcGFuLXRvcFwiLFxuICBcInNwYW4tYm90dG9tXCIsXG4gIFwieS1zdGFydFwiLFxuICBcInktZW5kXCIsXG4gIFwic3Bhbi15LXN0YXJ0XCIsXG4gIFwic3Bhbi15LWVuZFwiLFxuICBcInktc2VsZi1zdGFydFwiLFxuICBcInktc2VsZi1lbmRcIixcbiAgXCJzcGFuLXktc2VsZi1zdGFydFwiLFxuICBcInNwYW4teS1zZWxmLWVuZFwiLFxuICBcInNwYW4tYWxsXCJcbl0sIEJmID0gW1xuICBcImJsb2NrLXN0YXJ0XCIsXG4gIFwiY2VudGVyXCIsXG4gIFwiYmxvY2stZW5kXCIsXG4gIFwic3Bhbi1ibG9jay1zdGFydFwiLFxuICBcInNwYW4tYmxvY2stZW5kXCIsXG4gIFwic3Bhbi1hbGxcIlxuXSwgV2YgPSBbXG4gIFwiaW5saW5lLXN0YXJ0XCIsXG4gIFwiY2VudGVyXCIsXG4gIFwiaW5saW5lLWVuZFwiLFxuICBcInNwYW4taW5saW5lLXN0YXJ0XCIsXG4gIFwic3Bhbi1pbmxpbmUtZW5kXCIsXG4gIFwic3Bhbi1hbGxcIlxuXSwgVWYgPSBbXG4gIFwic2VsZi1ibG9jay1zdGFydFwiLFxuICBcImNlbnRlclwiLFxuICBcInNlbGYtYmxvY2stZW5kXCIsXG4gIFwic3Bhbi1zZWxmLWJsb2NrLXN0YXJ0XCIsXG4gIFwic3Bhbi1zZWxmLWJsb2NrLWVuZFwiLFxuICBcInNwYW4tYWxsXCJcbl0sIHpmID0gW1xuICBcInNlbGYtaW5saW5lLXN0YXJ0XCIsXG4gIFwiY2VudGVyXCIsXG4gIFwic2VsZi1pbmxpbmUtZW5kXCIsXG4gIFwic3Bhbi1zZWxmLWlubGluZS1zdGFydFwiLFxuICBcInNwYW4tc2VsZi1pbmxpbmUtZW5kXCIsXG4gIFwic3Bhbi1hbGxcIlxuXSwgYnMgPSBbXG4gIFwic3RhcnRcIixcbiAgXCJjZW50ZXJcIixcbiAgXCJlbmRcIixcbiAgXCJzcGFuLXN0YXJ0XCIsXG4gIFwic3Bhbi1lbmRcIixcbiAgXCJzcGFuLWFsbFwiXG5dLCB4cyA9IFtcbiAgXCJzZWxmLXN0YXJ0XCIsXG4gIFwiY2VudGVyXCIsXG4gIFwic2VsZi1lbmRcIixcbiAgXCJzcGFuLXNlbGYtc3RhcnRcIixcbiAgXCJzcGFuLXNlbGYtZW5kXCIsXG4gIFwic3Bhbi1hbGxcIlxuXSwgVmYgPSBbXCJibG9ja1wiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcInlcIl0sIEhmID0gW1wiaW5saW5lXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwieFwiXTtcbmZ1bmN0aW9uIGRuKHQpIHtcbiAgY29uc3QgZSA9IHQuc3BsaXQoXCItXCIpO1xuICBmb3IgKGNvbnN0IG4gb2YgZSkge1xuICAgIGlmIChWZi5pbmNsdWRlcyhuKSkgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICBpZiAoSGYuaW5jbHVkZXMobikpIHJldHVybiBcImlubGluZVwiO1xuICB9XG4gIHJldHVybiBcImFtYmlndW91c1wiO1xufVxuZnVuY3Rpb24gR2YodCwgZSkge1xuICByZXR1cm4gZVswXS5pbmNsdWRlcyh0WzBdKSAmJiBlWzFdLmluY2x1ZGVzKHRbMV0pIHx8IGVbMF0uaW5jbHVkZXModFsxXSkgJiYgZVsxXS5pbmNsdWRlcyh0WzBdKTtcbn1cbmNvbnN0IHFmID0gW1xuICBbTWYsIGpmXSxcbiAgW0JmLCBXZl0sXG4gIFtVZiwgemZdLFxuICBbYnMsIGJzXSxcbiAgW3hzLCB4c11cbl07XG5mdW5jdGlvbiBLZih0KSB7XG4gIGZvciAoY29uc3QgZSBvZiBxZilcbiAgICBpZiAoR2YodCwgZSkpIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuY29uc3QgQ3MgPSAodCkgPT4ge1xuICBjb25zdCBlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgcmV0dXJuIHtcbiAgICB3cml0aW5nTW9kZTogZS53cml0aW5nTW9kZSxcbiAgICBkaXJlY3Rpb246IGUuZGlyZWN0aW9uXG4gIH07XG59LCBRZiA9ICh0LCBlKSA9PiBSKG51bGwsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IG4gPSB5aWVsZCB2bih0KTtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcIkxvZ2ljYWxcIjpcbiAgICBjYXNlIFwiUGh5c2ljYWxcIjpcbiAgICAgIHJldHVybiBDcyhuKTtcbiAgICBjYXNlIFwiTG9naWNhbFNlbGZcIjpcbiAgICBjYXNlIFwiUGh5c2ljYWxTZWxmXCI6XG4gICAgICByZXR1cm4gQ3ModCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59KSwgWmUgPSAodCkgPT4gdC5yZXZlcnNlKCkubWFwKChlKSA9PiAzIC0gZSksIGhvID0gKHQsIGUpID0+IHQgPT09IFwiSXJyZWxldmFudFwiID8gZSA6IHQsIFlmID0gKHMsIHIpID0+IFIobnVsbCwgW3MsIHJdLCBmdW5jdGlvbiogKHtcbiAgYmxvY2s6IHQsXG4gIGlubGluZTogZVxufSwgbikge1xuICBjb25zdCBvID0gaG8odFsyXSwgZVsyXSksIGEgPSB5aWVsZCBRZihuLCBvKSwgbCA9IHtcbiAgICBibG9jazogW3RbMF0sIHRbMV1dLFxuICAgIGlubGluZTogW2VbMF0sIGVbMV1dXG4gIH07XG4gIGlmIChhKSB7XG4gICAgaWYgKGEuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChsLmlubGluZSA9IFplKGwuaW5saW5lKSksIGEud3JpdGluZ01vZGUuc3RhcnRzV2l0aChcInZlcnRpY2FsXCIpKSB7XG4gICAgICBjb25zdCB1ID0gbC5ibG9jaztcbiAgICAgIGwuYmxvY2sgPSBsLmlubGluZSwgbC5pbmxpbmUgPSB1O1xuICAgIH1cbiAgICBpZiAoYS53cml0aW5nTW9kZS5zdGFydHNXaXRoKFwic2lkZXdheXNcIikpIHtcbiAgICAgIGNvbnN0IHUgPSBsLmJsb2NrO1xuICAgICAgbC5ibG9jayA9IGwuaW5saW5lLCBsLmlubGluZSA9IHUsIGEud3JpdGluZ01vZGUuZW5kc1dpdGgoXCJsclwiKSAmJiAobC5ibG9jayA9IFplKGwuYmxvY2spKTtcbiAgICB9XG4gICAgYS53cml0aW5nTW9kZS5lbmRzV2l0aChcInJsXCIpICYmIChsLmlubGluZSA9IFplKGwuaW5saW5lKSk7XG4gIH1cbiAgcmV0dXJuIGw7XG59KSwgWGYgPSAoe1xuICBibG9jazogdCxcbiAgaW5saW5lOiBlXG59KSA9PiB7XG4gIGNvbnN0IG4gPSBbMCwgXCJ0b3BcIiwgXCJib3R0b21cIiwgMF0sIHMgPSBbMCwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgMF07XG4gIHJldHVybiB7XG4gICAgYmxvY2s6IFtuW3RbMF1dLCBuW3RbMV1dXSxcbiAgICBpbmxpbmU6IFtzW2VbMF1dLCBzW2VbMV1dXVxuICB9O1xufTtcbmZ1bmN0aW9uIHdzKFt0LCBlXSkge1xuICByZXR1cm4gdCA9PT0gMCAmJiBlID09PSAzID8gXCJjZW50ZXJcIiA6IHQgPT09IDAgPyBcImVuZFwiIDogZSA9PT0gMyA/IFwic3RhcnRcIiA6IFwiY2VudGVyXCI7XG59XG5mdW5jdGlvbiBKZih0KSB7XG4gIHJldHVybiB0LnR5cGUgPT09IFwiRGVjbGFyYXRpb25cIiAmJiB0LnByb3BlcnR5ID09PSBcInBvc2l0aW9uLWFyZWFcIjtcbn1cbmZ1bmN0aW9uIFpmKHQpIHtcbiAgY29uc3QgZSA9IHQudmFsdWUuY2hpbGRyZW4udG9BcnJheSgpLm1hcCgoeyBuYW1lOiBuIH0pID0+IG4pO1xuICByZXR1cm4gZS5sZW5ndGggPT09IDEgJiYgKGRuKGVbMF0pID09PSBcImFtYmlndW91c1wiID8gZS5wdXNoKGVbMF0pIDogZS5wdXNoKFwic3Bhbi1hbGxcIikpLCBlO1xufVxuZnVuY3Rpb24gdHAodCkge1xuICBpZiAoIUpmKHQpKSByZXR1cm47XG4gIGNvbnN0IGUgPSBaZih0KTtcbiAgaWYgKCFLZihlKSkgcmV0dXJuO1xuICBjb25zdCBuID0ge307XG4gIHN3aXRjaCAoZG4oZVswXSkpIHtcbiAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgIG4uYmxvY2sgPSBlWzBdLCBuLmlubGluZSA9IGVbMV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICBuLmlubGluZSA9IGVbMF0sIG4uYmxvY2sgPSBlWzFdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFtYmlndW91c1wiOlxuICAgICAgZG4oZVsxXSkgPT0gXCJibG9ja1wiID8gKG4uYmxvY2sgPSBlWzFdLCBuLmlubGluZSA9IGVbMF0pIDogKG4uaW5saW5lID0gZVsxXSwgbi5ibG9jayA9IGVbMF0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgY29uc3QgcyA9IHtcbiAgICBibG9jazogeXNbbi5ibG9ja10sXG4gICAgaW5saW5lOiB5c1tuLmlubGluZV1cbiAgfSwgciA9IGAtLXBhLWRlY2xhcmF0aW9uLSR7b28oMTIpfWA7XG4gIHJldHVybiB7XG4gICAgdmFsdWVzOiBuLFxuICAgIGdyaWQ6IHMsXG4gICAgc2VsZWN0b3JVVUlEOiByXG4gIH07XG59XG5mdW5jdGlvbiBlcCh0LCBlKSB7XG4gIFtcbiAgICAvLyBJbnNldHMgYXJlIGFwcGxpZWQgdG8gYSB3cmFwcGluZyBlbGVtZW50XG4gICAgXCJqdXN0aWZ5LXNlbGZcIixcbiAgICBcImFsaWduLXNlbGZcIlxuICBdLmZvckVhY2goKG4pID0+IHtcbiAgICBlLmNoaWxkcmVuLmFwcGVuZERhdGEoe1xuICAgICAgdHlwZTogXCJEZWNsYXJhdGlvblwiLFxuICAgICAgcHJvcGVydHk6IG4sXG4gICAgICB2YWx1ZTogeyB0eXBlOiBcIlJhd1wiLCB2YWx1ZTogYHZhcigtLXBhLXZhbHVlLSR7bn0pYCB9LFxuICAgICAgaW1wb3J0YW50OiAhMVxuICAgIH0pO1xuICB9KSwgZS5jaGlsZHJlbi5hcHBlbmREYXRhKHtcbiAgICB0eXBlOiBcIkRlY2xhcmF0aW9uXCIsXG4gICAgcHJvcGVydHk6IGFvLFxuICAgIHZhbHVlOiB7IHR5cGU6IFwiUmF3XCIsIHZhbHVlOiB0LnNlbGVjdG9yVVVJRCB9LFxuICAgIGltcG9ydGFudDogITFcbiAgfSk7XG59XG5mdW5jdGlvbiBucCh0LCBlKSB7XG4gIHZhciBzLCByO1xuICBsZXQgbjtcbiAgaWYgKCgocyA9IHQucGFyZW50RWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMudGFnTmFtZSkgPT09IFNzKVxuICAgIG4gPSB0LnBhcmVudEVsZW1lbnQ7XG4gIGVsc2Uge1xuICAgIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFNzKSwgbi5zdHlsZS5kaXNwbGF5ID0gXCJncmlkXCIsIG4uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgY29uc3QgbyA9IGdldENvbXB1dGVkU3R5bGUodCkucG9pbnRlckV2ZW50cztcbiAgICBuLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIiwgdC5zdHlsZS5wb2ludGVyRXZlbnRzID0gbywgW1widG9wXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdLmZvckVhY2goKGEpID0+IHtcbiAgICAgIG4uc3R5bGUuc2V0UHJvcGVydHkoYSwgYHZhcigtLXBhLXZhbHVlLSR7YX0pYCk7XG4gICAgfSksIChyID0gdC5wYXJlbnRFbGVtZW50KSA9PSBudWxsIHx8IHIuaW5zZXJ0QmVmb3JlKG4sIHQpLCBuLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIHJldHVybiBuLnNldEF0dHJpYnV0ZShcbiAgICBgJHtjb30ke2V9YCxcbiAgICBcIlwiXG4gICksIG47XG59XG5mdW5jdGlvbiBzcCh0LCBlLCBuKSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcyA9IGAtLXBhLXRhcmdldC0ke29vKDEyKX1gLCByID0geWllbGQgWWYoXG4gICAgICBlLmdyaWQsXG4gICAgICB0XG4gICAgKSwgbyA9IFhmKHIpLCBhID0gaG8oXG4gICAgICBlLmdyaWQuYmxvY2tbMl0sXG4gICAgICBlLmdyaWQuaW5saW5lWzJdXG4gICAgKSwgbCA9IFtcbiAgICAgIFwiTG9naWNhbFNlbGZcIixcbiAgICAgIFwiUGh5c2ljYWxTZWxmXCJcbiAgICAgIC8qIFBoeXNpY2FsU2VsZiAqL1xuICAgIF0uaW5jbHVkZXMoYSkgPyByIDogZS5ncmlkLCB1ID0ge1xuICAgICAgYmxvY2s6IHdzKFtsLmJsb2NrWzBdLCBsLmJsb2NrWzFdXSksXG4gICAgICBpbmxpbmU6IHdzKFtcbiAgICAgICAgbC5pbmxpbmVbMF0sXG4gICAgICAgIGwuaW5saW5lWzFdXG4gICAgICBdKVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc2V0czogbyxcbiAgICAgIGFsaWdubWVudHM6IHUsXG4gICAgICB0YXJnZXRVVUlEOiBzLFxuICAgICAgdGFyZ2V0RWw6IHQsXG4gICAgICBhbmNob3JFbDogbixcbiAgICAgIHdyYXBwZXJFbDogbnAodCwgcyksXG4gICAgICB2YWx1ZXM6IGUudmFsdWVzLFxuICAgICAgZ3JpZDogZS5ncmlkLFxuICAgICAgc2VsZWN0b3JVVUlEOiBlLnNlbGVjdG9yVVVJRFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcnAodCwgZSkge1xuICByZXR1cm4gYFxuICAgIFske2xvfT1cIiR7ZX1cIl1bJHtjb30ke3R9XSB7XG4gICAgICAtLXBhLXZhbHVlLXRvcDogdmFyKCR7dH0tdG9wKTtcbiAgICAgIC0tcGEtdmFsdWUtbGVmdDogdmFyKCR7dH0tbGVmdCk7XG4gICAgICAtLXBhLXZhbHVlLXJpZ2h0OiB2YXIoJHt0fS1yaWdodCk7XG4gICAgICAtLXBhLXZhbHVlLWJvdHRvbTogdmFyKCR7dH0tYm90dG9tKTtcbiAgICAgIC0tcGEtdmFsdWUtanVzdGlmeS1zZWxmOiB2YXIoJHt0fS1qdXN0aWZ5LXNlbGYpO1xuICAgICAgLS1wYS12YWx1ZS1hbGlnbi1zZWxmOiB2YXIoJHt0fS1hbGlnbi1zZWxmKTtcbiAgICB9XG4gIGAucmVwbGFjZUFsbChgXG5gLCBcIlwiKTtcbn1cbmNvbnN0IGlwID0gW1xuICBcIm5vcm1hbFwiLFxuICBcIm1vc3Qtd2lkdGhcIixcbiAgXCJtb3N0LWhlaWdodFwiLFxuICBcIm1vc3QtYmxvY2stc2l6ZVwiLFxuICBcIm1vc3QtaW5saW5lLXNpemVcIlxuXSwgb3AgPSBbXG4gIFwiZmxpcC1ibG9ja1wiLFxuICBcImZsaXAtaW5saW5lXCIsXG4gIFwiZmxpcC1zdGFydFwiXG5dO1xuZnVuY3Rpb24gYXAodCkge1xuICByZXR1cm4gdC50eXBlID09PSBcIkRlY2xhcmF0aW9uXCI7XG59XG5mdW5jdGlvbiBscCh0KSB7XG4gIHJldHVybiB0LnR5cGUgPT09IFwiRGVjbGFyYXRpb25cIiAmJiB0LnByb3BlcnR5ID09PSBcInBvc2l0aW9uLXRyeS1mYWxsYmFja3NcIjtcbn1cbmZ1bmN0aW9uIGNwKHQpIHtcbiAgcmV0dXJuIHQudHlwZSA9PT0gXCJEZWNsYXJhdGlvblwiICYmIHQucHJvcGVydHkgPT09IFwicG9zaXRpb24tdHJ5LW9yZGVyXCI7XG59XG5mdW5jdGlvbiB1cCh0KSB7XG4gIHJldHVybiB0LnR5cGUgPT09IFwiRGVjbGFyYXRpb25cIiAmJiB0LnByb3BlcnR5ID09PSBcInBvc2l0aW9uLXRyeVwiO1xufVxuZnVuY3Rpb24gaHAodCkge1xuICByZXR1cm4gdC50eXBlID09PSBcIkF0cnVsZVwiICYmIHQubmFtZSA9PT0gXCJwb3NpdGlvbi10cnlcIjtcbn1cbmZ1bmN0aW9uIGZwKHQpIHtcbiAgcmV0dXJuIG9wLmluY2x1ZGVzKHQpO1xufVxuZnVuY3Rpb24gcHAodCkge1xuICByZXR1cm4gaXAuaW5jbHVkZXModCk7XG59XG5mdW5jdGlvbiBkcCh0LCBlKSB7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpO1xuICBpZiAobikge1xuICAgIGxldCBzID0gbXAobik7XG4gICAgcmV0dXJuIGUuZm9yRWFjaCgocikgPT4ge1xuICAgICAgcyA9IGZvKHMsIHIpO1xuICAgIH0pLCBzO1xuICB9XG59XG5mdW5jdGlvbiBncCh0LCBlKSB7XG4gIGxldCBuID0gdC5kZWNsYXJhdGlvbnM7XG4gIHJldHVybiBlLmZvckVhY2goKHMpID0+IHtcbiAgICBuID0gZm8obiwgcyk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gbXAodCkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBYaS5mb3JFYWNoKChuKSA9PiB7XG4gICAgY29uc3QgcyA9IG90KHQsIGAtLSR7bn0tJHtyb31gKTtcbiAgICBzICYmIChlW25dID0gcyk7XG4gIH0pLCBlO1xufVxuY29uc3Qga3AgPSB7XG4gIFwiZmxpcC1ibG9ja1wiOiB7XG4gICAgdG9wOiBcImJvdHRvbVwiLFxuICAgIGJvdHRvbTogXCJ0b3BcIixcbiAgICBcImluc2V0LWJsb2NrLXN0YXJ0XCI6IFwiaW5zZXQtYmxvY2stZW5kXCIsXG4gICAgXCJpbnNldC1ibG9jay1lbmRcIjogXCJpbnNldC1ibG9jay1zdGFydFwiLFxuICAgIFwibWFyZ2luLXRvcFwiOiBcIm1hcmdpbi1ib3R0b21cIixcbiAgICBcIm1hcmdpbi1ib3R0b21cIjogXCJtYXJnaW4tdG9wXCJcbiAgfSxcbiAgXCJmbGlwLWlubGluZVwiOiB7XG4gICAgbGVmdDogXCJyaWdodFwiLFxuICAgIHJpZ2h0OiBcImxlZnRcIixcbiAgICBcImluc2V0LWlubGluZS1zdGFydFwiOiBcImluc2V0LWlubGluZS1lbmRcIixcbiAgICBcImluc2V0LWlubGluZS1lbmRcIjogXCJpbnNldC1pbmxpbmUtc3RhcnRcIixcbiAgICBcIm1hcmdpbi1sZWZ0XCI6IFwibWFyZ2luLXJpZ2h0XCIsXG4gICAgXCJtYXJnaW4tcmlnaHRcIjogXCJtYXJnaW4tbGVmdFwiXG4gIH0sXG4gIFwiZmxpcC1zdGFydFwiOiB7XG4gICAgbGVmdDogXCJ0b3BcIixcbiAgICByaWdodDogXCJib3R0b21cIixcbiAgICB0b3A6IFwibGVmdFwiLFxuICAgIGJvdHRvbTogXCJyaWdodFwiLFxuICAgIFwiaW5zZXQtYmxvY2stc3RhcnRcIjogXCJpbnNldC1ibG9jay1lbmRcIixcbiAgICBcImluc2V0LWJsb2NrLWVuZFwiOiBcImluc2V0LWJsb2NrLXN0YXJ0XCIsXG4gICAgXCJpbnNldC1pbmxpbmUtc3RhcnRcIjogXCJpbnNldC1pbmxpbmUtZW5kXCIsXG4gICAgXCJpbnNldC1pbmxpbmUtZW5kXCI6IFwiaW5zZXQtaW5saW5lLXN0YXJ0XCIsXG4gICAgXCJpbnNldC1ibG9ja1wiOiBcImluc2V0LWlubGluZVwiLFxuICAgIFwiaW5zZXQtaW5saW5lXCI6IFwiaW5zZXQtYmxvY2tcIlxuICB9XG59LCBTcCA9IHtcbiAgXCJmbGlwLWJsb2NrXCI6IHtcbiAgICB0b3A6IFwiYm90dG9tXCIsXG4gICAgYm90dG9tOiBcInRvcFwiLFxuICAgIHN0YXJ0OiBcImVuZFwiLFxuICAgIGVuZDogXCJzdGFydFwiLFxuICAgIFwic2VsZi1lbmRcIjogXCJzZWxmLXN0YXJ0XCIsXG4gICAgXCJzZWxmLXN0YXJ0XCI6IFwic2VsZi1lbmRcIlxuICB9LFxuICBcImZsaXAtaW5saW5lXCI6IHtcbiAgICBsZWZ0OiBcInJpZ2h0XCIsXG4gICAgcmlnaHQ6IFwibGVmdFwiLFxuICAgIHN0YXJ0OiBcImVuZFwiLFxuICAgIGVuZDogXCJzdGFydFwiLFxuICAgIFwic2VsZi1lbmRcIjogXCJzZWxmLXN0YXJ0XCIsXG4gICAgXCJzZWxmLXN0YXJ0XCI6IFwic2VsZi1lbmRcIlxuICB9LFxuICBcImZsaXAtc3RhcnRcIjoge1xuICAgIHRvcDogXCJsZWZ0XCIsXG4gICAgbGVmdDogXCJ0b3BcIixcbiAgICByaWdodDogXCJib3R0b21cIixcbiAgICBib3R0b206IFwicmlnaHRcIlxuICB9XG59LCB5cCA9IHtcbiAgXCJmbGlwLWJsb2NrXCI6IHtcbiAgICB0b3A6IFwiYm90dG9tXCIsXG4gICAgYm90dG9tOiBcInRvcFwiLFxuICAgIHN0YXJ0OiBcImVuZFwiLFxuICAgIGVuZDogXCJzdGFydFwiXG4gIH0sXG4gIFwiZmxpcC1pbmxpbmVcIjoge1xuICAgIGxlZnQ6IFwicmlnaHRcIixcbiAgICByaWdodDogXCJsZWZ0XCIsXG4gICAgc3RhcnQ6IFwiZW5kXCIsXG4gICAgZW5kOiBcInN0YXJ0XCJcbiAgfSxcbiAgXCJmbGlwLXN0YXJ0XCI6IHtcbiAgICAvLyBUT0RPOiBSZXF1aXJlcyBmdWxsZXIgbG9naWNcbiAgfVxufTtcbmZ1bmN0aW9uIGJwKHQsIGUpIHtcbiAgcmV0dXJuIGtwW2VdW3RdIHx8IHQ7XG59XG5mdW5jdGlvbiB4cCh0LCBlKSB7XG4gIHJldHVybiBTcFtlXVt0XSB8fCB0O1xufVxuZnVuY3Rpb24gQ3AodCwgZSkge1xuICBpZiAoZSA9PT0gXCJmbGlwLXN0YXJ0XCIpXG4gICAgcmV0dXJuIHQ7XG4gIHtcbiAgICBjb25zdCBuID0geXBbZV07XG4gICAgcmV0dXJuIHQuc3BsaXQoXCItXCIpLm1hcCgocykgPT4gbltzXSB8fCBzKS5qb2luKFwiLVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd3AodCwgZSwgbikge1xuICBpZiAodCA9PT0gXCJtYXJnaW5cIikge1xuICAgIGNvbnN0IFtzLCByLCBvLCBhXSA9IGUuY2hpbGRyZW4udG9BcnJheSgpO1xuICAgIG4gPT09IFwiZmxpcC1ibG9ja1wiID8gYSA/IGUuY2hpbGRyZW4uZnJvbUFycmF5KFtvLCByLCBzLCBhXSkgOiBvICYmIGUuY2hpbGRyZW4uZnJvbUFycmF5KFtvLCByLCBzXSkgOiBuID09PSBcImZsaXAtaW5saW5lXCIgJiYgYSAmJiBlLmNoaWxkcmVuLmZyb21BcnJheShbcywgYSwgbywgcl0pO1xuICB9IGVsc2UgaWYgKHQgPT09IFwibWFyZ2luLWJsb2NrXCIpIHtcbiAgICBjb25zdCBbcywgcl0gPSBlLmNoaWxkcmVuLnRvQXJyYXkoKTtcbiAgICBuID09PSBcImZsaXAtYmxvY2tcIiAmJiByICYmIGUuY2hpbGRyZW4uZnJvbUFycmF5KFtyLCBzXSk7XG4gIH0gZWxzZSBpZiAodCA9PT0gXCJtYXJnaW4taW5saW5lXCIpIHtcbiAgICBjb25zdCBbcywgcl0gPSBlLmNoaWxkcmVuLnRvQXJyYXkoKTtcbiAgICBuID09PSBcImZsaXAtaW5saW5lXCIgJiYgciAmJiBlLmNoaWxkcmVuLmZyb21BcnJheShbciwgc10pO1xuICB9XG59XG5jb25zdCBUcCA9ICh0LCBlKSA9PiB7XG4gIHZhciByO1xuICByZXR1cm4gKChyID0gTHQoYCNpZHske3R9OiAke2V9O31gKS5jaGlsZHJlbi5maXJzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYmxvY2suY2hpbGRyZW4uZmlyc3QpLnZhbHVlO1xufTtcbmZ1bmN0aW9uIGZvKHQsIGUpIHtcbiAgY29uc3QgbiA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoW3MsIHJdKSA9PiB7XG4gICAgdmFyIHU7XG4gICAgY29uc3QgbyA9IHMsIGEgPSBUcChvLCByKSwgbCA9IGJwKG8sIGUpO1xuICAgIGwgIT09IG8gJiYgKCh1ID0gbltvXSkgIT0gbnVsbCB8fCAobltvXSA9IFwicmV2ZXJ0XCIpKSwgJHQoYSwge1xuICAgICAgdmlzaXQ6IFwiRnVuY3Rpb25cIixcbiAgICAgIGVudGVyKGkpIHtcbiAgICAgICAgT2UoaSkgJiYgaS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgb2UoYykgJiYgWmkoYy5uYW1lKSAmJiAoYy5uYW1lID0geHAoYy5uYW1lLCBlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBvID09PSBcInBvc2l0aW9uLWFyZWFcIiAmJiBhLmNoaWxkcmVuLmZvckVhY2goKGkpID0+IHtcbiAgICAgIG9lKGkpICYmIHVvKGkubmFtZSkgJiYgKGkubmFtZSA9IENwKGkubmFtZSwgZSkpO1xuICAgIH0pLCBvLnN0YXJ0c1dpdGgoXCJtYXJnaW5cIikgJiYgd3AobywgYSwgZSksIG5bbF0gPSBaKGEpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIHBvKHQpIHtcbiAgY29uc3QgZSA9IGJmKHQpLCBuID0gW107XG4gIHJldHVybiBlLmZvckVhY2goKHMpID0+IHtcbiAgICBjb25zdCByID0ge1xuICAgICAgYXRSdWxlczogW10sXG4gICAgICB0YWN0aWNzOiBbXSxcbiAgICAgIHBvc2l0aW9uQXJlYXM6IFtdXG4gICAgfTtcbiAgICBzLmZvckVhY2goKG8pID0+IHtcbiAgICAgIGZwKG8ubmFtZSkgPyByLnRhY3RpY3MucHVzaChvLm5hbWUpIDogby5uYW1lLnN0YXJ0c1dpdGgoXCItLVwiKSA/IHIuYXRSdWxlcy5wdXNoKG8ubmFtZSkgOiB1byhvLm5hbWUpICYmIHIucG9zaXRpb25BcmVhcy5wdXNoKG8ubmFtZSk7XG4gICAgfSksIHIucG9zaXRpb25BcmVhcy5sZW5ndGggPyBuLnB1c2goe1xuICAgICAgcG9zaXRpb25BcmVhOiByLnBvc2l0aW9uQXJlYXNbMF0sXG4gICAgICB0eXBlOiBcInBvc2l0aW9uLWFyZWFcIlxuICAgIH0pIDogci5hdFJ1bGVzLmxlbmd0aCAmJiByLnRhY3RpY3MubGVuZ3RoID8gbi5wdXNoKHtcbiAgICAgIHRhY3RpY3M6IHIudGFjdGljcyxcbiAgICAgIGF0UnVsZTogci5hdFJ1bGVzWzBdLFxuICAgICAgdHlwZTogXCJhdC1ydWxlLXdpdGgtdHJ5LXRhY3RpY1wiXG4gICAgfSkgOiByLmF0UnVsZXMubGVuZ3RoID8gbi5wdXNoKHtcbiAgICAgIGF0UnVsZTogci5hdFJ1bGVzWzBdLFxuICAgICAgdHlwZTogXCJhdC1ydWxlXCJcbiAgICB9KSA6IHIudGFjdGljcy5sZW5ndGggJiYgbi5wdXNoKHtcbiAgICAgIHRhY3RpY3M6IHIudGFjdGljcyxcbiAgICAgIHR5cGU6IFwidHJ5LXRhY3RpY1wiXG4gICAgfSk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gQXAodCkge1xuICByZXR1cm4gbHAodCkgJiYgdC52YWx1ZS5jaGlsZHJlbi5maXJzdCA/IHBvKHQudmFsdWUuY2hpbGRyZW4pIDogW107XG59XG5mdW5jdGlvbiB2cCh0KSB7XG4gIGlmICh1cCh0KSAmJiB0LnZhbHVlLmNoaWxkcmVuLmZpcnN0KSB7XG4gICAgY29uc3QgZSA9IFBlKHQpO1xuICAgIGxldCBuO1xuICAgIGNvbnN0IHMgPSBlLnZhbHVlLmNoaWxkcmVuLmZpcnN0Lm5hbWU7XG4gICAgcyAmJiBwcChzKSAmJiAobiA9IHMsIGUudmFsdWUuY2hpbGRyZW4uc2hpZnQoKSk7XG4gICAgY29uc3QgciA9IHBvKGUudmFsdWUuY2hpbGRyZW4pO1xuICAgIHJldHVybiB7IG9yZGVyOiBuLCBvcHRpb25zOiByIH07XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gRXAodCkge1xuICByZXR1cm4gY3AodCkgJiYgdC52YWx1ZS5jaGlsZHJlbi5maXJzdCA/IHtcbiAgICBvcmRlcjogdC52YWx1ZS5jaGlsZHJlbi5maXJzdC5uYW1lXG4gIH0gOiB7fTtcbn1cbmZ1bmN0aW9uICRwKHQpIHtcbiAgY29uc3QgeyBvcmRlcjogZSwgb3B0aW9uczogbiB9ID0gdnAodCk7XG4gIGlmIChlIHx8IG4pXG4gICAgcmV0dXJuIHsgb3JkZXI6IGUsIG9wdGlvbnM6IG4gfTtcbiAgY29uc3QgeyBvcmRlcjogcyB9ID0gRXAodCksIHIgPSBBcCh0KTtcbiAgcmV0dXJuIHMgfHwgciA/IHsgb3JkZXI6IHMsIG9wdGlvbnM6IHIgfSA6IHt9O1xufVxuZnVuY3Rpb24gTHAodCkge1xuICByZXR1cm4gdWUodC5wcm9wZXJ0eSkgfHwgb2godC5wcm9wZXJ0eSkgfHwgUWkodC5wcm9wZXJ0eSkgfHwgYWgodC5wcm9wZXJ0eSkgfHwgW1wicG9zaXRpb24tYW5jaG9yXCIsIFwicG9zaXRpb24tYXJlYVwiXS5pbmNsdWRlcyh0LnByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIFBwKHQpIHtcbiAgdmFyIGUsIG47XG4gIGlmIChocCh0KSAmJiAoKGUgPSB0LnByZWx1ZGUpICE9IG51bGwgJiYgZS52YWx1ZSkgJiYgKChuID0gdC5ibG9jaykgIT0gbnVsbCAmJiBuLmNoaWxkcmVuKSkge1xuICAgIGNvbnN0IHMgPSB0LnByZWx1ZGUudmFsdWUsIHIgPSB0LmJsb2NrLmNoaWxkcmVuLmZpbHRlcihcbiAgICAgIChhKSA9PiBhcChhKSAmJiBMcChhKVxuICAgICksIG8gPSB7XG4gICAgICB1dWlkOiBgJHtzfS10cnktJHtsdCgxMil9YCxcbiAgICAgIGRlY2xhcmF0aW9uczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICByLm1hcCgoYSkgPT4gW2EucHJvcGVydHksIFooYS52YWx1ZSldKVxuICAgICAgKVxuICAgIH07XG4gICAgcmV0dXJuIHsgbmFtZTogcywgdHJ5QmxvY2s6IG8gfTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBPcCh0KSB7XG4gIGNvbnN0IGUgPSB7fSwgbiA9IHt9LCBzID0ge307XG4gIGZvciAoY29uc3QgciBvZiB0KSB7XG4gICAgY29uc3QgbyA9IEx0KHIuY3NzKTtcbiAgICAkdChvLCB7XG4gICAgICB2aXNpdDogXCJBdHJ1bGVcIixcbiAgICAgIGVudGVyKGEpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lOiBsLCB0cnlCbG9jazogdSB9ID0gUHAoYSk7XG4gICAgICAgIGwgJiYgdSAmJiAoZVtsXSA9IHUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgciBvZiB0KSB7XG4gICAgbGV0IG8gPSAhMTtcbiAgICBjb25zdCBhID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbCA9IEx0KHIuY3NzKTtcbiAgICAkdChsLCB7XG4gICAgICB2aXNpdDogXCJEZWNsYXJhdGlvblwiLFxuICAgICAgZW50ZXIodSkge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgY29uc3QgaSA9IChkID0gdGhpcy5ydWxlKSA9PSBudWxsID8gdm9pZCAwIDogZC5wcmVsdWRlLCBjID0gZm4oaSk7XG4gICAgICAgIGlmICghYy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBvcmRlcjogaCwgb3B0aW9uczogZiB9ID0gJHAodSksIHAgPSB7fTtcbiAgICAgICAgaCAmJiAocC5vcmRlciA9IGgpLCBjLmZvckVhY2goKHsgc2VsZWN0b3I6IG0gfSkgPT4ge1xuICAgICAgICAgIHZhciBrLCB5O1xuICAgICAgICAgIGYgPT0gbnVsbCB8fCBmLmZvckVhY2goKHgpID0+IHtcbiAgICAgICAgICAgIHZhciBNLCBldCwgdztcbiAgICAgICAgICAgIGxldCBBO1xuICAgICAgICAgICAgaWYgKHgudHlwZSA9PT0gXCJhdC1ydWxlXCIpXG4gICAgICAgICAgICAgIEEgPSB4LmF0UnVsZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHgudHlwZSA9PT0gXCJ0cnktdGFjdGljXCIpIHtcbiAgICAgICAgICAgICAgQSA9IGAke219LSR7eC50YWN0aWNzLmpvaW4oXCItXCIpfWA7XG4gICAgICAgICAgICAgIGNvbnN0IEMgPSBkcChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHgudGFjdGljc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBDICYmIChlW0FdID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IGAke219LSR7eC50YWN0aWNzLmpvaW4oXCItXCIpfS10cnktJHtsdCgxMil9YCxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IENcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHgudHlwZSA9PT0gXCJhdC1ydWxlLXdpdGgtdHJ5LXRhY3RpY1wiKSB7XG4gICAgICAgICAgICAgIEEgPSBgJHttfS0ke3guYXRSdWxlfS0ke3gudGFjdGljcy5qb2luKFwiLVwiKX1gO1xuICAgICAgICAgICAgICBjb25zdCBDID0gZVt4LmF0UnVsZV0sIE8gPSBncChcbiAgICAgICAgICAgICAgICBDLFxuICAgICAgICAgICAgICAgIHgudGFjdGljc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBPICYmIChlW0FdID0ge1xuICAgICAgICAgICAgICAgIHV1aWQ6IGAke219LSR7eC5hdFJ1bGV9LSR7eC50YWN0aWNzLmpvaW4oXCItXCIpfS10cnktJHtsdCgxMil9YCxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IE9cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQSAmJiBlW0FdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEMgPSBgW2RhdGEtYW5jaG9yLXBvbHlmaWxsPVwiJHtlW0FdLnV1aWR9XCJdYDtcbiAgICAgICAgICAgICAgKE0gPSBuW0NdKSAhPSBudWxsIHx8IChuW0NdID0gW10pLCBuW0NdLnB1c2gobSksIGEuaGFzKEEpIHx8ICgoZXQgPSBwLmZhbGxiYWNrcykgIT0gbnVsbCB8fCAocC5mYWxsYmFja3MgPSBbXSksIHAuZmFsbGJhY2tzLnB1c2goZVtBXSksIGEuYWRkKEEpLCAodyA9IHRoaXMuc3R5bGVzaGVldCkgPT0gbnVsbCB8fCB3LmNoaWxkcmVuLnByZXBlbmREYXRhKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICAgICAgICAgICAgICBwcmVsdWRlOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIlJhd1wiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IENcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIkJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogbmV3IEsoKS5mcm9tQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGVbQV0uZGVjbGFyYXRpb25zKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgKFtPLCBQXSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogTyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUmF3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBQXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIG8gPSAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIE9iamVjdC5rZXlzKHApLmxlbmd0aCA+IDAgJiYgKHNbbV0gPyAocC5vcmRlciAmJiAoc1ttXS5vcmRlciA9IHAub3JkZXIpLCBwLmZhbGxiYWNrcyAmJiAoKHkgPSAoayA9IHNbbV0pLmZhbGxiYWNrcykgIT0gbnVsbCB8fCAoay5mYWxsYmFja3MgPSBbXSksIHNbbV0uZmFsbGJhY2tzLnB1c2goXG4gICAgICAgICAgICAuLi5wLmZhbGxiYWNrc1xuICAgICAgICAgICkpKSA6IHNbbV0gPSBwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIG8gJiYgKHIuY3NzID0gWihsKSwgci5jaGFuZ2VkID0gITApO1xuICB9XG4gIHJldHVybiB7IGZhbGxiYWNrVGFyZ2V0czogbiwgdmFsaWRQb3NpdGlvbnM6IHMgfTtcbn1cbmZ1bmN0aW9uIFJwKHQsIGUpIHtcbiAgcmV0dXJuICF0IHx8IHQgPT09IGUgPyAhMSA6IGdvKHQpID8gdC5kb2N1bWVudC5jb250YWlucyhlKSA6IHQuY29udGFpbnMoZSk7XG59XG5mdW5jdGlvbiBnbyh0KSB7XG4gIHJldHVybiAhISh0ICYmIHQgPT09IHQud2luZG93KTtcbn1cbmZ1bmN0aW9uIF9wKHQpIHtcbiAgcmV0dXJuIFp0KHQsIFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKTtcbn1cbmZ1bmN0aW9uIGduKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgKF9wKHQpIHx8IFp0KHQsIFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKSkpO1xufVxuZnVuY3Rpb24gVHModCwgZSkge1xuICByZXR1cm4gdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xufVxuZnVuY3Rpb24gSXAodCkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB5aWVsZCBWLmdldE9mZnNldFBhcmVudCh0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0bih0KSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdLmluY2x1ZGVzKG90KHQsIFwicG9zaXRpb25cIikpKVxuICAgICAgcmV0dXJuIHlpZWxkIElwKHQpO1xuICAgIGxldCBlID0gdC5wYXJlbnRFbGVtZW50O1xuICAgIGZvciAoOyBlOyApIHtcbiAgICAgIGlmICghWnQoZSwgXCJwb3NpdGlvblwiLCBcInN0YXRpY1wiKSAmJiBadChlLCBcImRpc3BsYXlcIiwgXCJibG9ja1wiKSlcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBlID0gZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93O1xuICB9KTtcbn1cbmZ1bmN0aW9uIE5wKHQsIGUsIG4sIHMpIHtcbiAgcmV0dXJuIFIodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCByID0geWllbGQgdG4odCksIG8gPSB5aWVsZCB0bihuKTtcbiAgICBpZiAoIShScChvLCB0KSB8fCBnbyhvKSkgfHwgciA9PT0gbyAmJiAhKCFnbih0KSB8fCBUcyh0LCBuKSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKHIgIT09IG8pIHtcbiAgICAgIGxldCBhO1xuICAgICAgY29uc3QgbCA9IFtdO1xuICAgICAgZm9yIChhID0gcjsgYSAmJiBhICE9PSBvICYmIGEgIT09IHdpbmRvdzsgKVxuICAgICAgICBsLnB1c2goYSksIGEgPSB5aWVsZCB0bihhKTtcbiAgICAgIGNvbnN0IHUgPSBsW2wubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICEoIWduKHUpIHx8IFRzKHUsIG4pKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICB7XG4gICAgICBsZXQgYSA9IHQucGFyZW50RWxlbWVudDtcbiAgICAgIGZvciAoOyBhOyApIHtcbiAgICAgICAgaWYgKFp0KGEsIFwiY29udGVudC12aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgYSA9IGEucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEoZSAmJiBzICYmIEFzKHQsIGUsIHMpICE9PSBBcyhuLCBlLCBzKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gQXModCwgZSwgbikge1xuICBmb3IgKDsgISh0Lm1hdGNoZXMobikgJiYgUGYodCwgZSkpOyApIHtcbiAgICBpZiAoIXQucGFyZW50RWxlbWVudClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHQgPSB0LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBEcCh0LCBlLCBuLCBzLCByKSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG4ubGVuZ3RoICYmIGduKHQpKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG8gPSBuLmZsYXRNYXAoKGwpID0+ICRmKGwsIHIpKS5maWx0ZXIoKGwpID0+IExmKGwsIGUpKSwgYSA9IHMubWFwKChsKSA9PiBsLnNlbGVjdG9yKS5qb2luKFwiLFwiKSB8fCBudWxsO1xuICAgIGZvciAobGV0IGwgPSBvLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCB1ID0gb1tsXSwgaSA9IFwiZmFrZVBzZXVkb0VsZW1lbnRcIiBpbiB1O1xuICAgICAgaWYgKHlpZWxkIE5wKFxuICAgICAgICBpID8gdS5mYWtlUHNldWRvRWxlbWVudCA6IHUsXG4gICAgICAgIGUsXG4gICAgICAgIHQsXG4gICAgICAgIGFcbiAgICAgICkpXG4gICAgICAgIHJldHVybiBpICYmIHUucmVtb3ZlRmFrZVBzZXVkb0VsZW1lbnQoKSwgdTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufVxuZnVuY3Rpb24gRnAodCkge1xuICByZXR1cm4gdC50eXBlID09PSBcIkRlY2xhcmF0aW9uXCIgJiYgdC5wcm9wZXJ0eSA9PT0gXCJhbmNob3ItbmFtZVwiO1xufVxuZnVuY3Rpb24gTXAodCkge1xuICByZXR1cm4gdC50eXBlID09PSBcIkRlY2xhcmF0aW9uXCIgJiYgdC5wcm9wZXJ0eSA9PT0gXCJhbmNob3Itc2NvcGVcIjtcbn1cbmZ1bmN0aW9uIG1uKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgdC50eXBlID09PSBcIkZ1bmN0aW9uXCIgJiYgdC5uYW1lID09PSBcImFuY2hvci1zaXplXCIpO1xufVxuZnVuY3Rpb24gd2UodCkge1xuICByZXR1cm4gISEodCAmJiB0LnR5cGUgPT09IFwiRnVuY3Rpb25cIiAmJiB0Lm5hbWUgPT09IFwidmFyXCIpO1xufVxuZnVuY3Rpb24gb2UodCkge1xuICByZXR1cm4gISEodC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0Lm5hbWUpO1xufVxuZnVuY3Rpb24ganAodCkge1xuICByZXR1cm4gISEodC50eXBlID09PSBcIlBlcmNlbnRhZ2VcIiAmJiB0LnZhbHVlKTtcbn1cbmZ1bmN0aW9uIHZzKHQsIGUpIHtcbiAgbGV0IG4sIHMsIHIsIG8gPSBcIlwiLCBhID0gITEsIGw7XG4gIGNvbnN0IHUgPSBbXTtcbiAgdC5jaGlsZHJlbi50b0FycmF5KCkuZm9yRWFjaCgoZikgPT4ge1xuICAgIGlmIChhKSB7XG4gICAgICBvID0gYCR7b30ke1ooZil9YDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGYudHlwZSA9PT0gXCJPcGVyYXRvclwiICYmIGYudmFsdWUgPT09IFwiLFwiKSB7XG4gICAgICBhID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHUucHVzaChmKTtcbiAgfSk7XG4gIGxldCBbaSwgY10gPSB1O1xuICBpZiAoYyB8fCAoYyA9IGksIGkgPSB2b2lkIDApLCBpICYmIChvZShpKSAmJiBpLm5hbWUuc3RhcnRzV2l0aChcIi0tXCIpID8gbiA9IGkubmFtZSA6IHdlKGkpICYmIGkuY2hpbGRyZW4uZmlyc3QgJiYgKGwgPSBpLmNoaWxkcmVuLmZpcnN0Lm5hbWUpKSwgYylcbiAgICBpZiAoT2UodCkpIHtcbiAgICAgIGlmIChvZShjKSAmJiBaaShjLm5hbWUpKVxuICAgICAgICBzID0gYy5uYW1lO1xuICAgICAgZWxzZSBpZiAoanAoYykpIHtcbiAgICAgICAgY29uc3QgZiA9IE51bWJlcihjLnZhbHVlKTtcbiAgICAgICAgcyA9IE51bWJlci5pc05hTihmKSA/IHZvaWQgMCA6IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIG1uKHQpICYmIG9lKGMpICYmIGhoKGMubmFtZSkgJiYgKHIgPSBjLm5hbWUpO1xuICBjb25zdCBoID0gYC0tYW5jaG9yLSR7bHQoMTIpfWA7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHQsIHtcbiAgICB0eXBlOiBcIlJhd1wiLFxuICAgIHZhbHVlOiBgdmFyKCR7aH0pYCxcbiAgICBjaGlsZHJlbjogbnVsbFxuICB9KSwgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0LCBcIm5hbWVcIiksIHtcbiAgICBhbmNob3JOYW1lOiBuLFxuICAgIGFuY2hvclNpZGU6IHMsXG4gICAgYW5jaG9yU2l6ZTogcixcbiAgICBmYWxsYmFja1ZhbHVlOiBvIHx8IFwiMHB4XCIsXG4gICAgY3VzdG9tUHJvcE5hbWU6IGwsXG4gICAgdXVpZDogaFxuICB9O1xufVxuZnVuY3Rpb24gRXModCkge1xuICByZXR1cm4gdC52YWx1ZS5jaGlsZHJlbi5tYXAoKHsgbmFtZTogZSB9KSA9PiBlKTtcbn1cbmxldCBIdCA9IHt9LCBFdCA9IHt9LCBOdCA9IHt9LCBhZSA9IHt9LCBJdCA9IHt9O1xuZnVuY3Rpb24gQnAoKSB7XG4gIEh0ID0ge30sIEV0ID0ge30sIE50ID0ge30sIGFlID0ge30sIEl0ID0ge307XG59XG5mdW5jdGlvbiBXcCh0LCBlKSB7XG4gIHZhciBuO1xuICBpZiAoKE9lKHQpIHx8IG1uKHQpKSAmJiBlKSB7XG4gICAgaWYgKGUucHJvcGVydHkuc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICBjb25zdCBzID0gWihlLnZhbHVlKSwgciA9IHZzKHQpO1xuICAgICAgcmV0dXJuIGFlW3IudXVpZF0gPSBzLCBOdFtlLnByb3BlcnR5XSA9IFtcbiAgICAgICAgLi4uKG4gPSBOdFtlLnByb3BlcnR5XSkgIT0gbnVsbCA/IG4gOiBbXSxcbiAgICAgICAgclxuICAgICAgXSwgeyBjaGFuZ2VkOiAhMCB9O1xuICAgIH1cbiAgICBpZiAoT2UodCkgJiYgdWUoZS5wcm9wZXJ0eSkgfHwgbW4odCkgJiYgSmkoZS5wcm9wZXJ0eSkpIHtcbiAgICAgIGNvbnN0IHMgPSB2cyh0KTtcbiAgICAgIHJldHVybiB7IHByb3A6IGUucHJvcGVydHksIGRhdGE6IHMsIGNoYW5nZWQ6ICEwIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uICRzKHQsIGUsIG4pIHtcbiAgcmV0dXJuIFIodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgcyA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYW5jaG9yTmFtZTtcbiAgICBjb25zdCByID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5jdXN0b21Qcm9wTmFtZTtcbiAgICBpZiAodCAmJiAhcykge1xuICAgICAgY29uc3QgdSA9IG90KFxuICAgICAgICB0LFxuICAgICAgICBcInBvc2l0aW9uLWFuY2hvclwiXG4gICAgICApO1xuICAgICAgdSA/IHMgPSB1IDogciAmJiAocyA9IG90KHQsIHIpKTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHMgPyBIdFtzXSB8fCBbXSA6IFtdLCBhID0gcyA/IEV0W2lvLkFsbF0gfHwgW10gOiBbXSwgbCA9IHMgPyBFdFtzXSB8fCBbXSA6IFtdO1xuICAgIHJldHVybiB5aWVsZCBEcChcbiAgICAgIHQsXG4gICAgICBzIHx8IG51bGwsXG4gICAgICBvLFxuICAgICAgWy4uLmEsIC4uLmxdLFxuICAgICAgeyByb290czogbi5yb290cyB9XG4gICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVcCh0LCBlKSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIGgsIGYsIHAsIGQsIG0sIGssIHksIHgsIEEsIE0sIGV0O1xuICAgIGNvbnN0IG4gPSB7fSwgcyA9IHt9O1xuICAgIEJwKCk7XG4gICAgY29uc3QgeyBmYWxsYmFja1RhcmdldHM6IHIsIHZhbGlkUG9zaXRpb25zOiBvIH0gPSBPcCh0KTtcbiAgICBmb3IgKGNvbnN0IHcgb2YgdCkge1xuICAgICAgbGV0IEMgPSAhMTtcbiAgICAgIGNvbnN0IE8gPSBMdCh3LmNzcyk7XG4gICAgICAkdChPLCBmdW5jdGlvbihQKSB7XG4gICAgICAgIHZhciBKLCB4dCwgT3QsIEN0LCBwdCwgd3Q7XG4gICAgICAgIGNvbnN0IE4gPSAoSiA9IHRoaXMucnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEoucHJlbHVkZSwgJCA9IGZuKE4pO1xuICAgICAgICBpZiAoRnAoUCkgJiYgJC5sZW5ndGgpXG4gICAgICAgICAgZm9yIChjb25zdCBCIG9mIEVzKFApKVxuICAgICAgICAgICAgKHh0ID0gSHRbQl0pICE9IG51bGwgfHwgKEh0W0JdID0gW10pLCBIdFtCXS5wdXNoKC4uLiQpO1xuICAgICAgICBpZiAoTXAoUCkgJiYgJC5sZW5ndGgpXG4gICAgICAgICAgZm9yIChjb25zdCBCIG9mIEVzKFApKVxuICAgICAgICAgICAgKE90ID0gRXRbQl0pICE9IG51bGwgfHwgKEV0W0JdID0gW10pLCBFdFtCXS5wdXNoKC4uLiQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHJvcDogdixcbiAgICAgICAgICBkYXRhOiBqLFxuICAgICAgICAgIGNoYW5nZWQ6IERcbiAgICAgICAgfSA9IFdwKFAsIHRoaXMuZGVjbGFyYXRpb24pO1xuICAgICAgICBpZiAodiAmJiBqICYmICQubGVuZ3RoKVxuICAgICAgICAgIGZvciAoY29uc3QgeyBzZWxlY3RvcjogQiB9IG9mICQpXG4gICAgICAgICAgICBuW0JdID0gcShVKHt9LCBuW0JdKSwge1xuICAgICAgICAgICAgICBbdl06IFsuLi4ocHQgPSAoQ3QgPSBuW0JdKSA9PSBudWxsID8gdm9pZCAwIDogQ3Rbdl0pICE9IG51bGwgPyBwdCA6IFtdLCBqXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxldCBIO1xuICAgICAgICBpZiAodGhpcy5ibG9jayAmJiAoSCA9IHRwKFApLCBIKSkge1xuICAgICAgICAgIGVwKFxuICAgICAgICAgICAgSCxcbiAgICAgICAgICAgIHRoaXMuYmxvY2tcbiAgICAgICAgICApO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBzZWxlY3RvcjogQiB9IG9mICQpXG4gICAgICAgICAgICBzW0JdID0gW1xuICAgICAgICAgICAgICAuLi4od3QgPSBzW0JdKSAhPSBudWxsID8gd3QgOiBbXSxcbiAgICAgICAgICAgICAgSFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICAoRCB8fCBIKSAmJiAoQyA9ICEwKTtcbiAgICAgIH0pLCBDICYmICh3LmNzcyA9IFooTyksIHcuY2hhbmdlZCA9ICEwKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IG5ldyBTZXQoT2JqZWN0LmtleXMoTnQpKSwgbCA9IHt9LCB1ID0gKHcpID0+IHtcbiAgICAgIHZhciBQLCBOLCAkLCB2LCBqO1xuICAgICAgY29uc3QgQyA9IFtdLCBPID0gbmV3IFNldCgoTiA9IChQID0gbFt3XSkgPT0gbnVsbCA/IHZvaWQgMCA6IFAubmFtZXMpICE9IG51bGwgPyBOIDogW10pO1xuICAgICAgZm9yICg7IE8uc2l6ZSA+IDA7IClcbiAgICAgICAgZm9yIChjb25zdCBEIG9mIE8pXG4gICAgICAgICAgQy5wdXNoKC4uLigkID0gTnRbRF0pICE9IG51bGwgPyAkIDogW10pLCBPLmRlbGV0ZShEKSwgKGogPSAodiA9IGxbRF0pID09IG51bGwgPyB2b2lkIDAgOiB2Lm5hbWVzKSAhPSBudWxsICYmIGoubGVuZ3RoICYmIGxbRF0ubmFtZXMuZm9yRWFjaCgoSCkgPT4gTy5hZGQoSCkpO1xuICAgICAgcmV0dXJuIEM7XG4gICAgfTtcbiAgICBmb3IgKDsgYS5zaXplID4gMDsgKSB7XG4gICAgICBjb25zdCB3ID0gW107XG4gICAgICBmb3IgKGNvbnN0IEMgb2YgdCkge1xuICAgICAgICBsZXQgTyA9ICExO1xuICAgICAgICBjb25zdCBQID0gTHQoQy5jc3MpO1xuICAgICAgICAkdChQLCB7XG4gICAgICAgICAgdmlzaXQ6IFwiRnVuY3Rpb25cIixcbiAgICAgICAgICBlbnRlcihOKSB7XG4gICAgICAgICAgICB2YXIgRCwgSDtcbiAgICAgICAgICAgIGNvbnN0ICQgPSAoRCA9IHRoaXMucnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEQucHJlbHVkZSwgdiA9IHRoaXMuZGVjbGFyYXRpb24sIGogPSB2ID09IG51bGwgPyB2b2lkIDAgOiB2LnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCgkID09IG51bGwgPyB2b2lkIDAgOiAkLmNoaWxkcmVuLmlzRW1wdHkpID09PSAhMSAmJiB3ZShOKSAmJiB2ICYmIGogJiYgTi5jaGlsZHJlbi5maXJzdCAmJiBhLmhhcyhOLmNoaWxkcmVuLmZpcnN0Lm5hbWUpICYmIC8vIEZvciBub3csIHdlIG9ubHkgd2FudCBhc3NpZ25tZW50cyB0byBvdGhlciBDU1MgY3VzdG9tIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGouc3RhcnRzV2l0aChcIi0tXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEogPSBOLmNoaWxkcmVuLmZpcnN0LCB4dCA9IChIID0gTnRbSi5uYW1lXSkgIT0gbnVsbCA/IEggOiBbXSwgT3QgPSB1KEoubmFtZSk7XG4gICAgICAgICAgICAgIGlmICghKHh0Lmxlbmd0aCB8fCBPdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgY29uc3QgQ3QgPSBgJHtKLm5hbWV9LWFuY2hvci0ke2x0KDEyKX1gLCBwdCA9IFoodi52YWx1ZSk7XG4gICAgICAgICAgICAgIGFlW0N0XSA9IHB0LCBsW2pdIHx8IChsW2pdID0geyBuYW1lczogW10sIHV1aWRzOiBbXSB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgd3QgPSBsW2pdO1xuICAgICAgICAgICAgICB3dC5uYW1lcy5pbmNsdWRlcyhKLm5hbWUpIHx8IHd0Lm5hbWVzLnB1c2goSi5uYW1lKSwgd3QudXVpZHMucHVzaChDdCksIHcucHVzaChqKSwgSi5uYW1lID0gQ3QsIE8gPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBPICYmIChDLmNzcyA9IFooUCksIEMuY2hhbmdlZCA9ICEwKTtcbiAgICAgIH1cbiAgICAgIGEuY2xlYXIoKSwgdy5mb3JFYWNoKChDKSA9PiBhLmFkZChDKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdyBvZiB0KSB7XG4gICAgICBsZXQgQyA9ICExO1xuICAgICAgY29uc3QgTyA9IEx0KHcuY3NzKTtcbiAgICAgICR0KE8sIHtcbiAgICAgICAgdmlzaXQ6IFwiRnVuY3Rpb25cIixcbiAgICAgICAgZW50ZXIoUCkge1xuICAgICAgICAgIHZhciBqLCBELCBILCBKLCB4dCwgT3QsIEN0O1xuICAgICAgICAgIGNvbnN0IE4gPSAoaiA9IHRoaXMucnVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGoucHJlbHVkZSwgJCA9IHRoaXMuZGVjbGFyYXRpb24sIHYgPSAkID09IG51bGwgPyB2b2lkIDAgOiAkLnByb3BlcnR5O1xuICAgICAgICAgIGlmICgoTiA9PSBudWxsID8gdm9pZCAwIDogTi5jaGlsZHJlbi5pc0VtcHR5KSA9PT0gITEgJiYgd2UoUCkgJiYgJCAmJiB2ICYmIFAuY2hpbGRyZW4uZmlyc3QgJiYgLy8gTm93IHdlIG9ubHkgd2FudCBhc3NpZ25tZW50cyB0byBpbnNldC9zaXppbmcgcHJvcGVydGllc1xuICAgICAgICAgICh1ZSh2KSB8fCBRaSh2KSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gUC5jaGlsZHJlbi5maXJzdCwgd3QgPSAoRCA9IE50W3B0Lm5hbWVdKSAhPSBudWxsID8gRCA6IFtdLCBCID0gdShwdC5uYW1lKTtcbiAgICAgICAgICAgIGlmICghKHd0Lmxlbmd0aCB8fCBCLmxlbmd0aCkpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGZlID0gYCR7dn0tJHtsdCgxMil9YDtcbiAgICAgICAgICAgIGlmIChCLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBqdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtwdC5uYW1lXSk7XG4gICAgICAgICAgICAgIGZvciAoOyBqdC5zaXplID4gMDsgKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgQnQgb2YganQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IEcgPSBsW0J0XTtcbiAgICAgICAgICAgICAgICAgIGlmICgoSCA9IEcgPT0gbnVsbCA/IHZvaWQgMCA6IEcubmFtZXMpICE9IG51bGwgJiYgSC5sZW5ndGggJiYgKChKID0gRyA9PSBudWxsID8gdm9pZCAwIDogRy51dWlkcykgIT0gbnVsbCAmJiBKLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgV3Qgb2YgRy5uYW1lcylcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFV0IG9mIEcudXVpZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBJdFtVdF0gPSBxKFUoe30sIEl0W1V0XSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBga2V5YCAoYHByb3BVdWlkYCkgaXMgdGhlIHByb3BlcnR5LXNwZWNpZmljXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdXVpZCB0byBhcHBlbmQgdG8gdGhlIG5ldyBjdXN0b20gcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGB2YWx1ZWAgaXMgdGhlIG5ldyBwcm9wZXJ0eS1zcGVjaWZpYyBjdXN0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eSB2YWx1ZSB0byB1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZlXTogYCR7V3R9LSR7ZmV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBqdC5kZWxldGUoQnQpLCAoeHQgPSBHID09IG51bGwgPyB2b2lkIDAgOiBHLm5hbWVzKSAhPSBudWxsICYmIHh0Lmxlbmd0aCAmJiBHLm5hbWVzLmZvckVhY2goKFd0KSA9PiBqdC5hZGQoV3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtbyA9IGZuKE4pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBqdCBvZiBbLi4ud3QsIC4uLkJdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEJ0ID0gVSh7fSwganQpLCBHID0gYC0tYW5jaG9yLSR7bHQoMTIpfS0ke3Z9YCwgV3QgPSBCdC51dWlkO1xuICAgICAgICAgICAgICBCdC51dWlkID0gRztcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHNlbGVjdG9yOiBVdCB9IG9mIG1vKVxuICAgICAgICAgICAgICAgIG5bVXRdID0gcShVKHt9LCBuW1V0XSksIHtcbiAgICAgICAgICAgICAgICAgIFt2XTogWy4uLihDdCA9IChPdCA9IG5bVXRdKSA9PSBudWxsID8gdm9pZCAwIDogT3Rbdl0pICE9IG51bGwgPyBDdCA6IFtdLCBCdF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgSXRbV3RdID0gcShVKHt9LCBJdFtXdF0pLCB7XG4gICAgICAgICAgICAgICAgLy8gLSBga2V5YCAoYHByb3BVdWlkYCkgaXMgdGhlIHByb3BlcnR5LXNwZWNpZmljXG4gICAgICAgICAgICAgICAgLy8gICB1dWlkIHRvIGFwcGVuZCB0byB0aGUgbmV3IGN1c3RvbSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgICAgICAgICAgLy8gLSBgdmFsdWVgIGlzIHRoZSBuZXcgcHJvcGVydHktc3BlY2lmaWMgY3VzdG9tXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eSB2YWx1ZSB0byB1c2VcbiAgICAgICAgICAgICAgICBbZmVdOiBHXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHQubmFtZSA9IGAke3B0Lm5hbWV9LSR7ZmV9YCwgQyA9ICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksIEMgJiYgKHcuY3NzID0gWihPKSwgdy5jaGFuZ2VkID0gITApO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoSXQpLmxlbmd0aCA+IDApXG4gICAgICBmb3IgKGNvbnN0IHcgb2YgdCkge1xuICAgICAgICBsZXQgQyA9ICExO1xuICAgICAgICBjb25zdCBPID0gTHQody5jc3MpO1xuICAgICAgICAkdChPLCB7XG4gICAgICAgICAgdmlzaXQ6IFwiRnVuY3Rpb25cIixcbiAgICAgICAgICBlbnRlcihQKSB7XG4gICAgICAgICAgICB2YXIgTiwgJCwgdiwgajtcbiAgICAgICAgICAgIGlmICh3ZShQKSAmJiAoKCQgPSAoTiA9IFAuY2hpbGRyZW4uZmlyc3QpID09IG51bGwgPyB2b2lkIDAgOiBOLm5hbWUpICE9IG51bGwgJiYgJC5zdGFydHNXaXRoKFwiLS1cIikpICYmICgoaiA9ICh2ID0gdGhpcy5kZWNsYXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHYucHJvcGVydHkpICE9IG51bGwgJiYgai5zdGFydHNXaXRoKFwiLS1cIikpICYmIHRoaXMuYmxvY2spIHtcbiAgICAgICAgICAgICAgY29uc3QgRCA9IFAuY2hpbGRyZW4uZmlyc3QsIEggPSBJdFtELm5hbWVdO1xuICAgICAgICAgICAgICBpZiAoSClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtKLCB4dF0gb2YgT2JqZWN0LmVudHJpZXMoSCkpXG4gICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrLmNoaWxkcmVuLmFwcGVuZERhdGEoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkRlY2xhcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogITEsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBgJHt0aGlzLmRlY2xhcmF0aW9uLnByb3BlcnR5fS0ke0p9YCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlJhd1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBaKHRoaXMuZGVjbGFyYXRpb24udmFsdWUpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBgdmFyKCR7RC5uYW1lfSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgYHZhcigke3h0fSlgXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgQyA9ICEwO1xuICAgICAgICAgICAgICBhZVtELm5hbWVdICYmICh0aGlzLmRlY2xhcmF0aW9uLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUmF3XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFlW0QubmFtZV1cbiAgICAgICAgICAgICAgfSwgQyA9ICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBDICYmICh3LmNzcyA9IFooTyksIHcuY2hhbmdlZCA9ICEwKTtcbiAgICAgIH1cbiAgICBjb25zdCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFt3LCBDXSBvZiBPYmplY3QuZW50cmllcyhuKSkge1xuICAgICAgbGV0IE87XG4gICAgICB3LnN0YXJ0c1dpdGgoXCJbZGF0YS1hbmNob3ItcG9seWZpbGw9XCIpICYmICgoaCA9IHJbd10pICE9IG51bGwgJiYgaC5sZW5ndGgpID8gTyA9IGllKFxuICAgICAgICBlLnJvb3RzLFxuICAgICAgICByW3ddLmpvaW4oXCIsXCIpXG4gICAgICApIDogTyA9IGllKGUucm9vdHMsIHcpO1xuICAgICAgZm9yIChjb25zdCBbUCwgTl0gb2YgT2JqZWN0LmVudHJpZXMoQykpXG4gICAgICAgIGZvciAoY29uc3QgJCBvZiBOKVxuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBPKSB7XG4gICAgICAgICAgICBjb25zdCBqID0geWllbGQgJHModiwgJCwge1xuICAgICAgICAgICAgICByb290czogZS5yb290c1xuICAgICAgICAgICAgfSksIEQgPSBgLS1hbmNob3ItJHtsdCgxMil9YDtcbiAgICAgICAgICAgIGkuc2V0KHYsIHEoVSh7fSwgKGYgPSBpLmdldCh2KSkgIT0gbnVsbCA/IGYgOiB7fSksIHtcbiAgICAgICAgICAgICAgWyQudXVpZF06IERcbiAgICAgICAgICAgIH0pKSwgdi5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIFwic3R5bGVcIixcbiAgICAgICAgICAgICAgYCR7JC51dWlkfTogdmFyKCR7RH0pOyAkeyhwID0gdi5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkgIT0gbnVsbCA/IHAgOiBcIlwifWBcbiAgICAgICAgICAgICksIG9bd10gPSBxKFUoe30sIG9bd10pLCB7XG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogcShVKHt9LCAoZCA9IG9bd10pID09IG51bGwgPyB2b2lkIDAgOiBkLmRlY2xhcmF0aW9ucyksIHtcbiAgICAgICAgICAgICAgICBbUF06IFtcbiAgICAgICAgICAgICAgICAgIC4uLih5ID0gKGsgPSAobSA9IG9bd10pID09IG51bGwgPyB2b2lkIDAgOiBtLmRlY2xhcmF0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IGtbUF0pICE9IG51bGwgPyB5IDogW10sXG4gICAgICAgICAgICAgICAgICBxKFUoe30sICQpLCB7IGFuY2hvckVsOiBqLCB0YXJnZXRFbDogdiwgdXVpZDogRCB9KVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYyA9IHtcbiAgICAgIGVsOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSxcbiAgICAgIGNoYW5nZWQ6ICExLFxuICAgICAgY3JlYXRlZDogITAsXG4gICAgICBjc3M6IFwiXCJcbiAgICB9O1xuICAgIHQucHVzaChjKTtcbiAgICBmb3IgKGNvbnN0IFt3LCBDXSBvZiBPYmplY3QuZW50cmllcyhzKSkge1xuICAgICAgY29uc3QgTyA9IGllKGUucm9vdHMsIHcpO1xuICAgICAgZm9yIChjb25zdCBQIG9mIE8pIHtcbiAgICAgICAgY29uc3QgTiA9IHlpZWxkICRzKFAsIG51bGwsIHtcbiAgICAgICAgICByb290czogZS5yb290c1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCAkIG9mIEMpIHtcbiAgICAgICAgICBjb25zdCB2ID0geWllbGQgc3AoXG4gICAgICAgICAgICBQLFxuICAgICAgICAgICAgJCxcbiAgICAgICAgICAgIE5cbiAgICAgICAgICApO1xuICAgICAgICAgIGMuY3NzICs9IHJwKFxuICAgICAgICAgICAgdi50YXJnZXRVVUlELFxuICAgICAgICAgICAgJC5zZWxlY3RvclVVSURcbiAgICAgICAgICApLCBjLmNoYW5nZWQgPSAhMCwgb1t3XSA9IHEoVSh7fSwgb1t3XSksIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogcShVKHt9LCAoeCA9IG9bd10pID09IG51bGwgPyB2b2lkIDAgOiB4LmRlY2xhcmF0aW9ucyksIHtcbiAgICAgICAgICAgICAgXCJwb3NpdGlvbi1hcmVhXCI6IFtcbiAgICAgICAgICAgICAgICAuLi4oZXQgPSAoTSA9IChBID0gb1t3XSkgPT0gbnVsbCA/IHZvaWQgMCA6IEEuZGVjbGFyYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogTVtcInBvc2l0aW9uLWFyZWFcIl0pICE9IG51bGwgPyBldCA6IFtdLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBydWxlczogbywgaW5saW5lU3R5bGVzOiBpLCBhbmNob3JTY29wZXM6IEV0IH07XG4gIH0pO1xufVxuY29uc3QgenAgPSBbXG4gIFwiYXNcIixcbiAgXCJibG9ja2luZ1wiLFxuICBcImNyb3Nzb3JpZ2luXCIsXG4gIC8vICdkaXNhYmxlZCcgaXMgbm90IHJlbGV2YW50IGZvciBzdHlsZSBlbGVtZW50cywgYnV0IHRoaXMgZXhjbHVzaW9uIGlzXG4gIC8vIHRoZW9yZXRpY2FsLCBhcyBhIDxsaW5rIHJlbD1zdHlsZXNoZWV0IGRpc2FibGVkPiB3aWxsIG5vdCBiZSBsb2FkZWQsIGFuZFxuICAvLyB3aWxsIG5vdCByZWFjaCB0aGlzIHBhcnQgb2YgdGhlIHBvbHlmaWxsLiBTZWUgIzI0Ni5cbiAgXCJkaXNhYmxlZFwiLFxuICBcImZldGNocHJpb3JpdHlcIixcbiAgXCJocmVmXCIsXG4gIFwiaHJlZmxhbmdcIixcbiAgXCJpbnRlZ3JpdHlcIixcbiAgXCJyZWZlcnJlcnBvbGljeVwiLFxuICBcInJlbFwiLFxuICBcInR5cGVcIlxuXTtcbmZ1bmN0aW9uIExzKHQsIGUsIG4gPSAhMSkge1xuICBjb25zdCBzID0gW107XG4gIGZvciAoY29uc3QgeyBlbDogciwgY3NzOiBvLCBjaGFuZ2VkOiBhLCBjcmVhdGVkOiBsID0gITEgfSBvZiB0KSB7XG4gICAgY29uc3QgdSA9IHsgZWw6IHIsIGNzczogbywgY2hhbmdlZDogITEgfTtcbiAgICBpZiAoYSkge1xuICAgICAgaWYgKHIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN0eWxlXCIpXG4gICAgICAgIHIuaW5uZXJIVE1MID0gbztcbiAgICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgaS50ZXh0Q29udGVudCA9IG87XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiByLmdldEF0dHJpYnV0ZU5hbWVzKCkpXG4gICAgICAgICAgaWYgKCFjLnN0YXJ0c1dpdGgoXCJvblwiKSAmJiAhenAuaW5jbHVkZXMoYykpIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSByLmdldEF0dHJpYnV0ZShjKTtcbiAgICAgICAgICAgIGggIT09IG51bGwgJiYgaS5zZXRBdHRyaWJ1dGUoYywgaCk7XG4gICAgICAgICAgfVxuICAgICAgICByLmhhc0F0dHJpYnV0ZShcImhyZWZcIikgJiYgaS5zZXRBdHRyaWJ1dGUoXCJkYXRhLW9yaWdpbmFsLWhyZWZcIiwgci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSwgbCA/IChpLnNldEF0dHJpYnV0ZShcImRhdGEtZ2VuZXJhdGVkLWJ5LXBvbHlmaWxsXCIsIFwidHJ1ZVwiKSwgZG9jdW1lbnQuaGVhZC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgaSkpIDogKHIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYmVmb3JlYmVnaW5cIiwgaSksIHIucmVtb3ZlKCkpLCB1LmVsID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoci5oYXNBdHRyaWJ1dGUoXCJkYXRhLWhhcy1pbmxpbmUtc3R5bGVzXCIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSByLmdldEF0dHJpYnV0ZShcImRhdGEtaGFzLWlubGluZS1zdHlsZXNcIik7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGBbZGF0YS1oYXMtaW5saW5lLXN0eWxlcz1cIiR7aX1cIl17YDtcbiAgICAgICAgICBsZXQgZiA9IG8uc2xpY2UoYy5sZW5ndGgsIDAgLSBcIn1cIi5sZW5ndGgpO1xuICAgICAgICAgIGNvbnN0IHAgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmdldChyKTtcbiAgICAgICAgICBpZiAocClcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2QsIG1dIG9mIE9iamVjdC5lbnRyaWVzKHApKVxuICAgICAgICAgICAgICBmID0gYCR7ZH06IHZhcigke219KTsgJHtmfWA7XG4gICAgICAgICAgci5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuICYmIHIuaGFzQXR0cmlidXRlKFwiZGF0YS1oYXMtaW5saW5lLXN0eWxlc1wiKSAmJiByLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtaGFzLWlubGluZS1zdHlsZXNcIiksIHMucHVzaCh1KTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmNvbnN0IFZwID0gcShVKHt9LCBWKSwgeyBfYzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSB9KSwgSHAgPSAodCwgZSkgPT4ge1xuICBsZXQgbjtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgY2FzZSBcInNlbGYtc3RhcnRcIjpcbiAgICAgIG4gPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgIGNhc2UgXCJzZWxmLWVuZFwiOlxuICAgICAgbiA9IDEwMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0eXBlb2YgdCA9PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odCkgJiYgKG4gPSB0KTtcbiAgfVxuICBpZiAobiAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBlID8gMTAwIC0gbiA6IG47XG59LCBHcCA9ICh0LCBlKSA9PiB7XG4gIGxldCBuO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICBjYXNlIFwic2VsZi1ibG9ja1wiOlxuICAgICAgbiA9IGUgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlubGluZVwiOlxuICAgIGNhc2UgXCJzZWxmLWlubGluZVwiOlxuICAgICAgbiA9IGUgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG47XG59LCBQcyA9ICh0KSA9PiB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICByZXR1cm4gXCJ5XCI7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBcInhcIjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0sIHFwID0gKHQpID0+IHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInhcIjpcbiAgICAgIHJldHVybiBcIndpZHRoXCI7XG4gICAgY2FzZSBcInlcIjpcbiAgICAgIHJldHVybiBcImhlaWdodFwiO1xuICB9XG4gIHJldHVybiBudWxsO1xufSwgT3MgPSAodCkgPT4gb3QodCwgXCJkaXNwbGF5XCIpID09PSBcImlubGluZVwiLCBScyA9ICh0LCBlKSA9PiAoZSA9PT0gXCJ4XCIgPyBbXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiXSA6IFtcImJvcmRlci10b3Atd2lkdGhcIiwgXCJib3JkZXItYm90dG9tLXdpZHRoXCJdKS5yZWR1Y2UoXG4gIChzLCByKSA9PiBzICsgcGFyc2VJbnQob3QodCwgciksIDEwKSxcbiAgMFxuKSB8fCAwLCBTZSA9ICh0LCBlKSA9PiBwYXJzZUludChvdCh0LCBgbWFyZ2luLSR7ZX1gKSwgMTApIHx8IDAsIEtwID0gKHQpID0+ICh7XG4gIHRvcDogU2UodCwgXCJ0b3BcIiksXG4gIHJpZ2h0OiBTZSh0LCBcInJpZ2h0XCIpLFxuICBib3R0b206IFNlKHQsIFwiYm90dG9tXCIpLFxuICBsZWZ0OiBTZSh0LCBcImxlZnRcIilcbn0pLCBlbiA9IChhKSA9PiBSKG51bGwsIFthXSwgZnVuY3Rpb24qICh7XG4gIHRhcmdldEVsOiB0LFxuICB0YXJnZXRQcm9wZXJ0eTogZSxcbiAgYW5jaG9yUmVjdDogbixcbiAgYW5jaG9yU2lkZTogcyxcbiAgYW5jaG9yU2l6ZTogcixcbiAgZmFsbGJhY2s6IG8gPSBudWxsXG59KSB7XG4gIHZhciBsO1xuICBpZiAoISgociB8fCBzICE9PSB2b2lkIDApICYmIHQgJiYgbikpXG4gICAgcmV0dXJuIG87XG4gIGlmIChyKSB7XG4gICAgaWYgKCFKaShlKSlcbiAgICAgIHJldHVybiBvO1xuICAgIGxldCB1O1xuICAgIHN3aXRjaCAocikge1xuICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgIHUgPSByO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbGV0IGkgPSAhMTtcbiAgICAgICAgY29uc3QgYyA9IG90KHQsIFwid3JpdGluZy1tb2RlXCIpO1xuICAgICAgICBpID0gYy5zdGFydHNXaXRoKFwidmVydGljYWwtXCIpIHx8IGMuc3RhcnRzV2l0aChcInNpZGV3YXlzLVwiKSwgdSA9IEdwKHIsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdSA/IGAke25bdV19cHhgIDogbztcbiAgfVxuICBpZiAocyAhPT0gdm9pZCAwKSB7XG4gICAgbGV0IHUsIGk7XG4gICAgY29uc3QgYyA9IFBzKGUpO1xuICAgIGlmICghKHVlKGUpICYmIGMgJiYgKCF1ZShzKSB8fCBjID09PSBQcyhzKSkpKVxuICAgICAgcmV0dXJuIG87XG4gICAgY29uc3QgaCA9IFtcInRvcFwiLCBcImxlZnRcIl07XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICB1ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgdSA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgIHUgPSA1MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5zaWRlXCI6XG4gICAgICAgIHUgPSBoLmluY2x1ZGVzKGUpID8gMCA6IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib3V0c2lkZVwiOlxuICAgICAgICB1ID0gaC5pbmNsdWRlcyhlKSA/IDEwMCA6IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICBjb25zdCBkID0gKHlpZWxkIChsID0gVi5pc1JUTCkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuY2FsbChWLCB0KSkgfHwgITE7XG4gICAgICAgICAgdSA9IEhwKHMsIGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGYgPSB0eXBlb2YgdSA9PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odSksIHAgPSBxcChjKTtcbiAgICBpZiAoZiAmJiBwKSB7XG4gICAgICAoZSA9PT0gXCJib3R0b21cIiB8fCBlID09PSBcInJpZ2h0XCIpICYmIChpID0geWllbGQgdm4odCkpO1xuICAgICAgbGV0IGQgPSBuW2NdICsgbltwXSAqICh1IC8gMTAwKTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6IHtcbiAgICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBsZXQgbSA9IGkuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGlmIChtID09PSAwICYmIE9zKGkpKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gUnMoaSwgYyk7XG4gICAgICAgICAgICBtID0gaS5vZmZzZXRIZWlnaHQgLSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkID0gbSAtIGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6IHtcbiAgICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBsZXQgbSA9IGkuY2xpZW50V2lkdGg7XG4gICAgICAgICAgaWYgKG0gPT09IDAgJiYgT3MoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBScyhpLCBjKTtcbiAgICAgICAgICAgIG0gPSBpLm9mZnNldFdpZHRoIC0gaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZCA9IG0gLSBkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7ZH1weGA7XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufSksIFFwID0gKHQpID0+IFwid3JhcHBlckVsXCIgaW4gdCwgWXAgPSAodCkgPT4gXCJ1dWlkXCIgaW4gdDtcbmZ1bmN0aW9uIFhwKHQsIGUgPSAhMSkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgZm9yIChjb25zdCBbcywgcl0gb2YgT2JqZWN0LmVudHJpZXModCkpXG4gICAgICBmb3IgKGNvbnN0IG8gb2Ygcikge1xuICAgICAgICBjb25zdCBhID0gby5hbmNob3JFbCwgbCA9IG8udGFyZ2V0RWw7XG4gICAgICAgIGlmIChhICYmIGwpXG4gICAgICAgICAgaWYgKFFwKG8pKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gby53cmFwcGVyRWwsIGkgPSAoYywgaCwgZikgPT4gUihudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYyA9PT0gMCA/IFwiMHB4XCIgOiB5aWVsZCBlbih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWw6IHUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UHJvcGVydHk6IGgsXG4gICAgICAgICAgICAgICAgYW5jaG9yUmVjdDogZixcbiAgICAgICAgICAgICAgICBhbmNob3JTaWRlOiBjXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBybihcbiAgICAgICAgICAgICAgYSxcbiAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgKCkgPT4gUihudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBvdChcbiAgICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgICBhb1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdS5zZXRBdHRyaWJ1dGUobG8sIGMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSB5aWVsZCBWLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IGEsXG4gICAgICAgICAgICAgICAgICBmbG9hdGluZzogdSxcbiAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcbiAgICAgICAgICAgICAgICB9KSwgZiA9IG8uaW5zZXRzLCBwID0geWllbGQgaShcbiAgICAgICAgICAgICAgICAgIGYuYmxvY2tbMF0sXG4gICAgICAgICAgICAgICAgICBcInRvcFwiLFxuICAgICAgICAgICAgICAgICAgaC5yZWZlcmVuY2VcbiAgICAgICAgICAgICAgICApLCBkID0geWllbGQgaShcbiAgICAgICAgICAgICAgICAgIGYuYmxvY2tbMV0sXG4gICAgICAgICAgICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgaC5yZWZlcmVuY2VcbiAgICAgICAgICAgICAgICApLCBtID0geWllbGQgaShcbiAgICAgICAgICAgICAgICAgIGYuaW5saW5lWzBdLFxuICAgICAgICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICBoLnJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICksIGsgPSB5aWVsZCBpKFxuICAgICAgICAgICAgICAgICAgZi5pbmxpbmVbMV0sXG4gICAgICAgICAgICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICBoLnJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGAke28udGFyZ2V0VVVJRH0tdG9wYCxcbiAgICAgICAgICAgICAgICAgIHAgfHwgbnVsbFxuICAgICAgICAgICAgICAgICksIG4uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICBgJHtvLnRhcmdldFVVSUR9LWxlZnRgLFxuICAgICAgICAgICAgICAgICAgbSB8fCBudWxsXG4gICAgICAgICAgICAgICAgKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGAke28udGFyZ2V0VVVJRH0tcmlnaHRgLFxuICAgICAgICAgICAgICAgICAgayB8fCBudWxsXG4gICAgICAgICAgICAgICAgKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGAke28udGFyZ2V0VVVJRH0tYm90dG9tYCxcbiAgICAgICAgICAgICAgICAgIGQgfHwgbnVsbFxuICAgICAgICAgICAgICAgICksIG4uc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICBgJHtvLnRhcmdldFVVSUR9LWp1c3RpZnktc2VsZmAsXG4gICAgICAgICAgICAgICAgICBvLmFsaWdubWVudHMuaW5saW5lXG4gICAgICAgICAgICAgICAgKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIGAke28udGFyZ2V0VVVJRH0tYWxpZ24tc2VsZmAsXG4gICAgICAgICAgICAgICAgICBvLmFsaWdubWVudHMuYmxvY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgeyBhbmltYXRpb25GcmFtZTogZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcm4oXG4gICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICgpID0+IFIobnVsbCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1ID0geWllbGQgVi5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBhLFxuICAgICAgICAgICAgICAgICAgZmxvYXRpbmc6IGwsXG4gICAgICAgICAgICAgICAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiXG4gICAgICAgICAgICAgICAgfSksIGkgPSB5aWVsZCBlbih7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRFbDogbCxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFByb3BlcnR5OiBzLFxuICAgICAgICAgICAgICAgICAgYW5jaG9yUmVjdDogdS5yZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICBhbmNob3JTaWRlOiBvLmFuY2hvclNpZGUsXG4gICAgICAgICAgICAgICAgICBhbmNob3JTaXplOiBvLmFuY2hvclNpemUsXG4gICAgICAgICAgICAgICAgICBmYWxsYmFjazogby5mYWxsYmFja1ZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbi5zdHlsZS5zZXRQcm9wZXJ0eShvLnV1aWQsIGkpO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgeyBhbmltYXRpb25GcmFtZTogZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIGlmIChZcChvKSkge1xuICAgICAgICAgIGNvbnN0IHUgPSB5aWVsZCBlbih7XG4gICAgICAgICAgICB0YXJnZXRQcm9wZXJ0eTogcyxcbiAgICAgICAgICAgIGFuY2hvclNpZGU6IG8uYW5jaG9yU2lkZSxcbiAgICAgICAgICAgIGFuY2hvclNpemU6IG8uYW5jaG9yU2l6ZSxcbiAgICAgICAgICAgIGZhbGxiYWNrOiBvLmZhbGxiYWNrVmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLnN0eWxlLnNldFByb3BlcnR5KG8udXVpZCwgdSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfcyh0LCBlKSB7XG4gIHJldHVybiBSKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgbiA9IHlpZWxkIFYuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgIHJlZmVyZW5jZTogdCxcbiAgICAgIGZsb2F0aW5nOiB0LFxuICAgICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxuICAgIH0pO1xuICAgIHJldHVybiB5aWVsZCBZbyhcbiAgICAgIHtcbiAgICAgICAgeDogdC5vZmZzZXRMZWZ0LFxuICAgICAgICB5OiB0Lm9mZnNldFRvcCxcbiAgICAgICAgcGxhdGZvcm06IFZwLFxuICAgICAgICByZWN0czogbixcbiAgICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgICBmbG9hdGluZzogdCxcbiAgICAgICAgICByZWZlcmVuY2U6IGVcbiAgICAgICAgfSxcbiAgICAgICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGFkZGluZzogS3AodClcbiAgICAgIH1cbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIEpwKHQsIGUsIG4gPSAhMSkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gICAgZm9yIChjb25zdCByIG9mIHMpIHtcbiAgICAgIGxldCBvID0gITE7XG4gICAgICBjb25zdCBhID0geWllbGQgdm4ocik7XG4gICAgICBybihcbiAgICAgICAgLy8gV2UncmUganVzdCBjaGVja2luZyB3aGV0aGVyIHRoZSB0YXJnZXQgZWxlbWVudCBvdmVyZmxvd3MsIHNvIHdlIGRvbid0XG4gICAgICAgIC8vIGNhcmUgYWJvdXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBhbmNob3IgZWxlbWVudCBpbiB0aGlzIGNhc2UuIFBhc3NpbmcgaW5cbiAgICAgICAgLy8gYW4gZW1wdHkgb2JqZWN0IGluc3RlYWQgb2YgYSByZWZlcmVuY2UgZWxlbWVudCBhdm9pZHMgdW5uZWNlc3NhcmlseVxuICAgICAgICAvLyB3YXRjaGluZyBmb3IgaXJyZWxldmFudCBjaGFuZ2VzLlxuICAgICAgICB7fSxcbiAgICAgICAgcixcbiAgICAgICAgKCkgPT4gUihudWxsLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG8gPSAhMCwgci5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWFuY2hvci1wb2x5ZmlsbFwiKTtcbiAgICAgICAgICBjb25zdCBsID0geWllbGQgX3MociwgYSk7XG4gICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMobCkuZXZlcnkoKHUpID0+IHUgPD0gMCkpIHtcbiAgICAgICAgICAgIHIucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hbmNob3ItcG9seWZpbGwtbGFzdC1zdWNjZXNzZnVsXCIpLCBvID0gITE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgW3UsIHsgdXVpZDogaSB9XSBvZiBlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFuY2hvci1wb2x5ZmlsbFwiLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB5aWVsZCBfcyhyLCBhKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKGMpLmV2ZXJ5KChoKSA9PiBoIDw9IDApKSB7XG4gICAgICAgICAgICAgIHIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbmNob3ItcG9seWZpbGwtbGFzdC1zdWNjZXNzZnVsXCIsIGkpLCBvID0gITE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUgPT09IGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBoID0gci5nZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgXCJkYXRhLWFuY2hvci1wb2x5ZmlsbC1sYXN0LXN1Y2Nlc3NmdWxcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoID8gci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFuY2hvci1wb2x5ZmlsbFwiLCBoKSA6IHIucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1hbmNob3ItcG9seWZpbGxcIiksIG8gPSAhMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgeyBhbmltYXRpb25GcmFtZTogbiwgbGF5b3V0U2hpZnQ6ICExIH1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFpwKHQsIGUgPSAhMSkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIHZhciBuLCBzO1xuICAgIGZvciAoY29uc3QgciBvZiBPYmplY3QudmFsdWVzKHQpKVxuICAgICAgeWllbGQgWHAoKG4gPSByLmRlY2xhcmF0aW9ucykgIT0gbnVsbCA/IG4gOiB7fSwgZSk7XG4gICAgZm9yIChjb25zdCBbciwgb10gb2YgT2JqZWN0LmVudHJpZXModCkpXG4gICAgICB5aWVsZCBKcChcbiAgICAgICAgcixcbiAgICAgICAgKHMgPSBvLmZhbGxiYWNrcykgIT0gbnVsbCA/IHMgOiBbXSxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0ZCh0ID0ge30pIHtcbiAgY29uc3QgZSA9IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiID8geyB1c2VBbmltYXRpb25GcmFtZTogdCB9IDogdCwgbiA9IGUudXNlQW5pbWF0aW9uRnJhbWUgPT09IHZvaWQgMCA/ICEhd2luZG93LlVQREFURV9BTkNIT1JfT05fQU5JTUFUSU9OX0ZSQU1FIDogZS51c2VBbmltYXRpb25GcmFtZTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZS5lbGVtZW50cykgfHwgKGUuZWxlbWVudHMgPSB2b2lkIDApLCAoIUFycmF5LmlzQXJyYXkoZS5yb290cykgfHwgZS5yb290cy5sZW5ndGggPT09IDApICYmIChlLnJvb3RzID0gW2RvY3VtZW50XSksIE9iamVjdC5hc3NpZ24oZSwge1xuICAgIHVzZUFuaW1hdGlvbkZyYW1lOiBuXG4gIH0pO1xufVxuZnVuY3Rpb24gbmQodCkge1xuICByZXR1cm4gUih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGUgPSB0ZChcbiAgICAgIHQgIT0gbnVsbCA/IHQgOiB3aW5kb3cuQU5DSE9SX1BPU0lUSU9OSU5HX1BPTFlGSUxMX09QVElPTlNcbiAgICApO1xuICAgIGxldCBuID0geWllbGQgTmYoZSksIHMgPSB7fSwgcjtcbiAgICBDZigpO1xuICAgIHRyeSB7XG4gICAgICBUZihuKSAmJiAobiA9IExzKG4pKTtcbiAgICAgIGNvbnN0IGEgPSB5aWVsZCBVcChuLCB7IHJvb3RzOiBlLnJvb3RzIH0pO1xuICAgICAgcyA9IGEucnVsZXMsIHIgPSBhLmlubGluZVN0eWxlcztcbiAgICB9IGNhdGNoIChvKSB7XG4gICAgICB0aHJvdyB4ZigpLCBvO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzKS5sZW5ndGggJiYgKExzKG4sIHIsICEwKSwgeWllbGQgWnAocywgZS51c2VBbmltYXRpb25GcmFtZSkpLCBzO1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIG5kIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtYW5jaG9yLXBvc2l0aW9uaW5nLWZuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@oddbird/css-anchor-positioning/dist/css-anchor-positioning-fn.js\n\n}");

/***/ })

}]);